// @ts-nocheck - Desabilita verifica√ß√£o de tipos TypeScript para este arquivo (c√≥digo Deno/Supabase)
// @ts-ignore - Deno imports for Supabase Edge Functions
import { serve } from 'https://deno.land/std@0.208.0/http/server.ts';
// @ts-ignore - ESM imports for Supabase Edge Functions
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3';

// ============================================================================
// üöÄ 19/dez: SISTEMA DE CACHE PARA OTIMIZA√á√ÉO DE PERFORMANCE
// ============================================================================
// Cache reduz queries ao banco em ~70%, economizando recursos
// ============================================================================
interface CacheEntry<T> {
  data: T;
  timestamp: number;
  ttl: number;
}

const MEMORY_CACHE: Map<string, CacheEntry<any>> = new Map();
const CACHE_TTL = {
  PATTERN_MEMORY: 5 * 60 * 1000,    // 5 minutos (muda pouco)
  SIGNAL_WEIGHTS: 10 * 60 * 1000,   // 10 minutos (atualiza raramente)
  KNOWLEDGE_BASE: 15 * 60 * 1000,   // 15 minutos (quase est√°tico)
  MARKET_REGIME: 2 * 60 * 1000,     // 2 minutos (muda mais)
};

function getCached<T>(key: string): T | null {
  const entry = MEMORY_CACHE.get(key);
  if (entry && (Date.now() - entry.timestamp) < entry.ttl) {
    console.log(`üì¶ [CACHE HIT] ${key}`);
    return entry.data as T;
  }
  return null;
}

function setCache<T>(key: string, data: T, ttl: number): void {
  MEMORY_CACHE.set(key, { data, timestamp: Date.now(), ttl });
  console.log(`üíæ [CACHE SET] ${key} (TTL: ${ttl / 1000}s)`);
}

function clearCache(keyPrefix?: string): void {
  if (keyPrefix) {
    for (const key of MEMORY_CACHE.keys()) {
      if (key.startsWith(keyPrefix)) MEMORY_CACHE.delete(key);
    }
  } else {
    MEMORY_CACHE.clear();
  }
}

// ============================================================================
// üîµ CONTINUITY SUITE - Monitoramento Cont√≠nuo de Sinais
// ============================================================================
const TRADE_STATE_TABLE = "trade_state";

// ============================================================================
// üîµ MODO DE PRECIS√ÉO DA IA
// ============================================================================
const NARRATOR_MODE = "FLEX";  // Op√ß√µes: "FLEX" | "STANDARD"

// ============================================================================
// üéØ TRADING MODE - Sistema de Modos de Opera√ß√£o
// ============================================================================
// OBSERVE: Apenas an√°lise, nunca shouldEnter (para estudar mercado)
// PAPER:   Gera sinais e simula trades, mas n√£o executa real
// LIVE:    Execu√ß√£o real - s√≥ ativa se PAPER estiver saud√°vel
// ============================================================================
type TradingMode = 'OBSERVE' | 'PAPER' | 'LIVE';

const TRADING_MODE: TradingMode = (Deno.env.get('TRADING_MODE') as TradingMode) || 'PAPER';

// Configura√ß√µes de seguran√ßa por modo
const MODE_CONFIG = {
  OBSERVE: {
    allowShouldEnter: false,  // Nunca permite entrada
    allowExecution: false,    // Nunca executa
    logLevel: 'verbose',      // Log detalhado para estudo
    minConfidenceScore: 999,  // üîí Nunca atinge
    rangeBoost: 10,           // Boost padr√£o
    experimentalPath: false,  // Sem caminho experimental
    description: 'üîç Modo OBSERVE: Apenas an√°lise, sem trades'
  },
  PAPER: {
    allowShouldEnter: true,   // Permite sinalizar entrada
    allowExecution: false,    // Simula mas n√£o executa real
    logLevel: 'normal',
    minConfidenceScore: 65,   // üéØ GUARD RAIL: Threshold 65 para maior qualidade (ajustado 19/dez)
    rangeBoost: 15,           // üîì +5 boost extra em ranges
    experimentalPath: true,   // üß™ Caminho experimental ativo
    description: 'üìù Modo PAPER: Simula√ß√£o (sem execu√ß√£o real) - Permissivo para aprendizado'
  },
  LIVE: {
    allowShouldEnter: true,   // Permite entrada
    allowExecution: true,     // Executa real
    logLevel: 'minimal',      // Log m√≠nimo para performance
    minConfidenceScore: 65,   // üéØ GUARD RAIL: Threshold 65 para maior qualidade (ajustado 19/dez)
    rangeBoost: 10,           // Boost conservador
    experimentalPath: false,  // üîí Sem experimentos em LIVE
    description: 'üî¥ Modo LIVE: Execu√ß√£o REAL ativada'
  }
};

// ============================================================================
// üéØ 19/dez: Score m√≠nimo por padr√£o baseado em an√°lise cient√≠fica de 5,043 trades (Lovable)
// ============================================================================
// FAIXA IDEAL: 55-65 (maior WR e P&L segundo os dados)
// ============================================================================
const MIN_SCORE_BY_PATTERN: Record<string, number> = {
  // ‚úÖ Padr√µes que funcionam bem com score 55 (MELHOR FAIXA)
  'choch': 55,                    // ChoCh: 73.97% WR com 55-65
  'change of character': 55,
  'range': 55,                    // Range: 66.67% WR com 55-65
  'cunha': 55,                    // Cunha: 53.85% WR
  'wedge': 55,

  // ‚ö†Ô∏è Padr√µes que precisam de score 58-60
  'order block': 58,              // Order Block: ajustado para mais permissivo
  'bandeira': 55,
  'flag': 55,
  'elliott': 58,

  // ‚ö†Ô∏è Padr√µes que precisam de score 60-65 (eram 70-75, muito restritivo)
  'bos': 60,                      // BOS: reduzido de 70 para 60
  'break of structure': 60,
  'hammer': 60,                   // Hammer: reduzido de 70 para 60
  'engulfing': 58,

  // ‚ö†Ô∏è Padr√µes problem√°ticos (reduzido de 75 para 65)
  'shooting star': 65,            // Shooting Star: reduzido para 65
  'doji': 65,
};

// Helper: Obter score m√≠nimo para um padr√£o espec√≠fico
function getMinScoreForPattern(patternName: string): number {
  if (!patternName) return 55; // Default mais permissivo

  const patternLower = patternName.toLowerCase();

  for (const [pattern, score] of Object.entries(MIN_SCORE_BY_PATTERN)) {
    if (patternLower.includes(pattern)) {
      console.log(`üéØ [PATTERN SCORE] "${patternName}" ‚Üí minScore: ${score}`);
      return score;
    }
  }

  // Default: 55 (mais permissivo baseado nos dados)
  console.log(`üéØ [PATTERN SCORE] "${patternName}" ‚Üí minScore: 55 (default)`);
  return 55;
}

// Fun√ß√£o helper para verificar permiss√µes do modo
function getModePermissions() {
  const config = MODE_CONFIG[TRADING_MODE] || MODE_CONFIG.PAPER;
  return {
    mode: TRADING_MODE,
    ...config
  };
}

// Log do modo atual na inicializa√ß√£o
console.log(`\n${'='.repeat(60)}`);
console.log(`üéØ TRADING MODE: ${TRADING_MODE}`);
console.log(`üìã ${MODE_CONFIG[TRADING_MODE]?.description || 'Modo desconhecido'}`);
console.log(`${'='.repeat(60)}\n`);
/**
 * Buscar um trade ativo (n√£o-invasivo, com fallback)
 */ async function getActiveTradeState(supabase, user_id, symbol, timeframe) {
  try {
    // ‚úÖ CORRE√á√ÉO: Usar limit(1) antes de maybeSingle() para evitar erro quando h√° m√∫ltiplos trades ativos
    const { data, error } = await supabase
      .from(TRADE_STATE_TABLE)
      .select("*")
      .eq("user_id", user_id)
      .eq("symbol", symbol)
      .eq("timeframe", timeframe)
      .eq("status", "active")
      .order("created_at", { ascending: false }) // Pegar o mais recente
      .limit(1)
      .maybeSingle();
    if (error) {
      logTrade('warn', 'Erro ao buscar trade_state', { error: error.message });
      return {
        data: null,
        error
      };
    }
    return {
      data,
      error: null
    };
  } catch (err) {
    logTrade('warn', 'Exce√ß√£o ao buscar trade_state', { error: err?.message || err });
    return {
      data: null,
      error: err
    };
  }
}
/**
 * ‚úÖ CORRE√á√ÉO: Calcular equity atual da IA (INITIAL_EQUITY + soma de P&L de trades completados)
 */
async function calculateCurrentAiEquity(supabase) {
  try {
    const INITIAL_EQUITY = 10000; // ‚úÖ MUDAN√áA: Equity inicial $10,000 (suficiente para 75x leverage)

    // Buscar todos os trades completados do system-ai
    const { data: completedTrades, error } = await supabase
      .from(TRADE_STATE_TABLE)
      .select('pnl')
      .eq('user_id', 'system-ai')
      .eq('status', 'completed')
      .not('pnl', 'is', null);

    if (error) {
      logEngine('warn', 'Erro ao calcular equity', { error: error.message, fallback: INITIAL_EQUITY });
      return INITIAL_EQUITY;
    }

    // Somar todos os P&L
    const totalPnL = completedTrades?.reduce((sum, trade) => {
      const pnl = Number(trade.pnl) || 0;
      return sum + pnl;
    }, 0) || 0;

    let currentEquity = INITIAL_EQUITY + totalPnL;

    // ‚úÖ RENOVA√á√ÉO AUTOM√ÅTICA: Se equity <= 0, resetar para INITIAL_EQUITY
    if (currentEquity <= 0) {
      logEngine('warn', 'Equity zerado ou negativo, resetando', {
        currentEquity: currentEquity.toFixed(2),
        resetTo: INITIAL_EQUITY.toFixed(2)
      });

      // Resetar P&L de todos os trades completados
      try {
        const { error: resetError } = await supabase
          .from(TRADE_STATE_TABLE)
          .update({ pnl: 0 })
          .eq('user_id', 'system-ai')
          .eq('status', 'completed')
          .not('pnl', 'is', null);

        if (resetError) {
          logEngine('warn', 'Erro ao resetar P&L', { error: resetError.message });
        } else {
          logEngine('info', 'P&L resetado automaticamente', { equity: INITIAL_EQUITY.toFixed(2) });
        }
      } catch (resetErr) {
        logEngine('warn', 'Exce√ß√£o ao resetar P&L', { error: resetErr?.message || resetErr });
      }

      currentEquity = INITIAL_EQUITY;
    }

    logEngine('debug', 'Equity atual calculado', {
      current: currentEquity.toFixed(2),
      initial: INITIAL_EQUITY,
      totalPnL: totalPnL.toFixed(2)
    });

    return currentEquity;
  } catch (err) {
    logEngine('warn', 'Exce√ß√£o ao calcular equity', { error: err?.message || err, fallback: 10000 });
    return 10000; // ‚úÖ Fallback para equity inicial $10,000
  }
}

// ============================================================================
// üéØ META DI√ÅRIA: $800 - Reduz posi√ß√£o para 30% ap√≥s atingir
// ============================================================================
const DAILY_PROFIT_TARGET = 800; // Meta di√°ria em d√≥lares
const REDUCED_POSITION_MULTIPLIER = 0.30; // Ap√≥s meta: usar apenas 30% do tamanho normal

/**
 * ‚úÖ Calcular P&L di√°rio do system-ai
 * Soma apenas trades completados HOJE (desde meia-noite UTC)
 * ‚úÖ FIX: Verificar se meta J√Å FOI atingida em algum momento (n√£o s√≥ P&L atual)
 */
async function calculateDailyPnL(supabase) {
  try {
    // In√≠cio do dia atual em UTC
    const todayStart = new Date();
    todayStart.setUTCHours(0, 0, 0, 0);

    const { data: todayTrades, error } = await supabase
      .from(TRADE_STATE_TABLE)
      .select('pnl, completed_at')
      .eq('user_id', 'system-ai')
      .eq('status', 'completed')
      .not('pnl', 'is', null)
      .gte('completed_at', todayStart.toISOString())
      .order('completed_at', { ascending: true }); // ‚úÖ Ordenar para calcular acumulado

    if (error) {
      logEngine('warn', 'Erro ao calcular P&L di√°rio', { error: error.message });
      return { dailyPnL: 0, reachedTarget: false, maxPnL: 0 };
    }

    // ‚úÖ FIX: Calcular P&L acumulado progressivo e encontrar o m√°ximo
    let runningPnL = 0;
    let maxPnL = 0;
    for (const trade of (todayTrades || [])) {
      runningPnL += Number(trade.pnl) || 0;
      if (runningPnL > maxPnL) {
        maxPnL = runningPnL;
      }
    }

    const dailyPnL = runningPnL; // P&L atual
    // ‚úÖ FIX: Meta atingida se M√ÅXIMO do dia >= target (n√£o apenas atual)
    const reachedTarget = maxPnL >= DAILY_PROFIT_TARGET;

    if (reachedTarget) {
      logEngine('info', 'üéØ META DI√ÅRIA TRAVADA!', {
        dailyPnL: `$${dailyPnL.toFixed(2)}`,
        maxPnL: `$${maxPnL.toFixed(2)}`,
        target: `$${DAILY_PROFIT_TARGET}`,
        newPositionSize: `${(REDUCED_POSITION_MULTIPLIER * 100).toFixed(0)}%`,
        status: 'LOCKED - mant√©m 30% at√© fim do dia'
      });
    } else {
      logEngine('debug', 'P&L di√°rio calculado', {
        dailyPnL: `$${dailyPnL.toFixed(2)}`,
        maxPnL: `$${maxPnL.toFixed(2)}`,
        target: `$${DAILY_PROFIT_TARGET}`,
        remaining: `$${(DAILY_PROFIT_TARGET - maxPnL).toFixed(2)}`
      });
    }

    return { dailyPnL, reachedTarget, maxPnL };
  } catch (err) {
    logEngine('warn', 'Exce√ß√£o ao calcular P&L di√°rio', { error: err?.message || err });
    return { dailyPnL: 0, reachedTarget: false, maxPnL: 0 };
  }
}

// ============================================================================
// üß† SISTEMA DE APRENDIZADO EVOLUTIVO - PROMO√á√ÉO AUTOM√ÅTICA DE PADR√ïES
// ============================================================================
// Fase 1: Coleta (15 dias) - Registra todos os padr√µes
// Fase 2: Sele√ß√£o (15 dias) - Promove win_rate >= 65%
// Fase 3: Manuten√ß√£o (cont√≠nuo) - Mant√©m apenas os melhores
// ============================================================================

const PROMOTION_THRESHOLD = 0.65; // 65% win rate para promo√ß√£o
const MIN_TRADES_FOR_PROMOTION = 10; // M√≠nimo de trades para considerar v√°lido
const DEMOTION_THRESHOLD = 0.40; // Abaixo de 40% = rebaixar

/**
 * ‚úÖ Atualiza status do padr√£o baseado em win_rate
 * Status: 'collecting' | 'promoted' | 'disabled'
 */
async function updatePatternStatus(supabase, patternMemoryId, winRate, totalOccurrences) {
  try {
    if (!patternMemoryId || totalOccurrences < MIN_TRADES_FOR_PROMOTION) {
      return; // Ainda coletando dados
    }

    let newStatus = 'collecting';
    let newConfidenceLevel = 'low';
    let newAdaptiveWeight = 1.0;

    if (winRate >= PROMOTION_THRESHOLD) {
      // üèÜ PROMOVER: Win rate >= 65% com trades suficientes
      newStatus = 'promoted';
      newConfidenceLevel = 'high';
      newAdaptiveWeight = 1.5; // Boost de 50% para padr√µes promovidos
      console.log(`üèÜ [PATTERN LEARNING] Padr√£o PROMOVIDO! Win rate: ${(winRate * 100).toFixed(1)}%`);
    } else if (winRate < DEMOTION_THRESHOLD) {
      // ‚ùå DESABILITAR: Win rate < 40% = padr√£o ruim
      newStatus = 'disabled';
      newConfidenceLevel = 'very_low';
      newAdaptiveWeight = 0.3; // Penalidade forte
      console.log(`‚ùå [PATTERN LEARNING] Padr√£o DESABILITADO! Win rate: ${(winRate * 100).toFixed(1)}%`);
    } else {
      // ‚è≥ Ainda coletando (40-65%)
      newStatus = 'collecting';
      newConfidenceLevel = 'medium';
      newAdaptiveWeight = 1.0;
    }

    await supabase.from('ai_pattern_memory').update({
      confidence_level: newConfidenceLevel,
      adaptive_weight: newAdaptiveWeight,
      win_rate: winRate,  // ‚úÖ FIX: Atualizar win_rate na ai_pattern_memory
      updated_at: new Date().toISOString()
    }).eq('id', patternMemoryId);

  } catch (error) {
    console.warn('‚ö†Ô∏è [PATTERN LEARNING] Erro ao atualizar status:', error?.message);
  }
}

// ============================================================================
// üö´ GUARD RAILS CR√çTICOS - Identificados no Documento Mestre 17/12/2025
// ============================================================================

/**
 * ‚úÖ GUARD RAIL #1: Hard-block de padr√µes problem√°ticos
 * BOS Bullish: -$5,966 em 7 dias - requer score >= 65
 * Order Block Bullish: -$2,023 em 7 dias - requer score >= 60
 */
function shouldBlockPattern(patternName: string, confidenceScore: number): { blocked: boolean; reason: string } {
  // BOS Bullish: padr√£o mais problem√°tico identificado
  if (patternName?.toLowerCase().includes('bos') && patternName?.toLowerCase().includes('bullish')) {
    if (confidenceScore < 65) {
      return { blocked: true, reason: `BOS Bullish bloqueado - score ${confidenceScore} < 65 m√≠nimo` };
    }
  }
  // Order Block Bullish: segundo pior padr√£o (-$2,023)
  if (patternName?.toLowerCase().includes('order block') && patternName?.toLowerCase().includes('bullish')) {
    if (confidenceScore < 60) {
      return { blocked: true, reason: `Order Block Bullish bloqueado - score ${confidenceScore} < 60 m√≠nimo` };
    }
  }
  return { blocked: false, reason: '' };
}

/**
 * ‚úÖ GUARD RAIL #2 e #3: Penaliza√ß√£o de contexto (RANGING e hor√°rios t√≥xicos)
 * RANGING: -$2,563 em 7 dias
 * Hor√°rios t√≥xicos (17h, 00h, 22h UTC): -$2,694 combinado
 */
function calculateContextPenalties(marketRegime: string | null): { penalty: number; reasons: string[] } {
  let penalty = 0;
  const reasons: string[] = [];

  // RANGING: mercado lateral √© t√≥xico para o sistema
  if (marketRegime === 'RANGING') {
    penalty += 20;
    reasons.push('Regime RANGING (-20 pts)');
  }

  // Hor√°rios t√≥xicos baseados na an√°lise estat√≠stica
  const hourUTC = new Date().getUTCHours();
  const toxicHours = [0, 17, 22]; // 00h (-$1,387), 17h (-$1,307), 22h (-$841)
  if (toxicHours.includes(hourUTC)) {
    penalty += 15;
    reasons.push(`Hor√°rio t√≥xico ${hourUTC}h UTC (-15 pts)`);
  }

  return { penalty, reasons };
}

// ============================================================================
// üîó COPY TRADE - ENVIO AUTOM√ÅTICO DE WEBHOOK
// ============================================================================
// Envia sinais para webhooks configurados pelos usu√°rios (3Commas, Cornix, etc)
// Modelo n√£o-custodial: n√£o temos acesso aos fundos, apenas enviamos o sinal
// ============================================================================

/**
 * ‚úÖ Busca todos os webhooks configurados e envia o sinal
 */
async function sendCopyTradeWebhook(supabase: any, tradeData: {
  symbol: string;
  direction: 'BUY' | 'SELL';
  entry_price: number;
  stop_price: number;
  target_price: number;
  confidence: number;
  pattern: string;
}) {
  try {
    // Buscar todos os webhooks configurados (tabela pode n√£o existir)
    let webhookConfigs: any[] = [];

    try {
      const { data } = await supabase
        .from('user_copytrade_config')
        .select('user_id, webhook_url, api_key, symbols, accepted_terms, telegram_bot_token, telegram_chat_id')
        .eq('accepted_terms', true);

      if (data) {
        webhookConfigs = data;
      }
    } catch (err) {
      // Tabela n√£o existe ainda - usar localStorage fallback do frontend
      console.log('üì° [COPY TRADE] Tabela user_copytrade_config n√£o existe ainda');
      return;
    }

    if (webhookConfigs.length === 0) {
      return; // Nenhum webhook configurado
    }

    // Formatar s√≠mbolo para checagem
    const symbolNormalized = tradeData.symbol.replace('/', '');

    for (const config of webhookConfigs) {
      try {
        // Verificar se o s√≠mbolo est√° ativo para este usu√°rio
        const symbols = config.symbols || {};
        const symbolKey = tradeData.symbol; // BTC/USDT

        if (!symbols[symbolKey]) {
          continue; // S√≠mbolo n√£o est√° ativo para este usu√°rio
        }

        // Montar payload do webhook
        // Detectar se √© 3Commas (pela URL)
        const is3Commas = config.webhook_url.includes('3commas.io');

        let webhookPayload;

        if (is3Commas) {
          // Formato espec√≠fico para 3Commas Signal Bot
          // Payload simplificado que funciona na maioria dos bots
          webhookPayload = {
            message_type: 'bot',
            bot_uuid: 'USER_BOT_UUID', // O usu√°rio deve copiar do 3Commas, mas enviamos gen√©rico se n√£o tiver
            pair: `USDT_${symbolNormalized.replace('USDT', '')}`, // Ex: USDT_BTC
            action: 'custom_signal', // Ou buy/sell

            // Campos para custom payload (TV style)
            secret: config.api_key,
            trigger_price: tradeData.entry_price,
            tv_exchange: "Binance",
            tv_instrument: symbolNormalized,
            signal_token: config.api_key, // Alguns bots usam isso

            // Dados reais do sinal
            symbol: symbolNormalized,
            side: tradeData.direction === 'BUY' ? 'buy' : 'sell',
            entry: tradeData.entry_price,
            stop: tradeData.stop_price,
            target: tradeData.target_price
          };
        } else {
          // Payload Gen√©rico (Cornix, Custom, etc)
          webhookPayload = {
            symbol: symbolNormalized,
            side: tradeData.direction,
            entry: tradeData.entry_price,
            stop: tradeData.stop_price,
            target: tradeData.target_price,
            confidence: tradeData.confidence,
            pattern: tradeData.pattern,
            api_key: config.api_key,
            source: 'TradeVision IA',
            timestamp: new Date().toISOString()
          };
        }

        // Enviar webhook HTTP (3Commas, Custom, etc)
        if (config.webhook_url && config.webhook_url.startsWith('http')) {
          const response = await fetch(config.webhook_url, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(webhookPayload),
          });

          if (response.ok) {
            console.log(`‚úÖ [COPY TRADE] Webhook enviado para user ${config.user_id.substring(0, 8)}: ${tradeData.symbol} ${tradeData.direction}`);
          } else {
            console.warn(`‚ö†Ô∏è [COPY TRADE] Webhook falhou para user ${config.user_id.substring(0, 8)}: ${response.status}`);
          }
        }

        // üéØ Enviar para Telegram/Cornix (se configurado)
        if (config.telegram_bot_token && config.telegram_chat_id) {
          try {
            // Formatar s√≠mbolo: BTCUSDT ‚Üí BTC/USDT
            const symbolFormatted = symbolNormalized.replace('USDT', '/USDT').replace('BUSD', '/BUSD');

            // Formatar pre√ßos
            const formatPrice = (p: number) => p >= 100 ? p.toFixed(2) : p.toFixed(4);

            // ‚úÖ v293: Formato Cornix com M√öLTIPLOS TPs para Trailing Pro
            // Ref: https://help.cornix.io/hc/en-us/articles/360018706360-Signal-Format
            // TP1: 40% do target (garantir algum lucro)
            // TP2: 80% do target (lucro principal)
            // TP3: 120% do target (para movimentos estendidos)
            const entryP = tradeData.entry_price;
            const targetP = tradeData.target_price;
            const targetDistance = Math.abs(targetP - entryP);

            const tp1 = tradeData.direction === 'BUY'
              ? entryP + (targetDistance * 0.40)
              : entryP - (targetDistance * 0.40);
            const tp2 = tradeData.direction === 'BUY'
              ? entryP + (targetDistance * 0.80)
              : entryP - (targetDistance * 0.80);
            const tp3 = tradeData.direction === 'BUY'
              ? entryP + (targetDistance * 1.20)
              : entryP - (targetDistance * 1.20);

            let cornixMessage = `${tradeData.direction === 'BUY' ? 'LONG' : 'SHORT'} ${symbolFormatted}\n`;
            cornixMessage += `Exchange: ByBit Futures\n`;
            cornixMessage += `Leverage: Cross 75x\n`;
            cornixMessage += `Margin Mode: Cross\n`;
            cornixMessage += `Order Type: Market\n`;
            cornixMessage += `Entry Targets:\n`;
            cornixMessage += `1) ${formatPrice(tradeData.entry_price)}\n`;
            cornixMessage += `Take-Profit Targets:\n`;
            cornixMessage += `1) ${formatPrice(tp1)} - 30%\n`;  // TP1: 40% target, close 30% position
            cornixMessage += `2) ${formatPrice(tp2)} - 40%\n`;  // TP2: 80% target, close 40% position
            cornixMessage += `3) ${formatPrice(tp3)} - 30%\n`;  // TP3: 120% target, close rest
            cornixMessage += `Stop:\n`;
            cornixMessage += `1) ${formatPrice(tradeData.stop_price)}\n`;
            cornixMessage += `Trailing:\n`;
            cornixMessage += `Configuration: Without Trailing`; // Trailing handled internally

            if (tradeData.pattern) {
              cornixMessage += `\n\nüìä Pattern: ${tradeData.pattern}`;
              cornixMessage += `\nüéØ Confidence: ${tradeData.confidence}%`;
              cornixMessage += `\nü§ñ Source: TradeVision IA`;
            }

            // Enviar para Telegram
            const telegramUrl = `https://api.telegram.org/bot${config.telegram_bot_token}/sendMessage`;
            const telegramResponse = await fetch(telegramUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                chat_id: config.telegram_chat_id,
                text: cornixMessage
              })
            });

            if (telegramResponse.ok) {
              console.log(`‚úÖ [TELEGRAM] Sinal Cornix enviado: ${tradeData.symbol} ${tradeData.direction}`);
            } else {
              const error = await telegramResponse.json();
              console.warn(`‚ö†Ô∏è [TELEGRAM] Falha ao enviar:`, error?.description);
            }
          } catch (telegramError) {
            console.warn(`‚ö†Ô∏è [TELEGRAM] Erro:`, telegramError?.message);
          }
        }

        // ‚ö° NOVO: Execu√ß√£o Direta via API Keys (exchange-executor)
        // Buscar se usu√°rio tem API Keys configuradas
        try {
          const { data: apiKeyData } = await supabase
            .from('user_api_keys')
            .select('exchange, is_active, is_testnet, trade_amount_usd')
            .eq('user_id', config.user_id)
            .eq('is_active', true)
            .single();

          if (apiKeyData) {
            // üí∞ Calcular quantity baseado no trade_amount_usd e pre√ßo atual
            // ‚úÖ CORRE√á√ÉO: Usar m√≠nimos por s√≠mbolo
            const tradeAmountUsd = apiKeyData.trade_amount_usd || 50;
            const currentPrice = tradeData.entry_price || 1;

            // ‚úÖ M√≠nimos da Bybit por s√≠mbolo
            const symbolMins: Record<string, number> = {
              'BTCUSDT': 0.001, 'ETHUSDT': 0.01, 'BNBUSDT': 0.1,
              'SOLUSDT': 0.1, 'XRPUSDT': 1, 'DOGEUSDT': 10,
            };
            const symbolClean = tradeData.symbol.replace('/', '');
            const minQty = symbolMins[symbolClean] || 0.001;

            let quantity = tradeAmountUsd / currentPrice;
            if (quantity < minQty) {
              quantity = minQty;
            }

            // Arredondar para precis√£o apropriada
            const roundedQuantity = quantity >= 1
              ? parseFloat(quantity.toFixed(3))
              : parseFloat(quantity.toFixed(6));

            // Usu√°rio tem API Keys configuradas - executar diretamente
            const orderPayload = {
              action: 'execute_trade',
              userId: config.user_id,
              exchange: apiKeyData.exchange,
              order: {
                symbol: tradeData.symbol,
                side: tradeData.direction,
                quantity: roundedQuantity, // üí∞ Calculado baseado no valor USD configurado
                stopLoss: tradeData.stop_price,
                takeProfit: tradeData.target_price,
              }
            };

            // Chamar exchange-executor
            const executorUrl = `${Deno.env.get('SUPABASE_URL')}/functions/v1/exchange-executor`;
            const executorResponse = await fetch(executorUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')}`,
              },
              body: JSON.stringify(orderPayload),
            });

            const executorResult = await executorResponse.json();

            if (executorResult.success) {
              console.log(`‚ö° [DIRECT EXEC] Trade executado em ${apiKeyData.exchange}: ${tradeData.symbol} ${tradeData.direction} - Order ID: ${executorResult.orderId}`);
            } else {
              console.warn(`‚ö†Ô∏è [DIRECT EXEC] Falha na execu√ß√£o ${apiKeyData.exchange}:`, executorResult.error);
            }
          }
        } catch (directExecError) {
          // Silencioso se tabela n√£o existe ou usu√°rio n√£o tem API keys
          if (!directExecError?.message?.includes('No rows')) {
            console.warn(`‚ö†Ô∏è [DIRECT EXEC] Erro:`, directExecError?.message);
          }
        }

      } catch (webhookError) {
        console.warn(`‚ö†Ô∏è [COPY TRADE] Erro ao enviar webhook:`, webhookError?.message);
      }
    }

    // ‚ö° CORRE√á√ÉO: Execu√ß√£o Direta para TODOS os usu√°rios com API Keys ativas
    // Buscar independente do user_copytrade_config (IA cria trades como 'system-ai')
    try {
      const { data: allApiKeys } = await supabase
        .from('user_api_keys')
        .select('user_id, exchange, is_active, is_testnet, trade_amount_usd')
        .eq('is_active', true);

      if (allApiKeys && allApiKeys.length > 0) {
        console.log(`‚ö° [DIRECT EXEC] Encontrados ${allApiKeys.length} usu√°rios com API Keys ativas`);

        for (const apiKey of allApiKeys) {
          try {
            // ‚úÖ 19/dez: Verificar se j√° existe posi√ß√£o aberta para este s√≠mbolo
            // Evita m√∫ltiplas entradas acumulativas no mesmo s√≠mbolo
            const symbolClean = tradeData.symbol.replace('/', '');
            const executorUrl = `${Deno.env.get('SUPABASE_URL')}/functions/v1/exchange-executor`;

            try {
              const posCheckResponse = await fetch(executorUrl, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')}`,
                },
                body: JSON.stringify({
                  action: 'get_positions',
                  userId: apiKey.user_id,
                  exchange: apiKey.exchange,
                  symbol: tradeData.symbol
                }),
              });

              const posCheckResult = await posCheckResponse.json();

              if (posCheckResult.success && posCheckResult.positions?.length > 0) {
                const existingPosition = posCheckResult.positions.find((p: any) =>
                  p.symbol === symbolClean && parseFloat(p.size) > 0
                );

                if (existingPosition) {
                  console.log(`‚ö†Ô∏è [DIRECT EXEC] J√° existe posi√ß√£o aberta para ${symbolClean} (size: ${existingPosition.size}), ignorando nova entrada`);
                  continue; // Pula para o pr√≥ximo usu√°rio
                }
              }
            } catch (posCheckError: any) {
              console.log(`‚ö†Ô∏è [DIRECT EXEC] Erro ao verificar posi√ß√£o (continuando):`, posCheckError?.message);
              // Continua mesmo se a verifica√ß√£o falhar
            }

            // Calcular quantity baseado no trade_amount_usd e pre√ßo atual
            // ‚úÖ CORRE√á√ÉO: Usar m√≠nimos por s√≠mbolo para evitar erro de quantidade
            const tradeAmountUsd = apiKey.trade_amount_usd || 50;
            const currentPrice = tradeData.entry_price || 1;

            console.log(`üí∞ [DIRECT EXEC] Usando trade_amount_usd: $${tradeAmountUsd} para user ${apiKey.user_id.substring(0, 8)}`);

            // ‚úÖ M√≠nimos da Bybit por s√≠mbolo (Linear USDT Perpetual)
            const symbolMins: Record<string, number> = {
              'BTCUSDT': 0.001,
              'ETHUSDT': 0.01,
              'BNBUSDT': 0.1,
              'SOLUSDT': 0.1,
              'XRPUSDT': 1,
              'DOGEUSDT': 10,
            };

            const minQty = symbolMins[symbolClean] || 0.001;

            // Calcular quantidade: margem / pre√ßo
            let quantity = tradeAmountUsd / currentPrice;

            // ‚úÖ Garantir m√≠nimo do s√≠mbolo
            if (quantity < minQty) {
              quantity = minQty;
              console.log(`‚ö†Ô∏è [DIRECT EXEC] Qty ajustado para m√≠nimo ${minQty} para ${symbolClean}`);
            }

            // Arredondar para precis√£o apropriada
            const roundedQuantity = quantity >= 1
              ? parseFloat(quantity.toFixed(3))
              : parseFloat(quantity.toFixed(6));

            // Executar diretamente
            const orderPayload = {
              action: 'execute_trade',
              userId: apiKey.user_id,
              exchange: apiKey.exchange,
              order: {
                symbol: tradeData.symbol,
                side: tradeData.direction,
                quantity: roundedQuantity,
                stopLoss: tradeData.stop_price,
                takeProfit: tradeData.target_price,
              }
            };

            // Chamar exchange-executor (usando executorUrl j√° declarado)
            const executorResponse = await fetch(executorUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')}`,
              },
              body: JSON.stringify(orderPayload),
            });

            const executorResult = await executorResponse.json();

            if (executorResult.success) {
              console.log(`‚ö° [DIRECT EXEC] ‚úÖ Trade executado em ${apiKey.exchange} para user ${apiKey.user_id.substring(0, 8)}: ${tradeData.symbol} ${tradeData.direction} qty=${roundedQuantity} - Order ID: ${executorResult.orderId}`);

              // ‚ö° 19/dez: Definir TP/SL explicitamente ap√≥s abertura (Bybit ignora inline em Market orders)
              try {
                const tpslPayload = {
                  action: 'set_tpsl',
                  userId: apiKey.user_id,
                  exchange: apiKey.exchange,
                  symbol: tradeData.symbol,
                  stopLoss: tradeData.stop_price,
                  takeProfit: tradeData.target_price
                };
                await fetch(executorUrl, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')}`,
                  },
                  body: JSON.stringify(tpslPayload),
                });
                console.log(`‚ö° [DIRECT EXEC] TP/SL definido para ${tradeData.symbol}`);
              } catch (tpslError: any) {
                console.warn(`‚ö†Ô∏è [DIRECT EXEC] Erro set_tpsl:`, tpslError?.message);
              }
            } else {
              console.warn(`‚ö†Ô∏è [DIRECT EXEC] Falha ${apiKey.exchange} user ${apiKey.user_id.substring(0, 8)}:`, executorResult.error);
            }
          } catch (execError) {
            console.warn(`‚ö†Ô∏è [DIRECT EXEC] Erro para user ${apiKey.user_id.substring(0, 8)}:`, execError?.message);
          }
        }
      }
    } catch (globalExecError) {
      console.warn(`‚ö†Ô∏è [DIRECT EXEC] Erro ao buscar API keys globais:`, globalExecError?.message);
    }

  } catch (error) {
    console.warn('‚ö†Ô∏è [COPY TRADE] Erro geral no envio de webhooks:', error?.message);
  }
}

/**
 * ‚úÖ NOVO: Enviar sinal de fechamento para Telegram/Cornix
 * Formato: Close Signal para que Cornix feche o trade automaticamente
 */
async function sendCopyTradeCloseSignal(supabase: any, trade: {
  symbol: string;
  direction: 'BUY' | 'SELL';
  entry_price: number;
  exit_price: number;
  pnl: number;
  reason: string;
}) {
  try {
    // Buscar configura√ß√µes de Telegram
    let webhookConfigs: any[] = [];

    try {
      const { data } = await supabase
        .from('user_copytrade_config')
        .select('user_id, telegram_bot_token, telegram_chat_id, symbols, accepted_terms')
        .eq('accepted_terms', true);

      if (data) {
        webhookConfigs = data;
      }
    } catch (err) {
      return; // Tabela n√£o existe
    }

    if (webhookConfigs.length === 0) {
      return;
    }

    const symbolNormalized = trade.symbol.replace('/', '');

    for (const config of webhookConfigs) {
      try {
        // Verificar se s√≠mbolo est√° ativo
        const symbols = config.symbols || {};
        const symbolKey = trade.symbol;

        if (!symbols[symbolKey]) {
          continue;
        }

        // Enviar para Telegram/Cornix (se configurado)
        if (config.telegram_bot_token && config.telegram_chat_id) {
          try {
            // Formatar s√≠mbolo SEM barra para Cornix (BTCUSDT, n√£o BTC/USDT)
            const symbolCornix = symbolNormalized; // Ex: BTCUSDT

            // Formatar pre√ßos
            const formatPrice = (p: number) => p >= 100 ? p.toFixed(2) : p.toFixed(4);

            // Resultado
            const result = trade.pnl > 0 ? '‚úÖ WIN' : trade.pnl < 0 ? '‚ùå LOSS' : '‚è∏Ô∏è BREAKEVEN';
            const pnlFormatted = trade.pnl >= 0 ? `+$${trade.pnl.toFixed(2)}` : `-$${Math.abs(trade.pnl).toFixed(2)}`;

            // ‚úÖ CORRE√á√ÉO: Mensagem de fechamento no formato que Cornix reconhece
            // Cornix aceita: CLOSE, CANCEL ou EXIT seguido do s√≠mbolo
            let closeMessage = `CLOSE ${symbolCornix}\n\n`;
            closeMessage += `üìä Trade Encerrado\n`;
            closeMessage += `Exit: ${formatPrice(trade.exit_price)}\n`;
            closeMessage += `Entry: ${formatPrice(trade.entry_price)}\n`;
            closeMessage += `P&L: ${pnlFormatted} ${result}\n`;
            closeMessage += `Reason: ${trade.reason}`;

            // Enviar para Telegram
            const telegramUrl = `https://api.telegram.org/bot${config.telegram_bot_token}/sendMessage`;
            const telegramResponse = await fetch(telegramUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                chat_id: config.telegram_chat_id,
                text: closeMessage
              })
            });

            if (telegramResponse.ok) {
              console.log(`‚úÖ [TELEGRAM] Sinal de CLOSE enviado: ${trade.symbol} - ${trade.reason}`);
            } else {
              const error = await telegramResponse.json();
              console.warn(`‚ö†Ô∏è [TELEGRAM] Falha ao enviar close:`, error?.description);
            }
          } catch (telegramError) {
            console.warn(`‚ö†Ô∏è [TELEGRAM] Erro ao enviar close:`, telegramError?.message);
          }
        }
      } catch (configError) {
        console.warn(`‚ö†Ô∏è [COPY TRADE] Erro ao processar config:`, configError?.message);
      }
    }
  } catch (error) {
    console.warn('‚ö†Ô∏è [COPY TRADE] Erro ao enviar sinal de close:', error?.message);
  }
}

/**
 * ‚ö° 19/dez: Fechar posi√ß√£o na Bybit para TODOS os usu√°rios com API Keys
 * Sincroniza fechamento TradeVision ‚Üí Bybit
 */
async function closePositionForAllApiKeys(supabase: any, trade: { symbol: string; side: 'BUY' | 'SELL' }) {
  try {
    const { data: allApiKeys } = await supabase
      .from('user_api_keys')
      .select('user_id, exchange, is_active')
      .eq('is_active', true)
      .eq('exchange', 'bybit');

    if (!allApiKeys || allApiKeys.length === 0) {
      console.log('‚ö° [BYBIT SYNC] Nenhum usu√°rio com API Keys Bybit ativas');
      return;
    }

    console.log(`‚ö° [BYBIT SYNC] Fechando posi√ß√£o ${trade.symbol} para ${allApiKeys.length} usu√°rios`);

    for (const apiKey of allApiKeys) {
      try {
        const closePayload = {
          action: 'close_position',
          userId: apiKey.user_id,
          exchange: 'bybit',
          symbol: trade.symbol,
          side: trade.side
        };

        const executorUrl = `${Deno.env.get('SUPABASE_URL')}/functions/v1/exchange-executor`;
        const response = await fetch(executorUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')}`,
          },
          body: JSON.stringify(closePayload),
        });

        const result = await response.json();

        if (result.success) {
          console.log(`‚ö° [BYBIT SYNC] ‚úÖ Posi√ß√£o fechada para user ${apiKey.user_id.substring(0, 8)}: ${trade.symbol}`);
        } else if (result.error) {
          console.warn(`‚ö†Ô∏è [BYBIT SYNC] Falha ao fechar ${trade.symbol} para ${apiKey.user_id.substring(0, 8)}:`, result.error);
        }
      } catch (userError: any) {
        console.warn(`‚ö†Ô∏è [BYBIT SYNC] Erro para user ${apiKey.user_id.substring(0, 8)}:`, userError?.message);
      }
    }
  } catch (error: any) {
    console.warn('‚ö†Ô∏è [BYBIT SYNC] Erro ao sincronizar fechamento:', error?.message);
  }
}

/**
 * ‚ö° 19/dez: Atualizar TP/SL na Bybit para TODOS os usu√°rios com API Keys
 * Sincroniza trailing stop TradeVision ‚Üí Bybit
 */
async function updateTpSlForAllApiKeys(supabase: any, trade: { symbol: string; stopLoss?: number; takeProfit?: number }) {
  try {
    const { data: allApiKeys } = await supabase
      .from('user_api_keys')
      .select('user_id, exchange, is_active')
      .eq('is_active', true)
      .eq('exchange', 'bybit');

    if (!allApiKeys || allApiKeys.length === 0) return;

    console.log(`‚ö° [BYBIT SYNC] Atualizando TP/SL ${trade.symbol} para ${allApiKeys.length} usu√°rios`);

    for (const apiKey of allApiKeys) {
      try {
        const tpslPayload = {
          action: 'set_tpsl',
          userId: apiKey.user_id,
          exchange: 'bybit',
          symbol: trade.symbol,
          stopLoss: trade.stopLoss,
          takeProfit: trade.takeProfit
        };

        const executorUrl = `${Deno.env.get('SUPABASE_URL')}/functions/v1/exchange-executor`;
        const response = await fetch(executorUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')}`,
          },
          body: JSON.stringify(tpslPayload),
        });

        const result = await response.json();

        if (result.success) {
          console.log(`‚ö° [BYBIT SYNC] ‚úÖ TP/SL atualizado para user ${apiKey.user_id.substring(0, 8)}: ${trade.symbol} SL=${trade.stopLoss}`);
        }
      } catch (userError: any) {
        console.warn(`‚ö†Ô∏è [BYBIT SYNC] Erro set_tpsl para user ${apiKey.user_id.substring(0, 8)}:`, userError?.message);
      }
    }
  } catch (error: any) {
    console.warn('‚ö†Ô∏è [BYBIT SYNC] Erro ao sincronizar TP/SL:', error?.message);
  }
}

/**
 * ‚úÖ CORRE√á√ÉO: Criar um novo trade_state com equity salvo na entrada
 */
// ‚úÖ CONFIGURA√á√ÉO POR S√çMBOLO: Limites DIN√ÇMICOS baseados em ATR
// ‚úÖ NOVO: Stop/Target agora s√£o calculados dinamicamente com ATR, mas respeitando min/max
const SYMBOL_CONFIG = {
  'BTCUSDT': {
    maxEntry: 500,           // Entrada m√°xima $500
    // ‚úÖ OTIMIZADO: Stop 0.20-0.37% (perda m√°x ~27.75% com 75x), Target 0.70-1.20% (R:R 2:1 a 3:1)
    minStopPct: 0.20,        // Stop m√≠nimo 0.20% (perda ~15% com 75x)
    maxStopPct: 0.37,        // Stop m√°ximo 0.37% (perda ~27.75% com 75x)
    minTargetPct: 0.70,      // Target m√≠nimo 0.70% (R:R m√≠nimo ~2:1)
    maxTargetPct: 1.20,      // Target m√°ximo 1.20% (R:R ideal ~3:1)
    atrMultiplierStop: 1.2,  // Stop = ATR √ó 1.2 (mais curto)
    atrMultiplierTarget: 2.8,// Target = ATR √ó 2.8 (R:R ‚âà 2.3:1)
    leverage: 75,
    positionSizePct: 0.05    // 5% do equity = $500 em 10k
  },
  'ETHUSDT': {
    maxEntry: 250,
    minStopPct: 0.20,
    maxStopPct: 0.37,
    minTargetPct: 0.70,
    maxTargetPct: 1.20,
    atrMultiplierStop: 1.2,
    atrMultiplierTarget: 2.8,
    leverage: 75,
    positionSizePct: 0.025
  },
  'BNBUSDT': {
    maxEntry: 200,
    minStopPct: 0.20,
    maxStopPct: 0.37,
    minTargetPct: 0.70,
    maxTargetPct: 1.20,
    atrMultiplierStop: 1.2,
    atrMultiplierTarget: 2.8,
    leverage: 75,
    positionSizePct: 0.02
  },
  'SOLUSDT': {
    maxEntry: 200,
    minStopPct: 0.20,
    maxStopPct: 0.37,
    minTargetPct: 0.70,
    maxTargetPct: 1.20,
    atrMultiplierStop: 1.2,
    atrMultiplierTarget: 2.8,
    leverage: 75,
    positionSizePct: 0.02
  },
  'DEFAULT': {
    maxEntry: 200,
    minStopPct: 0.20,
    maxStopPct: 0.37,
    minTargetPct: 0.70,
    maxTargetPct: 1.20,
    atrMultiplierStop: 1.2,
    atrMultiplierTarget: 2.8,
    leverage: 75,
    positionSizePct: 0.02
  }
};

// ‚úÖ TIMEOUT: Trade fecha automaticamente ap√≥s 13 minutos
const TRADE_TIMEOUT_MINUTES = 18; // ‚úÖ v286: Aumentado de 13 para 18 min

/**
 * ‚úÖ NOVO: Calcula Stop/Target din√¢micos baseados em ATR real
 * Retorna valores em PERCENTUAL do pre√ßo
 */
function calculateDynamicStopTarget(symbol: string, atrPercent: number): { stopPct: number; targetPct: number } {
  const config = getSymbolConfig(symbol);

  // Calcular stop baseado em ATR √ó multiplicador
  let stopPct = atrPercent * config.atrMultiplierStop;
  let targetPct = atrPercent * config.atrMultiplierTarget;

  // ‚úÖ Aplicar limites (clamp) para n√£o ultrapassar bounds
  stopPct = Math.max(config.minStopPct, Math.min(config.maxStopPct, stopPct));
  targetPct = Math.max(config.minTargetPct, Math.min(config.maxTargetPct, targetPct));

  console.log(`üìè [DYNAMIC STOP] ${symbol} ATR=${(atrPercent * 100).toFixed(3)}% ‚Üí Stop=${(stopPct * 100).toFixed(2)}% Target=${(targetPct * 100).toFixed(2)}%`);

  return { stopPct, targetPct };
}

function getSymbolConfig(symbol) {
  const symbolUpper = String(symbol || '').toUpperCase().replace('/', '');
  return SYMBOL_CONFIG[symbolUpper] || SYMBOL_CONFIG['DEFAULT'];
}

/**
 * ‚úÖ ARQUITETURA GEN√âRICA: Detecta dire√ß√£o do padr√£o para QUALQUER padr√£o
 * Funciona para todos os padr√µes: Order Block, Engulfing, Hammer, BOS, ChoCh, etc.
 * 
 * @param {string|object} pattern - Nome do padr√£o ou objeto com type/name
 * @returns {object} - { isBullish: boolean, isBearish: boolean, direction: 'BUY'|'SELL'|'NEUTRAL' }
 */
function detectPatternDirection(pattern) {
  // Normalizar entrada: aceita string ou objeto
  const patternName = typeof pattern === 'string'
    ? pattern
    : (pattern?.type || pattern?.name || '');

  if (!patternName) {
    return { isBullish: false, isBearish: false, direction: 'NEUTRAL' };
  }

  // Normalizar: lowercase, remover pontua√ß√£o e espa√ßos extras
  const normalized = patternName.toLowerCase()
    .replace(/[_-]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  // ‚úÖ LISTA COMPLETA DE PADR√ïES BULLISH (arquitetura gen√©rica)
  const bullishKeywords = [
    'bullish', 'buy', 'compra', 'alta', 'ascendente', 'ascending',
    'order block bullish', 'orderblock bullish', 'ob bullish',
    'bullish engulfing', 'engulfing bullish',
    'hammer', 'hammer bullish', 'martelo',
    'spring', 'wyckoff spring',
    'break of structure bullish', 'bos bullish', 'breakofstructure bullish',
    'change of character bullish', 'choch bullish', 'changeofcharacter bullish',
    'fair value gap bullish', 'fvg bullish', 'fairvaluegap bullish',
    'liquidity sweep bullish', 'liquiditysweep bullish',
    'support', 'suporte', 'fundamento',
    'accumulation', 'acumula√ß√£o',
    'reversal bullish', 'revers√£o bullish',
    'pinbar bullish', 'pin bar bullish',
    'inside bar bullish', 'insidebar bullish',
    'double bottom', 'duplo fundo', 'triple bottom', 'triplo fundo',
    'head and shoulders bottom', 'cabe√ßa e ombros fundo'
  ];

  // ‚úÖ LISTA COMPLETA DE PADR√ïES BEARISH (arquitetura gen√©rica)
  const bearishKeywords = [
    'bearish', 'sell', 'venda', 'baixa', 'descendente', 'descending',
    'order block bearish', 'orderblock bearish', 'ob bearish',
    'bearish engulfing', 'engulfing bearish',
    'shooting star', 'shootingstar', 'estrela cadente',
    'upthrust', 'wyckoff upthrust',
    'break of structure bearish', 'bos bearish', 'breakofstructure bearish',
    'change of character bearish', 'choch bearish', 'changeofcharacter bearish',
    'fair value gap bearish', 'fvg bearish', 'fairvaluegap bearish',
    'liquidity sweep bearish', 'liquiditysweep bearish',
    'resistance', 'resist√™ncia', 'topo',
    'distribution', 'distribui√ß√£o',
    'reversal bearish', 'revers√£o bearish',
    'pinbar bearish', 'pin bar bearish',
    'inside bar bearish', 'insidebar bearish',
    'double top', 'duplo topo', 'triple top', 'triplo topo',
    'head and shoulders top', 'cabe√ßa e ombros topo'
  ];

  // ‚úÖ CORRE√á√ÉO CR√çTICA #1: Priorizar "Bearish"/"Bullish" quando presente no nome
  // Se o nome do padr√£o cont√©m "bearish" ou "bullish", SEMPRE respeitar essa dire√ß√£o
  if (normalized.includes('bearish')) {
    // Se cont√©m "bearish", SEMPRE √© bearish (mesmo que tenha outras keywords bullish)
    return {
      isBullish: false,
      isBearish: true,
      direction: 'SELL',
      patternName: normalized
    };
  }
  if (normalized.includes('bullish')) {
    // Se cont√©m "bullish", SEMPRE √© bullish (mesmo que tenha outras keywords bearish)
    return {
      isBullish: true,
      isBearish: false,
      direction: 'BUY',
      patternName: normalized
    };
  }

  // ‚úÖ CORRE√á√ÉO CR√çTICA: Shooting Star √© SEMPRE bearish, mesmo se contiver "bullish" no nome
  // Isso previne contradi√ß√µes como "Shooting Star Bullish" que s√£o logicamente imposs√≠veis
  const isShootingStar = normalized.includes('shooting star') || normalized.includes('shootingstar') || normalized.includes('estrela cadente');
  if (isShootingStar) {
    // Shooting Star √© sempre bearish, ignorar qualquer "bullish" no nome
    return {
      isBullish: false,
      isBearish: true,
      direction: 'SELL',
      patternName: normalized.replace(/\s*bullish\s*/gi, '').trim() // Remover "bullish" se presente
    };
  }

  // Verificar se padr√£o cont√©m keywords bullish
  const isBullish = bullishKeywords.some(keyword => normalized.includes(keyword));

  // Verificar se padr√£o cont√©m keywords bearish
  const isBearish = bearishKeywords.some(keyword => normalized.includes(keyword));

  // Determinar dire√ß√£o
  let direction = 'NEUTRAL';
  if (isBullish && !isBearish) {
    direction = 'BUY';
  } else if (isBearish && !isBullish) {
    direction = 'SELL';
  } else if (isBullish && isBearish) {
    // Conflito: padr√£o tem ambos (raro, mas poss√≠vel)
    // Priorizar baseado na ordem: se "bullish" vem antes, √© bullish
    const bullishIndex = normalized.indexOf('bullish');
    const bearishIndex = normalized.indexOf('bearish');
    if (bullishIndex !== -1 && (bearishIndex === -1 || bullishIndex < bearishIndex)) {
      direction = 'BUY';
    } else {
      direction = 'SELL';
    }
  }

  return {
    isBullish,
    isBearish,
    direction,
    patternName: normalized
  };
}

/**
 * ‚úÖ NOVO: Detectar contexto de RANGE e dar boost quando pre√ßo toca extremos
 * @param {array} candles - Array de candles (√∫ltimos 20-50)
 * @param {number} currentPrice - Pre√ßo atual
 * @param {object} technicalIndicators - Indicadores t√©cnicos
 * @returns {object} - { isRange, atExtreme, boost, direction, details }
 */
function detectRangeContext(candles: any[], currentPrice: number, technicalIndicators: any = {}) {
  const RANGE_BOOST_BASE = 25; // ‚úÖ v288: Aumentado de 15 para 25 (mais trades em extremos)
  const RANGE_BOOST_VOLUME = 35; // ‚úÖ v288: Aumentado de 20 para 35 (extremo + volume)

  if (!candles || candles.length < 15 || !currentPrice || currentPrice <= 0) {
    return { isRange: false, atExtreme: false, boost: 0, direction: 'NEUTRAL', details: {} };
  }

  // 1. Usar √∫ltimos 20 candles para detectar range
  const recent = candles.slice(-20);
  const highs = recent.map(c => Number(c.high) || 0).filter(h => h > 0);
  const lows = recent.map(c => Number(c.low) || 0).filter(l => l > 0);
  const closes = recent.map(c => Number(c.close) || 0).filter(c => c > 0);

  if (highs.length < 10 || lows.length < 10) {
    return { isRange: false, atExtreme: false, boost: 0, direction: 'NEUTRAL', details: {} };
  }

  // 2. Calcular n√≠veis de suporte e resist√™ncia do range
  const rangeHigh = Math.max(...highs);
  const rangeLow = Math.min(...lows);
  const rangeSize = rangeHigh - rangeLow;
  const rangeMid = (rangeHigh + rangeLow) / 2;
  const rangeSizePct = (rangeSize / rangeMid) * 100;

  // 3. Verificar se √© um range v√°lido (ADAPTATIVO)
  // Range ideal: Acima do ru√≠do (2x ATR) e abaixo de limite macro (3.5%)
  const atr = technicalIndicators?.atr_14 || technicalIndicators?.atr || 0;
  const atrPercent = rangeMid > 0 ? (atr / rangeMid) * 100 : 0.2;

  // ‚úÖ ADAPTATIVO: Range deve ser maior que 2x a volatilidade m√©dia (ATR)
  const isValidRangeSize = rangeSizePct >= atrPercent * 2 && rangeSizePct <= 3.5;

  if (isValidRangeSize) {
    console.log(`üìä [ADAPTIVE RANGE DETECT] Size: ${rangeSizePct.toFixed(2)}% > Threshold: ${(atrPercent * 2).toFixed(2)}% (2x ATR)`);
  }

  // 4. Verificar horizontalidade - topos e fundos devem ser relativamente pr√≥ximos
  // Calcular quantos toques teve em cada extremo
  const nearHighThreshold = rangeHigh * 0.997; // -0.3% do topo
  const nearLowThreshold = rangeLow * 1.003;   // +0.3% do fundo

  const touchesHigh = highs.filter(h => h >= nearHighThreshold).length;
  const touchesLow = lows.filter(l => l <= nearLowThreshold).length;

  // Precisa de pelo menos 2 toques em cada extremo para confirmar range
  const hasMultipleTouches = touchesHigh >= 2 && touchesLow >= 2;

  // 5. Verificar ADX para confirmar lateralidade (se dispon√≠vel)
  const adx = technicalIndicators?.adx_14 || technicalIndicators?.adx || 30;
  const isLowTrend = adx < 25; // ADX < 25 indica mercado lateral

  // 6. Determinar se estamos em range
  const isRange = isValidRangeSize && hasMultipleTouches && isLowTrend;

  // 7. Verificar se pre√ßo est√° nos extremos do range
  const distanceToHigh = ((rangeHigh - currentPrice) / rangeHigh) * 100;
  const distanceToLow = ((currentPrice - rangeLow) / rangeLow) * 100;

  const atResistance = distanceToHigh <= 0.4; // Dentro de 0.4% do topo
  const atSupport = distanceToLow <= 0.4;     // Dentro de 0.4% do fundo
  const atExtreme = atResistance || atSupport;

  // 8. Determinar dire√ß√£o do sinal baseado na posi√ß√£o
  let direction = 'NEUTRAL';
  if (atResistance) {
    direction = 'SELL'; // No topo do range ‚Üí vender
  } else if (atSupport) {
    direction = 'BUY';  // No fundo do range ‚Üí comprar
  }

  // 9. Calcular boost baseado em conflu√™ncias
  let boost = 0;
  if (isRange && atExtreme) {
    // Verificar se tem volume spike no candle atual
    const currentCandle = candles[candles.length - 1];
    const avgVolume = recent.slice(0, -1).reduce((sum, c) => sum + (Number(c.volume) || 0), 0) / (recent.length - 1);
    const currentVolume = Number(currentCandle?.volume) || 0;
    const hasVolumeSpike = currentVolume > avgVolume * 1.3; // Volume 30% acima da m√©dia

    boost = hasVolumeSpike ? RANGE_BOOST_VOLUME : RANGE_BOOST_BASE;
  }

  return {
    isRange,
    atExtreme,
    boost,
    direction,
    details: {
      rangeHigh: rangeHigh.toFixed(2),
      rangeLow: rangeLow.toFixed(2),
      rangeSizePct: rangeSizePct.toFixed(2),
      distanceToHigh: distanceToHigh.toFixed(3),
      distanceToLow: distanceToLow.toFixed(3),
      touchesHigh,
      touchesLow,
      adx: adx.toFixed(1),
      atResistance,
      atSupport,
      isValidRangeSize,
      hasMultipleTouches,
      isLowTrend
    }
  };
}

/**
 * ‚úÖ NOVO: Classificar padr√£o como REVERSAL ou BREAKOUT/CONTINUATION
 * @param {string} patternName - Nome do padr√£o detectado
 * @returns {string} - 'REVERSAL' | 'BREAKOUT' | 'UNKNOWN'
 */
function classifyPatternType(patternName) {
  if (!patternName) return 'UNKNOWN';

  const normalized = String(patternName).toLowerCase()
    .replace(/[_-]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  // ‚úÖ PADR√ïES DE REVERS√ÉO
  const reversalKeywords = [
    'hammer', 'shooting star', 'doji', 'pinbar', 'pin bar',
    'reversal', 'revers√£o', 'duplo topo', 'duplo fundo', 'triple top', 'triple bottom',
    'triplo topo', 'triplo fundo', 'head and shoulders', 'inverse head and shoulders',
    'cabe√ßa e ombros', 'ombro cabe√ßa ombro', 'h&s',
    'elliott abc', 'elliott correction', 'abc correction', 'onda abc',
    'spring', 'wyckoff spring', 'upthrust',
    'liquidity sweep', 'liquiditysweep', 'change of character', 'choch',
    'order block', 'orderblock', 'ob bullish', 'ob bearish'
  ];

  // ‚úÖ PADR√ïES DE ROMPIMENTO/CONTINUA√á√ÉO
  const breakoutKeywords = [
    'break of structure', 'bos', 'breakofstructure',
    'bandeira', 'flag', 'tri√¢ngulo', 'triangle', 'cunha', 'wedge',
    'range', 'consolida√ß√£o', 'consolidation', 'fair value gap', 'fvg'
  ];

  const isReversal = reversalKeywords.some(keyword => normalized.includes(keyword));
  const isBreakout = breakoutKeywords.some(keyword => normalized.includes(keyword));

  if (isReversal) return 'REVERSAL';
  if (isBreakout) return 'BREAKOUT';
  return 'UNKNOWN';
}

/**
 * ‚úÖ PATTERN TRUST SYSTEM - DIN√ÇMICO COM CONTEXTO (v288)
 * Consulta ai_pattern_memory + valida contexto de mercado.
 * N√ÉO bloqueia se tiver confirma√ß√£o: liquidity sweep, range extreme, ou volume spike.
 * 
 * @param {any} supabase - Cliente Supabase
 * @param {string} patternName - Nome do padr√£o
 * @param {string} symbol - S√≠mbolo (ex: BTCUSDT)
 * @param {object} context - Contexto de mercado opcional
 * @returns {Promise<object>} - { adjustment, winRate, confidence, action, shouldBlock, requiresContext, source }
 */
async function getPatternTrustFromDB(
  supabase: any,
  patternName: string,
  symbol: string = 'ALL',
  context: {
    hasLiquiditySweep?: boolean;
    atRangeExtreme?: boolean;
    hasVolumeSpike?: boolean;
    isWyckoffPattern?: boolean;
  } = {}
) {
  const DEFAULT = { adjustment: 0, winRate: 0.5, confidence: 'unknown', action: 'NONE', shouldBlock: false, requiresContext: false, source: 'fallback' };

  if (!patternName || !supabase) return DEFAULT;

  try {
    const normalized = String(patternName).toLowerCase().trim();
    const symbolNorm = String(symbol || 'ALL').toUpperCase().replace('/', '');

    // Detectar se √© padr√£o de estrutura (BOS, ChoCh, Order Block)
    const isStructuralPattern =
      normalized.includes('break of structure') ||
      normalized.includes('bos') ||
      normalized.includes('change of character') ||
      normalized.includes('choch') ||
      normalized.includes('order block');

    // 1. BUSCAR DO BANCO (espec√≠fico por s√≠mbolo)
    const { data } = await supabase
      .from('ai_pattern_memory')
      .select('pattern_name, symbol, total_occurrences, wins, losses, win_rate, adaptive_weight')
      .ilike('pattern_name', `%${normalized.split(' ')[0]}%`)
      .eq('symbol', symbolNorm)
      .order('total_occurrences', { ascending: false })
      .limit(1)
      .maybeSingle();

    if (!data || (data.total_occurrences || 0) < 10) {
      console.log(`üìä [PATTERN TRUST] ${patternName} @ ${symbol} ‚Üí Sem dados (source: fallback)`);
      return { ...DEFAULT, source: 'fallback' };
    }

    // 2. CALCULAR WIN RATE REAL
    const wins = Number(data.wins) || 0;
    const losses = Number(data.losses) || 0;
    const completed = wins + losses;
    const realWinRate = completed > 0 ? wins / completed : 0.5;
    const weight = Number(data.adaptive_weight) || 1;

    // 3. AVALIAR CONTEXTO DE MERCADO
    const { hasLiquiditySweep, atRangeExtreme, hasVolumeSpike, isWyckoffPattern } = context;
    const hasGoodContext = hasLiquiditySweep || atRangeExtreme || hasVolumeSpike || isWyckoffPattern;
    const contextCount = [hasLiquiditySweep, atRangeExtreme, hasVolumeSpike, isWyckoffPattern].filter(Boolean).length;

    // 4. L√ìGICA DE BLOQUEIO INTELIGENTE
    // Padr√£o ruim SEM contexto = bloquear
    // Padr√£o ruim COM contexto = permitir com penalidade
    const isLowWinRate = realWinRate < 0.30;
    const requiresContext = isStructuralPattern && isLowWinRate && completed >= 30;

    // S√≥ bloqueia se: win rate muito baixo E sem contexto E muitos trades
    const shouldBlock = realWinRate < 0.20 && !hasGoodContext && completed >= 50 && weight <= 0.5;

    // 5. CALCULAR ADJUSTMENT DIN√ÇMICO
    let adjustment = 0;
    let confidence = 'unknown';
    let action = 'NONE';

    if (shouldBlock) {
      // BLOQUEIO TOTAL - sem contexto, win rate p√©ssimo
      adjustment = -100;
      confidence = 'blocked';
      action = 'BLOCK';
    } else if (requiresContext && !hasGoodContext) {
      // REQUER CONTEXTO - padr√£o estrutural com WR baixo
      adjustment = -30;
      confidence = 'requires_context';
      action = 'WAIT_CONTEXT';
    } else if (requiresContext && hasGoodContext) {
      // CONTEXTO VALIDADO - padr√£o estrutural COM confirma√ß√£o
      adjustment = contextCount >= 2 ? +10 : 0; // Boost se m√∫ltiplas confirma√ß√µes
      confidence = 'context_validated';
      action = 'PROCEED';
      console.log(`‚úÖ [CONTEXT] ${patternName} permitido por contexto:`, {
        liquiditySweep: hasLiquiditySweep,
        rangeExtreme: atRangeExtreme,
        volumeSpike: hasVolumeSpike,
        wyckoff: isWyckoffPattern
      });
    } else if (realWinRate >= 0.55) {
      adjustment = +20;
      confidence = 'high';
      action = 'BOOST';
    } else if (realWinRate >= 0.45) {
      adjustment = +10;
      confidence = 'medium';
      action = 'BOOST';
    } else if (realWinRate >= 0.35) {
      adjustment = -5;
      confidence = 'low';
      action = 'PENALIZE';
    } else if (realWinRate >= 0.25) {
      adjustment = -15;
      confidence = 'toxic';
      action = 'PENALIZE';
    } else {
      adjustment = hasGoodContext ? -10 : -25; // Menos penalidade se tem contexto
      confidence = 'toxic';
      action = hasGoodContext ? 'PROCEED_CAUTIOUS' : 'PENALIZE';
    }

    // Penalidade extra por peso baixo (mas menor se tem contexto)
    if (weight < 0.5 && !shouldBlock) {
      adjustment -= hasGoodContext ? 5 : 10;
    }

    const emoji = action === 'BOOST' ? 'üèÜ' : action === 'BLOCK' ? 'üö´' : action === 'PROCEED' ? '‚úÖ' : action === 'WAIT_CONTEXT' ? '‚è≥' : '‚ö†Ô∏è';
    console.log(`${emoji} [PATTERN TRUST] ${patternName} @ ${symbol} ‚Üí WR: ${(realWinRate * 100).toFixed(1)}%, adj: ${adjustment}, ctx: ${contextCount} (source: db)`);

    return {
      adjustment,
      winRate: realWinRate,
      confidence,
      action,
      shouldBlock,
      requiresContext,
      hasGoodContext,
      contextCount,
      source: 'db',
      trades: completed
    };
  } catch (error) {
    console.warn(`‚ö†Ô∏è [PATTERN TRUST] Erro DB:`, error);
    return { ...DEFAULT, source: 'fallback' };
  }
}


/**
 * ‚úÖ PATTERN TRUST SYNC (fallback quando n√£o tem supabase)
 */
function getPatternTrust(patternName) {
  if (!patternName) return { adjustment: 0, winRate: 0.5, confidence: 'unknown', action: 'NONE', shouldBlock: false, source: 'fallback' };

  const normalized = String(patternName).toLowerCase().trim();

  // PADR√ïES BLOQUEADOS (baseado em dados do banco 15/12/2025)
  const blocked = ['break of structure bullish (bos)', 'bos bullish', 'order block bullish', 'estrutura t√©cnica'];
  for (const b of blocked) {
    if (normalized.includes(b)) {
      console.log(`üö´ [PATTERN TRUST] ${patternName} ‚Üí BLOQUEADO (source: fallback)`);
      return { adjustment: -100, winRate: 0.1, confidence: 'blocked', action: 'BLOCK', shouldBlock: true, source: 'fallback' };
    }
  }

  // PADR√ïES CONFI√ÅVEIS (fallback)
  const trusted: Record<string, any> = {
    'change of character': { adjustment: +15, winRate: 0.55, confidence: 'high' },
    'range': { adjustment: +10, winRate: 0.50, confidence: 'medium' },
  };
  for (const [p, d] of Object.entries(trusted)) {
    if (normalized.includes(p)) {
      console.log(`üèÜ [PATTERN TRUST] ${patternName} ‚Üí BOOST +${d.adjustment} (source: fallback)`);
      return { ...d, action: 'BOOST', shouldBlock: false, source: 'fallback' };
    }
  }

  return { adjustment: 0, winRate: 0.5, confidence: 'neutral', action: 'NONE', shouldBlock: false, source: 'fallback' };
}


/**
 * ‚úÖ DETECT RUN EXHAUSTION (Fim de Run / Exaust√£o de Tend√™ncia)
 * Detecta quando um run forte (alta ou queda) est√° perdendo for√ßa.
 * Identifica o "√°pice" do gr√°fico onde a revers√£o √© prov√°vel.
 * 
 * @param {array} candles - Array de candles
 * @param {object} technicalIndicators - Indicadores t√©cnicos (RSI, MACD)
 * @returns {object} - { isExhausted, runDirection, reversalDirection, confidence, details }
 */
function detectRunExhaustion(candles, technicalIndicators) {
  // ‚úÖ v284: Aumentado de 8 para 20 velas para melhor detec√ß√£o de topos/fundos
  if (!candles || candles.length < 20) {
    return { isExhausted: false, runDirection: null, reversalDirection: null, confidence: 0, details: {} };
  }

  const recent = candles.slice(-20); // ‚úÖ An√°lise de 20 velas (20 min em M1)

  // 1. Detectar run recente (8+ velas na mesma dire√ß√£o para run forte)
  let bullishCandles = 0;
  let bearishCandles = 0;

  for (let i = 0; i < recent.length - 1; i++) {
    const candle = recent[i];
    const close = Number(candle.close) || 0;
    const open = Number(candle.open) || 0;
    if (close > open) bullishCandles++;
    else if (close < open) bearishCandles++;
  }

  // ‚úÖ v284: Aumentado de 4+ para 8+ velas para run mais significativo
  const hasUpRun = bullishCandles >= 8;
  const hasDownRun = bearishCandles >= 8;
  const hasRun = hasUpRun || hasDownRun;
  const runDirection = hasUpRun ? 'UP' : hasDownRun ? 'DOWN' : null;

  if (!hasRun) {
    return { isExhausted: false, runDirection: null, reversalDirection: null, confidence: 0, details: { reason: 'Sem run detectado' } };
  }

  // 2. Verificar sinais de exaust√£o no √∫ltimo candle
  const lastCandle = recent[recent.length - 1];
  const prevCandle = recent[recent.length - 2];

  const lastClose = Number(lastCandle.close) || 0;
  const lastOpen = Number(lastCandle.open) || 0;
  const lastHigh = Number(lastCandle.high) || 0;
  const lastLow = Number(lastCandle.low) || 0;
  const prevClose = Number(prevCandle.close) || 0;

  // Body e wicks
  const body = Math.abs(lastClose - lastOpen);
  const totalRange = lastHigh - lastLow;
  const upperWick = lastHigh - Math.max(lastClose, lastOpen);
  const lowerWick = Math.min(lastClose, lastOpen) - lastLow;

  // Padr√µes de exaust√£o
  const isDoji = totalRange > 0 && body / totalRange < 0.2; // Corpo < 20% do range
  const hasLongUpperWick = totalRange > 0 && upperWick / totalRange > 0.5; // Sombra superior > 50%
  const hasLongLowerWick = totalRange > 0 && lowerWick / totalRange > 0.5; // Sombra inferior > 50%

  // Shooting Star (topo) ou Hammer invertido
  const isShootingStar = hasUpRun && hasLongUpperWick && body / totalRange < 0.3;
  // Hammer (fundo) ou Hanging Man invertido
  const isHammer = hasDownRun && hasLongLowerWick && body / totalRange < 0.3;

  // 3. Verificar perda de momentum
  const rsi = technicalIndicators?.rsi_14 || 50;
  const macd = technicalIndicators?.macd || 0;
  const macdSignal = technicalIndicators?.macd_signal || 0;

  // RSI extremo (exaust√£o prov√°vel)
  const rsiExhausted = hasUpRun ? rsi > 70 : hasDownRun ? rsi < 30 : false;

  // MACD come√ßando a divergir
  const macdDiverging = hasUpRun ? macd < macdSignal : hasDownRun ? macd > macdSignal : false;

  // 4. Verificar volume decrescente (sinal de exaust√£o)
  const volumes = recent.map(c => Number(c.volume) || 0);
  const avgVolume = volumes.slice(0, -1).reduce((a, b) => a + b, 0) / (volumes.length - 1);
  const lastVolume = volumes[volumes.length - 1];
  const volumeDecreasing = lastVolume < avgVolume * 0.8;

  // 5. Calcular confian√ßa da exaust√£o
  let exhaustionSignals = 0;
  if (isDoji) exhaustionSignals++;
  if (isShootingStar || isHammer) exhaustionSignals += 2;
  if (rsiExhausted) exhaustionSignals++;
  if (macdDiverging) exhaustionSignals++;
  if (volumeDecreasing) exhaustionSignals++;

  const isExhausted = exhaustionSignals >= 3;
  const confidence = Math.min(100, exhaustionSignals * 20);
  const reversalDirection = runDirection === 'UP' ? 'SELL' : runDirection === 'DOWN' ? 'BUY' : null;

  if (isExhausted) {
    console.log(`‚ö° [RUN EXHAUSTION] Exaust√£o detectada ap√≥s run ${runDirection}`, {
      bullishCandles,
      bearishCandles,
      isDoji,
      isShootingStar,
      isHammer,
      rsiExhausted,
      macdDiverging,
      volumeDecreasing,
      confidence
    });
  }

  return {
    isExhausted,
    runDirection,
    reversalDirection,
    confidence,
    details: {
      bullishCandles,
      bearishCandles,
      isDoji,
      isShootingStar,
      isHammer,
      rsiExhausted,
      macdDiverging,
      volumeDecreasing,
      exhaustionSignals
    }
  };
}

/**
 * ‚úÖ NOVO: Validar contexto espec√≠fico (REVERSAL vs BREAKOUT)
 * @param {string} patternType - 'REVERSAL' | 'BREAKOUT' | 'UNKNOWN'
 * @param {array} candles - Array de candles
 * @param {object} technicalIndicators - Indicadores t√©cnicos
 * @param {string} signalType - 'BUY' | 'SELL'
 * @returns {object} - { isValid: boolean, reason: string, details: object }
 */
function validatePatternContext(patternType, candles, technicalIndicators, signalType) {
  if (!candles || candles.length < 5) {
    return { isValid: false, reason: 'Poucos candles para validar contexto', details: {} };
  }

  const recent = candles.slice(-8); // √öltimos 8 candles para an√°lise
  const currentCandle = recent[recent.length - 1];
  const previousCandle = recent[recent.length - 2];

  // Volume
  const avgVolume = recent.slice(0, -1).reduce((sum, c) => sum + (Number(c.volume) || 0), 0) / (recent.length - 1);
  const currentVolume = Number(currentCandle.volume) || 0;
  const volumeSpike = currentVolume > avgVolume * 1.5;
  const volumeRatio = avgVolume > 0 ? currentVolume / avgVolume : 0;

  // Pre√ßos
  const currentClose = Number(currentCandle.close) || 0;
  const currentHigh = Number(currentCandle.high) || 0;
  const currentLow = Number(currentCandle.low) || 0;
  const currentOpen = Number(currentCandle.open) || 0;
  const previousClose = Number(previousCandle.close) || 0;

  // Range do candle
  const candleRange = currentClose > 0 ? ((currentHigh - currentLow) / currentClose) * 100 : 0;
  const bodySize = currentClose > 0 ? (Math.abs(currentClose - currentOpen) / currentClose) * 100 : 0;
  const upperWick = currentHigh - Math.max(currentOpen, currentClose);
  const lowerWick = Math.min(currentOpen, currentClose) - currentLow;
  const totalRange = currentHigh - currentLow;
  const upperWickPct = totalRange > 0 ? (upperWick / totalRange) * 100 : 0;
  const lowerWickPct = totalRange > 0 ? (lowerWick / totalRange) * 100 : 0;

  // Liquidity sweep detection
  const highs = recent.map(c => Number(c.high));
  const lows = recent.map(c => Number(c.low));
  const closes = recent.map(c => Number(c.close));
  const maxHigh = Math.max(...highs.slice(0, -2));
  const minLow = Math.min(...lows.slice(0, -2));

  const sweepHigh = currentHigh > maxHigh * 1.001 && currentClose < previousClose;
  const sweepLow = currentLow < minLow * 0.999 && currentClose > previousClose;
  const hasLiquiditySweep = sweepHigh || sweepLow;

  // Price change
  const priceChange = previousClose > 0 ? ((currentClose - previousClose) / previousClose) * 100 : 0;
  const isMovingInDirection = (signalType === 'BUY' && priceChange > 0) || (signalType === 'SELL' && priceChange < 0);

  // ‚úÖ VALIDA√á√ÉO PARA REVERSAL
  if (patternType === 'REVERSAL') {
    const hasRejection = (signalType === 'BUY' && lowerWickPct > 40) || // Wick inferior longo para BUY
      (signalType === 'SELL' && upperWickPct > 40);   // Wick superior longo para SELL

    const hasReversalVolume = volumeSpike || volumeRatio > 1.2; // Volume na revers√£o

    // Revers√£o v√°lida se: liquidity sweep OU rejei√ß√£o forte OU volume na revers√£o
    const isValid = hasLiquiditySweep || hasRejection || hasReversalVolume;

    return {
      isValid,
      reason: isValid
        ? 'Revers√£o validada'
        : 'Revers√£o sem confirma√ß√£o (falta liquidity sweep, rejei√ß√£o ou volume)',
      details: {
        hasLiquiditySweep,
        hasRejection,
        hasReversalVolume,
        upperWickPct: upperWickPct.toFixed(1),
        lowerWickPct: lowerWickPct.toFixed(1),
        volumeRatio: volumeRatio.toFixed(2)
      }
    };
  }

  // ‚úÖ VALIDA√á√ÉO PARA BREAKOUT
  if (patternType === 'BREAKOUT') {
    // Breakout v√°lido se: volume spike obrigat√≥rio + movimento na dire√ß√£o
    const isValid = volumeSpike && isMovingInDirection && candleRange > 0.1;

    return {
      isValid,
      reason: isValid
        ? 'Breakout validado'
        : !volumeSpike
          ? 'Breakout sem volume suficiente'
          : !isMovingInDirection
            ? 'Breakout sem movimento na dire√ß√£o'
            : 'Breakout sem range suficiente',
      details: {
        volumeSpike,
        volumeRatio: volumeRatio.toFixed(2),
        isMovingInDirection,
        priceChange: priceChange.toFixed(3),
        candleRange: candleRange.toFixed(2)
      }
    };
  }

  // ‚úÖ UNKNOWN: Valida√ß√£o gen√©rica (compatibilidade)
  return {
    isValid: volumeSpike || candleRange > 0.1,
    reason: 'Padr√£o desconhecido - valida√ß√£o gen√©rica',
    details: { volumeSpike, candleRange: candleRange.toFixed(2) }
  };
}

/**
 * ‚úÖ ESTRAT√âGIA PERFEITA 75x: Validar momentum real antes de entrar
 * Entrada ONLY se houver momentum real (n√£o preditivo)
 * ‚úÖ MELHORIA: Agora considera contexto de REVERSAL vs BREAKOUT
 */
function validateRealMomentum(candles, marketData, technicalIndicators, patternName = null, signalType = null) {
  if (!candles || candles.length < 3) {
    return {
      hasMomentum: false,
      direction: 'NEUTRAL',
      confidence: 0,
      reason: 'Poucos candles para validar momentum'
    };
  }

  // ‚úÖ NOVO: Classificar padr√£o e validar contexto espec√≠fico
  const patternType = patternName ? classifyPatternType(patternName) : 'UNKNOWN';
  const contextValidation = patternType !== 'UNKNOWN' && signalType
    ? validatePatternContext(patternType, candles, technicalIndicators, signalType)
    : null;

  const recent = candles.slice(-3); // √öltimos 3 candles
  const currentCandle = recent[recent.length - 1];
  const previousCandle = recent[recent.length - 2];

  // 1. Volume acima da m√©dia (ADAPTATIVO: M√©dia + 0.5 * Desvio Padr√£o)
  const recentVolumes = recent.slice(0, -1).map(c => Number(c.volume) || 0);
  const avgVolume = recentVolumes.reduce((sum, v) => sum + v, 0) / (recentVolumes.length || 1);
  const stdDevVolume = Math.sqrt(recentVolumes.reduce((sum, v) => sum + Math.pow(v - avgVolume, 2), 0) / (recentVolumes.length || 1));

  const currentVolume = Number(currentCandle.volume) || 0;
  // ‚úÖ ADAPTATIVO: Usa volatilidade do volume para definir spike, n√£o multiplicador fixo
  const volumeSpike = currentVolume > avgVolume + 0.5 * stdDevVolume;

  console.log(`üìä [ADAPTIVE MOMENTUM] Volume: ${currentVolume} > Threshold: ${(avgVolume + 0.5 * stdDevVolume).toFixed(1)} (Avg: ${avgVolume.toFixed(1)}, StdDev: ${stdDevVolume.toFixed(1)})`);

  // 2. Fluxo indo para o lado do trade
  const currentClose = Number(currentCandle.close) || 0;
  const previousClose = Number(previousCandle.close) || 0;
  const priceChange = previousClose > 0 ? ((currentClose - previousClose) / previousClose) * 100 : 0;
  const isBullishMomentum = priceChange > 0.05 && currentClose > Number(currentCandle.open || 0);
  const isBearishMomentum = priceChange < -0.05 && currentClose < Number(currentCandle.open || 0);

  // 3. Candle com range coerente (ADAPTATIVO: 50% do ATR)
  const candleHigh = Number(currentCandle.high) || 0;
  const candleLow = Number(currentCandle.low) || 0;
  const candleRange = currentClose > 0 ? ((candleHigh - candleLow) / currentClose) * 100 : 0;

  const atr = technicalIndicators?.atr_14 || technicalIndicators?.atr || 0;
  const atrPercent = currentClose > 0 ? (atr / currentClose) * 100 : 0.2; // fallback 0.2%

  // ‚úÖ ADAPTATIVO: Range deve ser expressivo em rela√ß√£o √† volatilidade atual (ATR)
  // Se ATR alto, exige candles maiores. Se ATR baixo, aceita menores.
  const hasRealRange = candleRange > atrPercent * 0.5;

  console.log(`üìä [ADAPTIVE RANGE] Range: ${candleRange.toFixed(3)}% > Threshold: ${(atrPercent * 0.5).toFixed(3)}% (50% do ATR)`);

  // ‚úÖ MELHORIA: Usar valida√ß√£o de contexto se dispon√≠vel
  let hasMomentum;
  if (contextValidation && patternType !== 'UNKNOWN') {
    // Se temos valida√ß√£o de contexto, usar ela (mais precisa)
    hasMomentum = contextValidation.isValid;
  } else {
    // Fallback para valida√ß√£o gen√©rica (compatibilidade)
    hasMomentum = volumeSpike && hasRealRange && (isBullishMomentum || isBearishMomentum);
  }

  return {
    hasMomentum,
    direction: isBullishMomentum ? 'BUY' : isBearishMomentum ? 'SELL' : 'NEUTRAL',
    confidence: volumeSpike ? 0.8 : 0.5,
    reason: contextValidation
      ? contextValidation.reason
      : (hasMomentum
        ? 'Momentum real confirmado'
        : !volumeSpike
          ? 'Volume insuficiente'
          : !hasRealRange
            ? 'Candle sem range (doji)'
            : 'Sem dire√ß√£o clara'),
    patternType, // ‚úÖ NOVO: Incluir tipo de padr√£o no retorno
    contextDetails: contextValidation?.details || {}
  };
}

/**
 * ‚úÖ REFATORA√á√ÉO: Valida√ß√£o consolidada de momentum
 * Unifica momentumCheck, hasRealMomentum, hasDirectionalMovement em uma √∫nica fun√ß√£o
 */
function validateMomentumConsolidated(
  candles: any[],
  marketData: any,
  technicalIndicators: any,
  patternName: string,
  signalType: string,
  confidenceScore: number
) {
  // 1. Valida√ß√£o de momentum real (padr√£o)
  const momentumCheck = validateRealMomentum(candles, marketData, technicalIndicators, patternName, signalType);

  // 2. Detec√ß√£o de movimento direcional claro (price change > 0.3%)
  let hasDirectionalMovement = false;
  let movementDirection = 'NEUTRAL';
  if (candles.length >= 3) {
    const recent3 = candles.slice(-3);
    const priceChange = recent3.length >= 2
      ? ((recent3[recent3.length - 1].close - recent3[recent3.length - 2].close) / recent3[recent3.length - 2].close) * 100
      : 0;
    if (Math.abs(priceChange) > 0.3) {
      hasDirectionalMovement = true;
      movementDirection = priceChange > 0 ? 'BUY' : 'SELL';
    }
  }

  // 3. Calcular hasRealMomentum com l√≥gica unificada
  const isVeryHighScore = confidenceScore >= 90;
  const hasRealMomentum = isVeryHighScore
    ? (momentumCheck.hasMomentum || momentumCheck.direction === signalType || momentumCheck.direction === 'NEUTRAL')
    : (momentumCheck.hasMomentum && (
      momentumCheck.direction === signalType ||
      (momentumCheck.direction === 'NEUTRAL' && momentumCheck.confidence >= 0.7)
    ));

  // 4. Determinar se momentum √© v√°lido para trade
  const momentumValid = hasRealMomentum ||
    (hasDirectionalMovement && movementDirection === signalType);

  return {
    momentumCheck,
    hasRealMomentum,
    hasDirectionalMovement,
    movementDirection,
    momentumValid,
    isVeryHighScore
  };
}

/**
 * ‚úÖ FASE 1: Fun√ß√£o centralizada para c√°lculo de ATR com thresholds espec√≠ficos por timeframe
 * Resolve problema de ATR "0.000" em M1 usando ATR curta + volatility floor
 */
function calculateATRPercent(
  technicalIndicators: any,
  currentPrice: number,
  timeframe: string
): { atrPercent: number; atrMinThreshold: number; atrMaxThreshold: number; atr: number } {
  // 1. ATR curta com fallback (prioriza ATR curta para M1)
  const atrShort = technicalIndicators?.atr_3
    ?? technicalIndicators?.atr_5
    ?? technicalIndicators?.atr_7
    ?? technicalIndicators?.atr_14
    ?? technicalIndicators?.atr
    ?? 0;

  // 2. Calcular ATR percentual
  const rawAtrPercent = currentPrice > 0 ? (atrShort / currentPrice) * 100 : 0;

  // 3. Volatility Floor (evita ATR = 0)
  const volatilityFloor = 0.05; // 0.05% m√≠nimo
  const atrPercent = Math.max(rawAtrPercent, volatilityFloor);

  // 4. Thresholds espec√≠ficos por timeframe
  let atrMinThreshold: number;
  let atrMaxThreshold: number;

  const tf = timeframe?.toUpperCase() || '';
  if (tf === '1M' || tf === 'M1') {
    // M1: thresholds muito mais baixos para microvolatilidade
    atrMinThreshold = 0.03; // 0.03%
    atrMaxThreshold = 0.50; // 0.50%
  } else if (tf === '5M' || tf === 'M5') {
    // M5: thresholds intermedi√°rios
    atrMinThreshold = 0.10; // 0.10%
    atrMaxThreshold = 1.00; // 1.00%
  } else {
    // M15, M30, H1+: thresholds originais (mant√©m seguran√ßa)
    atrMinThreshold = 0.32; // 0.32%
    atrMaxThreshold = 2.10; // 2.10%
  }

  return {
    atrPercent,
    atrMinThreshold,
    atrMaxThreshold,
    atr: atrShort
  };
}

/**
 * ‚úÖ REFATORA√á√ÉO: Valida√ß√£o consolidada de ATR
 * Unifica atrPercent, atrValid, atrScoreReduction em uma √∫nica fun√ß√£o
 * ‚úÖ FASE 1: Agora usa thresholds espec√≠ficos por timeframe + ATR curta + volatility floor
 */
function validateATRConsolidated(
  technicalIndicators: any,
  currentPrice: number,
  hasDirectionalMovement: boolean,
  movementDirection: string,
  signalType: string,
  timeframe: string = '1m' // ‚úÖ FASE 1: Adicionado par√¢metro timeframe
) {
  // ‚úÖ FASE 1: Usar fun√ß√£o centralizada para c√°lculo de ATR
  const { atrPercent, atrMinThreshold, atrMaxThreshold, atr } = calculateATRPercent(
    technicalIndicators,
    currentPrice,
    timeframe
  );

  // Valida√ß√£o b√°sica
  const atrValid = atrPercent >= atrMinThreshold && atrPercent <= atrMaxThreshold;

  // C√°lculo de redu√ß√£o de score m√≠nimo baseado em ATR (ajustado para thresholds din√¢micos)
  let atrScoreReduction = 0;
  // ‚úÖ FASE 1: Usar thresholds din√¢micos ao inv√©s de valores fixos
  const highVolatilityThreshold = atrMaxThreshold * 0.95; // 95% do m√°ximo
  const moderateVolatilityThreshold = atrMaxThreshold * 0.70; // 70% do m√°ximo

  if (atrPercent > highVolatilityThreshold) {
    atrScoreReduction = 5; // ATR muito alto: redu√ß√£o de 5 pontos
  } else if (atrPercent > moderateVolatilityThreshold) {
    atrScoreReduction = 3; // ATR moderado-alto: redu√ß√£o de 3 pontos
  }

  // Redu√ß√£o adicional por movimento direcional claro
  if (hasDirectionalMovement && movementDirection === signalType) {
    atrScoreReduction += 3; // Movimento direcional: +3 pontos de redu√ß√£o
  }

  return {
    atr,
    atrPercent,
    atrMinThreshold,
    atrMaxThreshold,
    atrValid,
    atrScoreReduction
  };
}

/**
 * ‚úÖ REFATORA√á√ÉO: Valida√ß√£o final consolidada de trade
 * Unifica todas as condi√ß√µes de valida√ß√£o em uma √∫nica fun√ß√£o
 * ‚úÖ NOVO: Agora inclui valida√ß√£o de conflu√™ncia m√≠nima
 */
function validateTradeCreation(
  savedSignal: boolean,
  signalType: string,
  validationScore: number,
  minScore: number,
  atrValidation: ReturnType<typeof validateATRConsolidated>,
  momentumValidation: ReturnType<typeof validateMomentumConsolidated>,
  isFallbackPattern: boolean,
  confluenceValidation?: { hasMinConfluence: boolean; confluenceCount: number; shouldProceed: boolean } // ‚úÖ NOVO
) {
  // 1. Score m√≠nimo ajustado por ATR (REDUZIDO PARA LIBERAR MAIS TRADES)
  const adjustedMinScore = Math.max(20, minScore - atrValidation.atrScoreReduction); // ‚úÖ REDUZIDO: De 30 para 20 para liberar muito mais trades
  const meetsScoreRequirement = validationScore >= adjustedMinScore;

  // 2. Valida√ß√£o de momentum (com override para scores altos - REDUZIDO)
  const isHighScoreOverride = validationScore >= 50; // ‚úÖ REDUZIDO: De 65 para 50 para liberar mais trades
  const canCreateTrade = isHighScoreOverride
    ? true // Score ‚â•50 permite trade mesmo sem momentum perfeito (reduzido de 65)
    : (momentumValidation.momentumValid ||
      validationScore >= 35 || // ‚úÖ REDUZIDO: De 55 para 35 para liberar mais trades
      (momentumValidation.hasDirectionalMovement && momentumValidation.movementDirection === signalType));

  // ‚úÖ AJUSTADO: Permitir padr√µes fallback quando score √© alto o suficiente
  // Score ‚â•45: permite padr√µes fallback (reduzido de 50)
  const allowsFallbackPattern = validationScore >= 45; // Score ‚â•45 permite fallback
  const patternValid = !isFallbackPattern || allowsFallbackPattern;

  // ‚úÖ AJUSTADO: Valida√ß√£o de conflu√™ncia m√≠nima
  // Requer 2+ conflu√™ncias OU confidence>=75% OU score>=55
  const confluenceValid = confluenceValidation
    ? (confluenceValidation.shouldProceed || validationScore >= 55) // Score ‚â•55 compensa (reduzido de 60)
    : true; // Backward compatibility: se n√£o passar, assume v√°lido

  // 3. Condi√ß√µes finais consolidadas
  const allConditionsMet = savedSignal &&
    signalType !== 'NEUTRAL' &&
    meetsScoreRequirement &&
    patternValid && // ‚úÖ AJUSTE: Usar patternValid ao inv√©s de !isFallbackPattern
    canCreateTrade &&
    atrValidation.atrValid &&
    confluenceValid; // ‚úÖ NOVO: Adicionar valida√ß√£o de conflu√™ncia

  return {
    adjustedMinScore,
    meetsScoreRequirement,
    canCreateTrade,
    isHighScoreOverride,
    allConditionsMet,
    confluenceValid, // ‚úÖ NOVO: Expor resultado da valida√ß√£o de conflu√™ncia
    validationDetails: {
      hasSignal: savedSignal,
      signalTypeValid: signalType !== 'NEUTRAL',
      scoreValid: meetsScoreRequirement,
      patternValid: patternValid, // ‚úÖ AJUSTE: Usar patternValid
      momentumValid: canCreateTrade,
      atrValid: atrValidation.atrValid,
      confluenceValid: confluenceValid // ‚úÖ NOVO
    }
  };
}

async function createTradeState(supabase, user_id, symbol, timeframe, direction, entry_price, stop_price, target_price, pattern, confluences, confidence, orderBookAnalysis = null, marketRegime = null) {
  try {
    const INITIAL_EQUITY = 10000; // ‚úÖ MUDAN√áA: Equity inicial $10,000
    const symbolConfig = getSymbolConfig(symbol);

    // ============================================================================
    // üö´ FILTRO ANTI-DUPLICA√á√ÉO: N√£o criar m√∫ltiplos trades no mesmo minuto
    // PROBLEMA: Sistema estava criando 11 BUYs em 6 minutos!
    // ============================================================================
    const oneMinuteAgo = new Date(Date.now() - 60 * 1000).toISOString();
    const { data: recentTrades, error: recentError } = await supabase
      .from(TRADE_STATE_TABLE)
      .select('id, created_at, direction, pattern')
      .eq('user_id', user_id)
      .eq('symbol', symbol)
      .eq('direction', direction)
      .gte('created_at', oneMinuteAgo)
      .order('created_at', { ascending: false })
      .limit(1);

    if (!recentError && recentTrades && recentTrades.length > 0) {
      const lastTrade = recentTrades[0];
      const secondsSinceLastTrade = (Date.now() - new Date(lastTrade.created_at).getTime()) / 1000;

      logTrade('warn', 'üö´ [ANTI-DUPLICA√á√ÉO] Trade bloqueado - muito recente', {
        symbol,
        direction,
        pattern,
        lastTradeId: lastTrade.id,
        secondsSinceLastTrade: secondsSinceLastTrade.toFixed(0),
        minIntervalSeconds: 60
      });

      return { data: null, error: { message: 'Trade duplicado bloqueado - aguarde 60s' } };
    }

    // ============================================================================
    // üö´ GUARD RAIL #1: Hard-block de padr√µes problem√°ticos (BOS Bullish, Order Block Bullish)
    // ============================================================================
    const patternBlock = shouldBlockPattern(pattern, confidence);
    if (patternBlock.blocked) {
      logTrade('warn', 'üö´ [HARD-BLOCK] Padr√£o bloqueado', {
        symbol,
        direction,
        pattern,
        confidence,
        reason: patternBlock.reason
      });
      return { data: null, error: { message: patternBlock.reason } };
    }

    // ============================================================================
    // üö´ GUARD RAIL #2 e #3: Penaliza√ß√£o de contexto (RANGING + hor√°rios t√≥xicos)
    // ============================================================================
    const contextPenalties = calculateContextPenalties(marketRegime);
    const adjustedConfidence = confidence - contextPenalties.penalty;
    if (adjustedConfidence < 55 && contextPenalties.penalty > 0) {
      logTrade('warn', 'üö´ [CONTEXT-BLOCK] Trade bloqueado por contexto', {
        symbol,
        direction,
        pattern,
        originalConfidence: confidence,
        penalty: contextPenalties.penalty,
        adjustedConfidence,
        reasons: contextPenalties.reasons
      });
      return { data: null, error: { message: `Score ${adjustedConfidence} ap√≥s penalidades < 55` } };
    }

    // ============================================================================
    // üö´ FILTRO ANTI-TEND√äNCIA: N√£o comprar quando mercado caindo, n√£o vender quando subindo
    // PROBLEMA: Sistema comprava BUY enquanto BTC ca√≠a -0.5% em 5 minutos!
    // ============================================================================
    const { data: recentCandles, error: candleError } = await supabase
      .from('market_m1')
      .select('data')
      .eq('symbol', symbol.replace('/', ''))
      .order('timestamp', { ascending: false })
      .limit(5);

    if (!candleError && recentCandles && recentCandles.length >= 5) {
      const candles = recentCandles.map(c => c.data);
      if (candles[0] && candles[4]) {
        const currentPrice = Number(candles[0].close) || Number(candles[0].c) || 0;
        const price5MinAgo = Number(candles[4].open) || Number(candles[4].o) || currentPrice;

        if (currentPrice > 0 && price5MinAgo > 0) {
          const priceChange5Min = ((currentPrice - price5MinAgo) / price5MinAgo) * 100;

          // ‚ùå BUY quando mercado caiu mais de -0.3% nos √∫ltimos 5 min = BLOQUEADO
          if (direction === 'BUY' && priceChange5Min < -0.3) {
            logTrade('warn', 'üö´ [ANTI-TEND√äNCIA] BUY bloqueado - mercado em queda', {
              symbol,
              direction,
              pattern,
              priceChange5Min: priceChange5Min.toFixed(2) + '%',
              currentPrice: currentPrice.toFixed(2),
              price5MinAgo: price5MinAgo.toFixed(2),
              threshold: '-0.3%'
            });

            return { data: null, error: { message: `BUY bloqueado - mercado caindo ${priceChange5Min.toFixed(2)}%` } };
          }

          // ‚ùå SELL quando mercado subiu mais de +0.3% nos √∫ltimos 5 min = BLOQUEADO
          if (direction === 'SELL' && priceChange5Min > 0.3) {
            logTrade('warn', 'üö´ [ANTI-TEND√äNCIA] SELL bloqueado - mercado em alta', {
              symbol,
              direction,
              pattern,
              priceChange5Min: priceChange5Min.toFixed(2) + '%',
              currentPrice: currentPrice.toFixed(2),
              price5MinAgo: price5MinAgo.toFixed(2),
              threshold: '+0.3%'
            });

            return { data: null, error: { message: `SELL bloqueado - mercado subindo ${priceChange5Min.toFixed(2)}%` } };
          }

          // ‚úÖ Trade alinhado com tend√™ncia de curto prazo
          logTrade('debug', '‚úÖ [ANTI-TEND√äNCIA] Trade alinhado com tend√™ncia', {
            symbol,
            direction,
            priceChange5Min: priceChange5Min.toFixed(2) + '%'
          });
        }
      }
    }

    // ‚úÖ FASE 1: Calcular spread REAL do order book (ao inv√©s de fixo)
    // Se orderBookAnalysis dispon√≠vel e tem bestBid/bestAsk, usar spread real
    // Caso contr√°rio, usar fallback de 0.02%
    let marketSpread = 0.0002; // Fallback: 0.02% - spread bid/ask m√©dio

    if (orderBookAnalysis && orderBookAnalysis.realSpread !== undefined) {
      // ‚úÖ Usar spread real calculado do order book
      marketSpread = orderBookAnalysis.realSpread;
      logTrade('debug', 'Spread real calculado do order book', {
        spread: (marketSpread * 100).toFixed(4) + '%',
        bestBid: orderBookAnalysis.bestBid?.toFixed(2),
        bestAsk: orderBookAnalysis.bestAsk?.toFixed(2),
        symbol
      });
    } else {
      logTrade('debug', 'Usando spread fixo (order book n√£o dispon√≠vel)', {
        spread: (marketSpread * 100).toFixed(4) + '%',
        symbol
      });
    }

    // ‚úÖ Slippage ainda aleat√≥rio (Fase 2 implementar√° c√°lculo real baseado em liquidez)
    const slippage = Math.random() * 0.0004 + 0.0001; // 0.01% - 0.05% aleat√≥rio

    // Salvar pre√ßo de mercado original para ajustar stop/target
    const originalEntryPrice = entry_price;

    // Aplicar spread + slippage no pre√ßo de entrada
    let adjustedEntryPrice = entry_price;
    if (direction === 'BUY' || direction === 'LONG') {
      // BUY: executa no ASK (pre√ßo mais alto) + slippage
      adjustedEntryPrice = entry_price * (1 + marketSpread / 2 + slippage);
    } else {
      // SELL: executa no BID (pre√ßo mais baixo) - slippage
      adjustedEntryPrice = entry_price * (1 - marketSpread / 2 - slippage);
    }

    // ‚úÖ Ajustar stop_price e target_price para manter a mesma DIST√ÇNCIA ABSOLUTA do pre√ßo original
    // Isso mant√©m o risco/recompensa original, apenas ajusta o ponto de entrada
    const stopDistance = Math.abs(originalEntryPrice - stop_price);
    const targetDistance = Math.abs(target_price - originalEntryPrice);

    if (direction === 'BUY' || direction === 'LONG') {
      // BUY: stop abaixo, target acima
      stop_price = adjustedEntryPrice - stopDistance;
      target_price = adjustedEntryPrice + targetDistance;
    } else {
      // SELL: stop acima, target abaixo
      stop_price = adjustedEntryPrice + stopDistance;
      target_price = adjustedEntryPrice - targetDistance;
    }

    // Usar o pre√ßo ajustado como entry_price
    entry_price = adjustedEntryPrice;

    // ‚úÖ Log para debug (apenas quando diferen√ßa significativa)
    const priceDiff = Math.abs(adjustedEntryPrice - originalEntryPrice);
    const priceDiffPct = (priceDiff / originalEntryPrice) * 100;
    if (priceDiffPct > 0.01) { // Log apenas se diferen√ßa > 0.01%
      logTrade('debug', 'Pre√ßo ajustado com spread/slippage', {
        original: originalEntryPrice.toFixed(2),
        adjusted: adjustedEntryPrice.toFixed(2),
        diffPct: priceDiffPct.toFixed(4),
        spread: (marketSpread * 100).toFixed(4) + '%',
        slippage: (slippage * 100).toFixed(4) + '%',
        spreadType: orderBookAnalysis && orderBookAnalysis.realSpread !== undefined ? 'REAL (order book)' : 'FIXO (fallback)'
      });
    }

    // ‚úÖ CORRE√á√ÉO: Calcular equity atual da IA antes de criar o trade
    const currentEquity = user_id === 'system-ai'
      ? await calculateCurrentAiEquity(supabase)
      : INITIAL_EQUITY;

    // ‚úÖ META DI√ÅRIA: Verificar se atingiu $800 de lucro hoje
    const { dailyPnL, reachedTarget } = user_id === 'system-ai'
      ? await calculateDailyPnL(supabase)
      : { dailyPnL: 0, reachedTarget: false };

    // ‚úÖ CORRE√á√ÉO: Calcular position_size_value baseado no equity atual e limites do s√≠mbolo
    // Position size n√£o pode exceder a entrada m√°xima do s√≠mbolo
    // üéØ Se meta di√°ria atingida: usar apenas 30% do tamanho normal
    const positionMultiplier = reachedTarget ? REDUCED_POSITION_MULTIPLIER : 1.0;
    const basePositionSize = Math.min(
      currentEquity * symbolConfig.positionSizePct,  // Baseado em % do equity
      symbolConfig.maxEntry  // N√£o exceder entrada m√°xima do s√≠mbolo
    );
    const positionSizeValue = basePositionSize * positionMultiplier;
    const quantity = positionSizeValue / entry_price; // Quantidade real baseada no position size (usa pre√ßo ajustado)

    if (reachedTarget) {
      logTrade('info', 'üéØ META DI√ÅRIA: Operando com posi√ß√£o reduzida', {
        dailyPnL: `$${dailyPnL.toFixed(2)}`,
        baseSize: `$${basePositionSize.toFixed(2)}`,
        reducedSize: `$${positionSizeValue.toFixed(2)}`,
        reduction: `${((1 - positionMultiplier) * 100).toFixed(0)}%`
      });
    }

    // ‚úÖ VALIDA√á√ïES: Verificar limites por s√≠mbolo (em PERCENTUAL do pre√ßo de entrada)
    const stopDistancePct = Math.abs((entry_price - stop_price) / entry_price) * 100;
    const targetDistancePct = Math.abs((target_price - entry_price) / entry_price) * 100;

    // Validar stop m√°ximo (percentual do pre√ßo)
    if (stopDistancePct > symbolConfig.maxStopPct) {
      logTrade('warn', 'Stop excede m√°ximo permitido', {
        stopPct: stopDistancePct.toFixed(2),
        maxPct: symbolConfig.maxStopPct,
        symbol
      });
      // Ajustar stop para m√°ximo permitido
      if (direction === 'BUY' || direction === 'LONG') {
        stop_price = entry_price * (1 - symbolConfig.maxStopPct / 100);
      } else {
        stop_price = entry_price * (1 + symbolConfig.maxStopPct / 100);
      }
    }

    // Validar target m√≠nimo (percentual do pre√ßo) - razo√°vel para alavancagem 75x
    if (targetDistancePct < symbolConfig.minTargetPct) {
      logTrade('warn', 'Target abaixo do m√≠nimo permitido', {
        targetPct: targetDistancePct.toFixed(2),
        minPct: symbolConfig.minTargetPct,
        symbol
      });
      // Ajustar target para m√≠nimo permitido
      if (direction === 'BUY' || direction === 'LONG') {
        target_price = entry_price * (1 + symbolConfig.minTargetPct / 100);
      } else {
        target_price = entry_price * (1 - symbolConfig.minTargetPct / 100);
      }
    }

    // ‚úÖ VALIDA√á√ÉO EXTRA: Garantir que target n√£o seja negativo ou absurdo
    if (target_price <= 0 || target_price > entry_price * 10 || target_price < entry_price / 10) {
      logTrade('warn', 'Target inv√°lido, ajustando', { target: target_price, symbol });
      // Recalcular target baseado no percentual m√≠nimo
      if (direction === 'BUY' || direction === 'LONG') {
        target_price = entry_price * (1 + symbolConfig.minTargetPct / 100);
      } else {
        target_price = entry_price * (1 - symbolConfig.minTargetPct / 100);
      }
    }


    const tradeData: any = {
      user_id,
      symbol,
      timeframe,
      direction,
      entry_price,
      stop_price,
      target_price,
      pattern,
      confluences_initial: Array.isArray(confluences) ? confluences : [],
      confidence_initial: confidence,
      confidence: confidence,  // ‚úÖ 19/dez: Salvar confidence para an√°lises futuras
      status: "active",
      leverage: symbolConfig.leverage, // ‚úÖ Alavancagem do s√≠mbolo (75x)
      quantity: Number(quantity.toFixed(8)), // ‚úÖ Quantidade real calculada
      position_size: symbolConfig.positionSizePct, // ‚úÖ Percentual do equity usado
      position_size_value: Number(positionSizeValue.toFixed(2)), // ‚úÖ Valor absoluto do position size
      account_equity_at_entry: Number(currentEquity.toFixed(2)), // ‚úÖ CR√çTICO: Equity salvo na entrada
      market_regime: marketRegime || 'UNKNOWN', // ‚úÖ FIX: Salvar regime para an√°lise estat√≠stica
      created_at: new Date().toISOString()
    };

    const { data, error } = await supabase.from(TRADE_STATE_TABLE).insert(tradeData).select().single();
    if (error) {
      logTrade('warn', 'Erro ao criar trade_state', { error: error.message });
      return {
        data: null,
        error
      };
    }
    logTrade('info', 'TradeState criado', {
      equity: currentEquity.toFixed(2),
      entry: entry_price.toFixed(2),
      quantity: quantity.toFixed(8),
      symbol,
      direction
    });

    // üîó COPY TRADE: Enviar webhook imediatamente ap√≥s criar o trade
    // N√£o paramos o fluxo se falhar (fire-and-forget logica interna)
    await sendCopyTradeWebhook(supabase, tradeData);

    return {
      data,
      error: null
    };
  } catch (err) {
    logTrade('warn', 'Exce√ß√£o ao criar trade_state', { error: err?.message || err });
    return {
      data: null,
      error: err
    };
  }
}

/**
 * ‚úÖ NOVO: Dispara aprendizado do padr√£o ap√≥s fechar trade
 */
async function triggerPatternLearning(supabase: any, patternName: string) {
  try {
    if (!patternName || patternName === 'unknown') return;

    // 1. Buscar ID do padr√£o na mem√≥ria
    const { data: patternMem } = await supabase
      .from('ai_pattern_memory')
      .select('id')
      .eq('pattern_name', patternName)
      .maybeSingle();

    if (!patternMem) return; // Padr√£o n√£o monitorado

    // 2. Calcular estat√≠sticas atualizadas
    const { data: history } = await supabase
      .from('trade_history')
      .select('result')
      .eq('pattern', patternName);

    if (!history || history.length === 0) return;

    const total = history.length;
    const wins = history.filter((h: any) => h.result === 'WIN').length;
    const winRate = wins / total;

    // 3. Atualizar status (Promo√ß√£o/Rebaixamento)
    await updatePatternStatus(supabase, patternMem.id, winRate, total);

    logEngine('info', 'üß† [AI LEARNING] Padr√£o atualizado', {
      pattern: patternName,
      winRate: (winRate * 100).toFixed(1) + '%',
      total: total
    });

  } catch (error) {
    console.warn('‚ö†Ô∏è [AI LEARNING] Falha ao processar aprendizado:', error);
  }
}

/**
 * ‚úÖ CORRE√á√ÉO CR√çTICA #6: Calcular P&L e fechar trade corretamente
 */ async function closeTradeWithPnL(supabase, trade, exitPrice, reason, details) {
  try {
    if (!trade || !trade.id || !trade.entry_price || !trade.direction) {
      logTrade('warn', 'Dados inv√°lidos para fechar trade', { tradeId: trade?.id });
      return { data: null, error: new Error('Dados inv√°lidos') };
    }

    // Calcular P&L baseado na dire√ß√£o
    let pnl = 0;
    if (trade.direction === 'BUY' || trade.direction === 'LONG') {
      pnl = exitPrice - trade.entry_price;
    } else {
      pnl = trade.entry_price - exitPrice;
    }

    // Ajustar P&L pelo quantity e leverage
    const quantity = trade.quantity || 0;
    const leverage = trade.leverage || 1;
    const pnlAdjusted = pnl * quantity * leverage;

    // Determinar resultado
    const result = pnlAdjusted > 0 ? 'WIN' : pnlAdjusted < 0 ? 'LOSS' : 'BREAKEVEN';

    // üèÜ PREMIUM TRADE DETECTION (v292)
    // Trade √© premium se: WIN + trailing ativou + progresso > 50%
    const trailingProgress = trade.trailing_progress || 0; // % do target atingido
    const trailingActivated = trade.trailing_activated || false;
    const isPremiumTrade = result === 'WIN' && trailingActivated && trailingProgress >= 50;
    const tradeQuality = isPremiumTrade ? 'premium' : 'standard';

    if (isPremiumTrade) {
      console.log(`üèÜ [PREMIUM] Trade ${trade.id.slice(0, 8)} qualificou como PREMIUM! Trailing: ${trailingProgress}%`);
    }

    // Atualizar trade como completed com P&L
    const { data, error } = await supabase.from(TRADE_STATE_TABLE).update({
      status: 'completed',
      exit_price: exitPrice,
      pnl: Number(pnlAdjusted.toFixed(2)),
      completed_at: new Date().toISOString(),
      invalidation_reason: reason,
      invalidation_details: details || {},
      trade_quality: tradeQuality,
      updated_at: new Date().toISOString()
    }).eq('id', trade.id).select().single();

    if (error) {
      logTrade('warn', 'Erro ao fechar trade com P&L', { error: error.message, tradeId: trade.id });
      return { data: null, error };
    }

    // Salvar em trade_history
    try {
      await supabase.from('trade_history').insert({
        signal_id: trade.id,
        pattern: trade.pattern || 'unknown',
        symbol: trade.symbol || '',
        timeframe: trade.timeframe || '',
        entry_price: trade.entry_price,
        exit_price: exitPrice,
        pnl: Number(pnlAdjusted.toFixed(2)),
        result: result,
        created_at: new Date().toISOString()
      });
    } catch (historyError) {
      logTrade('warn', 'Erro ao salvar trade_history', { error: historyError?.message, tradeId: trade.id });
    }

    logTrade('info', 'Trade fechado com P&L calculado', {
      tradeId: trade.id,
      direction: trade.direction,
      entry: trade.entry_price,
      exit: exitPrice,
      pnl: pnlAdjusted.toFixed(2),
      result: result,
      reason: reason,
      quality: tradeQuality
    });

    // üß† AI LEARNING: Atualizar intelig√™ncia do padr√£o
    // Fire-and-forget para n√£o travar o fechamento
    triggerPatternLearning(supabase, trade.pattern).catch(console.error);

    // üèÜ PREMIUM BONUS: Dar boost extra no Pattern Memory
    if (isPremiumTrade && trade.pattern && trade.symbol) {
      try {
        const symbolNormalized = (trade.symbol || '').replace(/[^A-Z0-9]/gi, '').toUpperCase();
        console.log(`üéÅ [BONUS] Aplicando boost premium para ${trade.pattern} @ ${symbolNormalized}`);

        // Buscar registro atual
        const { data: currentMemory } = await supabase
          .from('ai_pattern_memory')
          .select('id, wins, adaptive_weight')
          .ilike('pattern_name', `%${trade.pattern}%`)
          .eq('symbol', symbolNormalized)
          .limit(1)
          .single();

        if (currentMemory) {
          // Boost: +2 wins extras e +0.2 no weight (max 1.5)
          const newWins = (currentMemory.wins || 0) + 2;
          const newWeight = Math.min(1.5, (parseFloat(currentMemory.adaptive_weight) || 1) + 0.2);

          await supabase
            .from('ai_pattern_memory')
            .update({
              wins: newWins,
              adaptive_weight: newWeight,
              last_updated: new Date().toISOString()
            })
            .eq('id', currentMemory.id);

          console.log(`‚úÖ [BONUS] Boost premium aplicado: wins=${newWins}, weight=${newWeight.toFixed(2)}`);
        } else {
          console.log(`‚ö†Ô∏è [BONUS] Padr√£o ${trade.pattern} @ ${symbolNormalized} n√£o encontrado no Pattern Memory`);
        }
      } catch (bonusError) {
        console.warn(`‚ö†Ô∏è [BONUS] Erro ao aplicar boost premium:`, bonusError?.message);
      }
    }

    // üîó COPY TRADE: Enviar sinal de CLOSE para Telegram/Cornix
    // Fire-and-forget para n√£o travar o fechamento
    sendCopyTradeCloseSignal(supabase, {
      symbol: trade.symbol || '',
      direction: trade.direction,
      entry_price: trade.entry_price,
      exit_price: exitPrice,
      pnl: Number(pnlAdjusted.toFixed(2)),
      reason: reason
    }).catch(console.error);

    // ‚ö° 19/dez: SINCRONIZAR FECHAMENTO COM BYBIT API
    // Fechar posi√ß√£o real na Bybit para todos os usu√°rios com API Keys
    closePositionForAllApiKeys(supabase, {
      symbol: trade.symbol || '',
      side: trade.direction
    }).catch((err: any) => console.warn('‚ö†Ô∏è [BYBIT SYNC] Erro ao fechar posi√ß√£o:', err?.message));

    return { data, error: null };
  } catch (err) {
    logTrade('warn', 'Exce√ß√£o ao fechar trade com P&L', { error: err?.message || err, tradeId: trade?.id });
    return { data: null, error: err };
  }
}


/**
 * Invalidar trade quando quebrar (n√£o-invasivo)
 * ‚úÖ CORRE√á√ÉO CR√çTICA #6: Agora calcula P&L antes de invalidar
 */ async function invalidateTradeState(supabase, id, reason, details, currentPrice = null) {
  try {
    // ‚úÖ NOVO: Buscar trade antes de invalidar para calcular P&L
    const { data: trade, error: fetchError } = await supabase.from(TRADE_STATE_TABLE)
      .select('*')
      .eq('id', id)
      .maybeSingle();

    if (fetchError) {
      logTrade('warn', 'Erro ao buscar trade para invalidar', { error: fetchError.message, tradeId: id });
      return { data: null, error: fetchError };
    }

    if (!trade) {
      logTrade('warn', 'Trade n√£o encontrado para invalidar', { tradeId: id });
      return { data: null, error: new Error('Trade n√£o encontrado') };
    }

    // ‚úÖ CORRE√á√ÉO: Se temos pre√ßo atual e trade est√° ativo, calcular P&L antes de invalidar
    if (trade.status === 'active' && currentPrice && currentPrice > 0) {
      const closeResult = await closeTradeWithPnL(supabase, trade, currentPrice, reason, details);
      if (closeResult.error) {
        logTrade('warn', 'Erro ao fechar trade antes de invalidar, tentando invalidar diretamente', {
          error: closeResult.error.message,
          tradeId: id
        });
        // Continuar com invalida√ß√£o direta se fechar falhar
      } else {
        // Trade foi fechado com P&L, retornar resultado
        return closeResult;
      }
    }

    // Se n√£o h√° pre√ßo atual ou trade j√° est√° invalidado, apenas invalidar
    const { data, error } = await supabase.from(TRADE_STATE_TABLE).update({
      status: "invalidated",
      invalidation_reason: reason,
      invalidation_details: details || {},
      invalidated_at: new Date().toISOString()
    }).eq("id", id).select().single();

    if (error) {
      logTrade('warn', 'Erro ao invalidar trade_state', { error: error.message, tradeId: id });
      return {
        data: null,
        error
      };
    }
    return {
      data,
      error: null
    };
  } catch (err) {
    logTrade('warn', 'Exce√ß√£o ao invalidar trade_state', { error: err?.message || err, tradeId: id });
    return {
      data: null,
      error: err
    };
  }
}
/**
 * Atualizar acompanhamento de tend√™ncia (n√£o-invasivo)
 */ async function updateTrendFollow(supabase, id, new_score, health, message) {
  try {
    const { data, error } = await supabase.from(TRADE_STATE_TABLE).update({
      trend_follow_score: new_score,
      trend_health: health,
      trend_message: message,
      updated_at: new Date().toISOString()
    }).eq("id", id).select().single();
    if (error) {
      logTrade('warn', 'Erro ao atualizar trend_follow', { error: error.message, tradeId: id });
      return {
        data: null,
        error
      };
    }
    return {
      data,
      error: null
    };
  } catch (err) {
    logTrade('warn', 'Exce√ß√£o ao atualizar trend_follow', { error: err?.message || err, tradeId: id });
    return {
      data: null,
      error: err
    };
  }
}

// ============================================================================
// üß† UNIFIED BRAIN - Resolve Conflitos e Gera Estado Final √önico
// ============================================================================
/**
 * üÜï UnifiedBrain - M√≥dulo central que unifica todas as an√°lises e resolve conflitos
 * Prioridade: ML > MTF > Patterns > Indicators
 * ‚úÖ CORRE√á√ÉO: Movido para n√≠vel superior para evitar erro de inicializa√ß√£o
 */
class UnifiedBrain {
  async process(input: {
    indicators: any;
    mtf: any;
    patterns: any;
    ml: any;
    volume: any;
    volatility: any;
    patternMemory?: any;
  }): Promise<{
    bias: 'bullish' | 'bearish' | 'neutral';
    confidenceScore: number;
    volatilityState: 'compressed' | 'expanded' | 'normal';
    volumeState: 'high' | 'normal' | 'low';
    liquidityRisk: number;
    trendPhase: 'accumulation' | 'markup' | 'distribution' | 'markdown';
    signalType: 'BUY' | 'SELL' | 'NEUTRAL';
    reasoning: string;
    confluences: string[];
    conflicts: Array<{ module1: string; module2: string; conflict: string; resolution: string; confidence: number }>;
  }> {
    const { indicators, mtf, patterns, ml, volume, volatility, patternMemory } = input;
    const conflicts: Array<{ module1: string; module2: string; conflict: string; resolution: string; confidence: number }> = [];
    const confluences: string[] = [];

    // 1. COLETAR SINAIS DE CADA M√ìDULO
    const moduleSignals: any = {
      mtf: {
        direction: mtf?.direction || mtf?.globalBias?.direction || 'neutral',
        confidence: mtf?.confidence || mtf?.globalBias?.confidence || 50,
        recommendation: mtf?.recommendation || 'WAIT',
        source: 'MTF'
      },
      patterns: {
        direction: patterns?.direction || (patterns?.isBullishPattern ? 'bullish' : patterns?.isBearishPattern ? 'bearish' : 'neutral'),
        confidence: patterns?.confidence || 50,
        source: 'Patterns'
      },
      indicators: {
        direction: this.getIndicatorDirection(indicators),
        confidence: this.getIndicatorConfidence(indicators),
        source: 'Indicators'
      },
      ml: {
        direction: ml?.direction || patternMemory?.direction || 'neutral',
        confidence: ml?.confidence || patternMemory?.matchPercentage || 50,
        source: 'ML'
      }
    };

    // 2. DETECTAR CONFLITOS
    const directions = Object.values(moduleSignals).map((s: any) => s.direction);
    const uniqueDirections = [...new Set(directions.filter(d => d !== 'neutral'))];

    if (uniqueDirections.length > 1) {
      // ‚úÖ PROTE√á√ÉO EVENT LOOP: Limitar loop aninhado e adicionar yield
      // H√° conflito - identificar m√≥dulos conflitantes
      const moduleKeys = Object.keys(moduleSignals);
      const maxModules = 20; // Limitar para evitar bloqueio do event loop
      const limitedKeys = moduleKeys.slice(0, maxModules);

      for (let i = 0; i < limitedKeys.length; i++) {
        // ‚úÖ Yield ao event loop a cada 5 itera√ß√µes para evitar bloqueio
        if (i > 0 && i % 5 === 0) {
          await new Promise(resolve => setTimeout(resolve, 0));
        }

        for (let j = i + 1; j < limitedKeys.length; j++) {
          const mod1 = limitedKeys[i];
          const mod2 = limitedKeys[j];
          const sig1 = moduleSignals[mod1];
          const sig2 = moduleSignals[mod2];

          if (sig1.direction !== 'neutral' && sig2.direction !== 'neutral' && sig1.direction !== sig2.direction) {
            conflicts.push({
              module1: sig1.source,
              module2: sig2.source,
              conflict: `${sig1.source} diz ${sig1.direction}, ${sig2.source} diz ${sig2.direction}`,
              resolution: this.resolveConflict(sig1, sig2),
              confidence: Math.max(sig1.confidence, sig2.confidence)
            });
          }
        }
      }
    }

    // 3. RESOLVER CONFLITOS (Prioridade: ML > MTF > Patterns > Indicators)
    let finalDirection: 'bullish' | 'bearish' | 'neutral' = 'neutral';
    let finalConfidence = 0;
    let reasoning = '';

    // Calcular score de conflu√™ncia total
    let totalConfluenceScore = 0;
    const confluenceWeights = { ml: 0.3, mtf: 0.3, patterns: 0.25, indicators: 0.15 };

    for (const modKey of Object.keys(moduleSignals)) {
      const signal = moduleSignals[modKey];
      const weight = confluenceWeights[modKey] || 0.1;
      if (signal.direction !== 'neutral') {
        totalConfluenceScore += signal.confidence * weight;
      }
    }

    // Priorizar por ordem de confiabilidade
    const priorityOrder = ['ml', 'mtf', 'patterns', 'indicators'];

    for (const modKey of priorityOrder) {
      const signal = moduleSignals[modKey];
      if (signal.direction !== 'neutral' && signal.confidence >= 50 && signal.confidence > finalConfidence) {
        finalDirection = signal.direction;
        finalConfidence = signal.confidence;
        reasoning = `Dire√ß√£o determinada por ${signal.source} (confian√ßa: ${signal.confidence}%, conflu√™ncia total: ${totalConfluenceScore.toFixed(1)})`;
      }
    }

    // Se ainda neutro, usar voto majorit√°rio
    if (finalDirection === 'neutral') {
      const bullishVotes = directions.filter(d => d === 'bullish').length;
      const bearishVotes = directions.filter(d => d === 'bearish').length;

      if (bullishVotes > bearishVotes) {
        finalDirection = 'bullish';
        reasoning = `Dire√ß√£o determinada por voto majorit√°rio (${bullishVotes} m√≥dulos bullish)`;
      } else if (bearishVotes > bullishVotes) {
        finalDirection = 'bearish';
        reasoning = `Dire√ß√£o determinada por voto majorit√°rio (${bearishVotes} m√≥dulos bearish)`;
      } else {
        reasoning = 'Dire√ß√£o neutra - m√≥dulos n√£o convergem';
      }
    }

    // 4. CALCULAR CONFIDENCE SCORE FINAL
    const avgConfidence = Object.values(moduleSignals).reduce((sum: number, s: any) => sum + s.confidence, 0) / Object.keys(moduleSignals).length;
    const conflictPenalty = conflicts.length * 3;
    const baseScore = totalConfluenceScore > 0 ? totalConfluenceScore : avgConfidence;
    const finalConfidenceScore = Math.max(0, Math.min(100, Math.round(baseScore - conflictPenalty)));

    // 5. DETERMINAR VOLATILITY STATE
    const atr = volatility?.atr || indicators?.atr;
    const volatilityState: 'compressed' | 'expanded' | 'normal' =
      atr && atr > 0.02 ? 'expanded' :
        atr && atr < 0.005 ? 'compressed' :
          'normal';

    // 6. DETERMINAR VOLUME STATE
    const volumeZScore = volume?.volume_z_score || indicators?.volume_z_score || 0;
    const volumeState: 'high' | 'normal' | 'low' =
      volumeZScore > 1.5 ? 'high' :
        volumeZScore < -1.5 ? 'low' :
          'normal';

    // 7. CALCULAR LIQUIDITY RISK
    const liquidityRisk = Math.max(0, Math.min(100,
      50 +
      (volatilityState === 'expanded' ? 20 : 0) +
      (volumeState === 'low' ? 15 : 0) +
      (conflicts.length * 10)
    ));

    // 8. DETERMINAR TREND PHASE
    const trendPhase: 'accumulation' | 'markup' | 'distribution' | 'markdown' =
      mtf?.phases?.accumulation ? 'accumulation' :
        mtf?.phases?.markup ? 'markup' :
          mtf?.phases?.distribution ? 'distribution' :
            mtf?.phases?.markdown ? 'markdown' :
              'accumulation';

    // 9. DETERMINAR SIGNAL TYPE
    const signalType: 'BUY' | 'SELL' | 'NEUTRAL' =
      finalDirection === 'bullish' ? 'BUY' :
        finalDirection === 'bearish' ? 'SELL' :
          'NEUTRAL';

    // 10. GERAR CONFLU√äNCIAS
    if (mtf?.alignment === 'aligned' || mtf?.alignment === 'neutral') {
      confluences.push(`MTF: ${mtf.reasoning || 'Contexto MTF aplicado'}`);
    }
    if (moduleSignals.ml.confidence > 60) {
      confluences.push(`ML confian√ßa: ${moduleSignals.ml.confidence}%`);
    }
    if (volumeState === 'high') {
      confluences.push(`Volume alto (Z-score: ${volumeZScore.toFixed(2)})`);
    }
    if (volatilityState === 'compressed') {
      confluences.push(`Volatilidade comprimida - poss√≠vel breakout`);
    }

    return {
      bias: finalDirection,
      confidenceScore: finalConfidenceScore,
      volatilityState,
      volumeState,
      liquidityRisk,
      trendPhase,
      signalType,
      reasoning,
      confluences,
      conflicts
    };
  }

  private getIndicatorDirection(indicators: any): 'bullish' | 'bearish' | 'neutral' {
    const rsi = indicators?.rsi_14 || indicators?.rsi;
    const ema9 = indicators?.ema_9;
    const ema50 = indicators?.ema_50;
    const ema200 = indicators?.ema_200;

    let bullish = 0;
    let bearish = 0;

    if (rsi) {
      if (rsi > 50) bullish++;
      else if (rsi < 50) bearish++;
    }

    if (ema9 && ema50) {
      if (ema9 > ema50) bullish++;
      else bearish++;
    }

    if (ema50 && ema200) {
      if (ema50 > ema200) bullish++;
      else bearish++;
    }

    if (bullish > bearish) return 'bullish';
    if (bearish > bullish) return 'bearish';
    return 'neutral';
  }

  private getIndicatorConfidence(indicators: any): number {
    const rsi = indicators?.rsi_14 || indicators?.rsi;
    let confidence = 50;

    if (rsi) {
      if (rsi > 70 || rsi < 30) confidence += 20;
      else if (rsi > 60 || rsi < 40) confidence += 10;
    }

    return Math.min(100, confidence);
  }

  private resolveConflict(sig1: any, sig2: any): string {
    const priority: any = { 'ML': 4, 'MTF': 3, 'Patterns': 2, 'Indicators': 1 };
    const p1 = priority[sig1.source] || 0;
    const p2 = priority[sig2.source] || 0;

    if (p1 > p2) {
      return `Priorizado ${sig1.source} sobre ${sig2.source} (prioridade maior)`;
    } else if (p2 > p1) {
      return `Priorizado ${sig2.source} sobre ${sig1.source} (prioridade maior)`;
    } else {
      if (sig1.confidence > sig2.confidence) {
        return `Priorizado ${sig1.source} sobre ${sig2.source} (confian√ßa maior: ${sig1.confidence}% vs ${sig2.confidence}%)`;
      } else {
        return `Priorizado ${sig2.source} sobre ${sig1.source} (confian√ßa maior: ${sig2.confidence}% vs ${sig1.confidence}%)`;
      }
    }
  }
}

// ============================================================================
// üÜï TRAILING STOP + TIME DECAY + HEALTH DECAY (FASE 1 COMPLETA)
// ============================================================================
/**
 * Aplicar Trailing Stop Inteligente (BUY e SELL)
 */ async function applyTrailingStop(supabase, trade, currentPrice) {
  try {
    if (!trade || !trade.id || !trade.direction || !trade.entry_price || !trade.stop_price) {
      return; // Dados inv√°lidos
    }
    // ‚úÖ CORRIGIDO: Stop inicial 0.5%, quando pre√ßo move 0.5% ‚Üí mover stop para break even
    const profitTrigger = 0.005; // ‚úÖ CORRIGIDO: 0.5% para ativar trailing (reduzido de 1.5%)
    const breakEvenThreshold = 0.005; // ‚úÖ NOVO: 0.5% de lucro para mover para break even
    let shouldUpdate = false;
    let newStop = trade.stop_price;

    if (trade.direction === 'BUY') {
      const profitPercent = (currentPrice - trade.entry_price) / trade.entry_price;
      const profitDollar = (currentPrice - trade.entry_price) * (trade.position_size || 1);

      // ‚úÖ v287: TRAILING PROGRESSIVO baseado em $ de lucro
      if (profitDollar >= 100) {
        // $100+ de lucro ‚Üí proteger $50 (50%)
        const protectAmount = 50;
        const protectPercent = protectAmount / (trade.position_size || 1);
        newStop = trade.entry_price + protectPercent;
        if (newStop > trade.stop_price) shouldUpdate = true;
      } else if (profitDollar >= 60) {
        // $60+ de lucro ‚Üí proteger $20 (33%)
        const protectAmount = 20;
        const protectPercent = protectAmount / (trade.position_size || 1);
        newStop = trade.entry_price + protectPercent;
        if (newStop > trade.stop_price) shouldUpdate = true;
      } else if (profitDollar >= 30) {
        // $30+ de lucro ‚Üí proteger $10 (33%)
        const protectAmount = 10;
        const protectPercent = protectAmount / (trade.position_size || 1);
        newStop = trade.entry_price + protectPercent;
        if (newStop > trade.stop_price) shouldUpdate = true;
      } else if (profitPercent >= breakEvenThreshold) {
        // 0.5%+ de lucro ‚Üí mover para breakeven
        newStop = trade.entry_price;
        if (newStop > trade.stop_price) shouldUpdate = true;
      }
    } else if (trade.direction === 'SELL') {
      const profitPercent = (trade.entry_price - currentPrice) / trade.entry_price;
      const profitDollar = (trade.entry_price - currentPrice) * (trade.position_size || 1);

      // ‚úÖ v287: TRAILING PROGRESSIVO baseado em $ de lucro
      if (profitDollar >= 100) {
        // $100+ de lucro ‚Üí proteger $50 (50%)
        const protectAmount = 50;
        const protectPercent = protectAmount / (trade.position_size || 1);
        newStop = trade.entry_price - protectPercent;
        if (newStop < trade.stop_price) shouldUpdate = true;
      } else if (profitDollar >= 60) {
        // $60+ de lucro ‚Üí proteger $20 (33%)
        const protectAmount = 20;
        const protectPercent = protectAmount / (trade.position_size || 1);
        newStop = trade.entry_price - protectPercent;
        if (newStop < trade.stop_price) shouldUpdate = true;
      } else if (profitDollar >= 30) {
        // $30+ de lucro ‚Üí proteger $10 (33%)
        const protectAmount = 10;
        const protectPercent = protectAmount / (trade.position_size || 1);
        newStop = trade.entry_price - protectPercent;
        if (newStop < trade.stop_price) shouldUpdate = true;
      } else if (profitPercent >= breakEvenThreshold) {
        // 0.5%+ de lucro ‚Üí mover para breakeven
        newStop = trade.entry_price;
        if (newStop < trade.stop_price) shouldUpdate = true;
      }
    }
    if (shouldUpdate) {
      const { error } = await supabase.from(TRADE_STATE_TABLE).update({
        stop_price: Number(newStop.toFixed(2)),
        updated_at: new Date().toISOString()
      }).eq('id', trade.id);
      if (!error) {
        logTrade('info', 'Stop movido (trailing)', {
          newStop: newStop.toFixed(2),
          direction: trade.direction,
          tradeId: trade.id
        });
      } else {
        logTrade('warn', 'Erro ao atualizar stop (trailing)', { error: error.message, tradeId: trade.id });
      }
    }
  } catch (err) {
    logTrade('warn', 'Exce√ß√£o ao aplicar trailing stop', { error: err?.message || err });
  }
}
/**
 * Aplicar Time Decay (invalida√ß√£o por tempo sem movimento)
 */ async function applyTimeDecay(supabase, trade, currentPrice, timeframe) {
  try {
    if (!trade || !trade.id || !trade.created_at || !trade.entry_price) {
      return; // Dados inv√°lidos
    }
    // Mapear timeframe para minutos
    const timeframeMap = {
      '1m': 1,
      '1': 1,
      '3m': 3,
      '3': 3,
      '5m': 5,
      '5': 5,
      '15m': 15,
      '15': 15,
      '30m': 30,
      '30': 30,
      '1h': 60,
      '1H': 60,
      '60': 60,
      '4h': 240,
      '4H': 240,
      '240': 240,
      '1d': 1440,
      '1D': 1440,
      '1440': 1440
    };
    const timeframeMinutes = timeframeMap[timeframe] || 1;
    const msSinceEntry = Date.now() - new Date(trade.created_at).getTime();
    const candlesSinceEntry = Math.floor(msSinceEntry / (timeframeMinutes * 60 * 1000));
    // Calcular profit atual
    const profit = trade.direction === 'BUY' ? (currentPrice - trade.entry_price) / trade.entry_price : (trade.entry_price - currentPrice) / trade.entry_price;

    // ‚úÖ v285: TIME DECAY DESATIVADO
    // Trades agora s√≥ fecham por: Stop, Target, ou Timeout de 13min
    // A fun√ß√£o applyTimeDecay n√£o invalida mais trades antecipadamente
    const shouldInvalidate = false; // DESATIVADO

    if (shouldInvalidate) {
      // Este c√≥digo n√£o ser√° mais executado
      await invalidateTradeState(supabase, trade.id, 'Time Decay - Renova√ß√£o', {
        candlesSinceEntry: 0,
        profitPercent: (profit * 100).toFixed(2),
        timeframe: timeframe,
        currentPrice: currentPrice,
        entryPrice: trade.entry_price
      }, currentPrice);
      logTrade('info', 'Trade invalidado por time decay', {
        candlesSinceEntry,
        profitPct: (profit * 100).toFixed(2),
        tradeId: trade.id
      });
    }
  } catch (err) {
    logTrade('warn', 'Exce√ß√£o ao aplicar time decay', { error: err?.message || err });
  }
}
/**
 * Atualizar Health Decay (score degrada com idade do trade)
 * ‚úÖ NOVO: Fecha trade automaticamente ap√≥s TRADE_TIMEOUT_MINUTES (13 min)
 */ async function updateHealthDecay(supabase, trade, strengthScore, currentPrice = null) {
  try {
    if (!trade || !trade.id || !trade.created_at) {
      return { timedOut: false }; // Dados inv√°lidos
    }
    const ageMinutes = (Date.now() - new Date(trade.created_at).getTime()) / 60000;

    // ‚úÖ TIMEOUT: Fechar trade ap√≥s 13 minutos automaticamente
    if (ageMinutes >= TRADE_TIMEOUT_MINUTES && currentPrice) {
      logTrade('info', '‚è±Ô∏è TIMEOUT: Fechando trade ap√≥s 13 minutos', {
        tradeId: trade.id,
        symbol: trade.symbol,
        ageMinutes: Math.round(ageMinutes),
        timeout: TRADE_TIMEOUT_MINUTES,
        currentPrice
      });

      // Fechar trade com P&L atual
      await closeTradeWithPnL(supabase, trade, currentPrice, 'TIMEOUT', {
        ageMinutes: Math.round(ageMinutes),
        timeout: TRADE_TIMEOUT_MINUTES
      });

      return { timedOut: true };
    }

    // Penalidade por idade: -30 pontos ap√≥s 90 minutos (linear)
    // M√°ximo de -30 pontos para n√£o zerar completamente
    const agePenalty = Math.min(ageMinutes / 3, 30);
    const finalScore = Math.max(0, Math.round(strengthScore - agePenalty));
    // Determinar health baseado no score final
    let health = 'strong';
    if (finalScore < 40) {
      health = 'weak';
    } else if (finalScore < 65) {
      health = 'neutral';
    }
    const { error } = await supabase.from(TRADE_STATE_TABLE).update({
      trend_follow_score: finalScore,
      trend_health: health,
      trend_message: `Score ajustado por idade: -${agePenalty.toFixed(0)} pts (${Math.round(ageMinutes)}min)`,
      updated_at: new Date().toISOString()
    }).eq('id', trade.id);
    if (error) {
      logEngine('warn', 'Erro ao atualizar health decay', { error: error.message, tradeId: trade.id });
    } else if (agePenalty > 0) {
      logEngine('debug', 'Score ajustado por health decay', {
        before: strengthScore,
        after: finalScore,
        ageMinutes: Math.round(ageMinutes),
        penalty: agePenalty.toFixed(1)
      });
    }
    return { timedOut: false };
  } catch (err) {
    logEngine('warn', 'Exce√ß√£o ao atualizar health decay', { error: err?.message || err });
    return { timedOut: false };
  }
}
// ============================================================================
// üèóÔ∏è MTF HIERARCHICAL CASCADE - Arquitetura Unificada e Infal√≠vel
// ============================================================================
/**
 * üÜï MTF Hierarchical Cascade - An√°lise unificada com fallback hier√°rquico
 * Substitui analyzeMTFContextual + calculateTrendState com arquitetura profissional
 */
async function analyzeMTFUnified(multiTimeframeContext: any, pattern: any, analysis: any, temporalAwareness: any = {}) {
  try {
    // ‚úÖ FRACTAL: Detectar padr√µes em m√∫ltiplos timeframes (estrutura fractal completa)
    let fractalPatterns = {};
    try {
      fractalPatterns = await detectPatternsMultiTimeframe(multiTimeframeContext);
      if (Object.keys(fractalPatterns).length > 0) {
        logIntelligence('info', 'Padr√µes fractais detectados', { patterns: fractalPatterns });
      }
    } catch (error) {
      logError('warn', 'Erro ao detectar padr√µes fractais (continuando sem eles)', { error: error?.message || error });
    }

    // 1. DEFINIR HIERARQUIA DE TIMEFRAMES (M1 ‚Üí M5 ‚Üí M15 ‚Üí M30 ‚Üí H1 ‚Üí H4 ‚Üí D1)
    const timeframeHierarchy = [
      { key: 'm1', name: 'M1', priority: 1, type: 'local' },
      { key: 'm5', name: 'M5', priority: 2, type: 'local' },
      { key: 'm15', name: 'M15', priority: 3, type: 'global' },
      { key: 'm30', name: 'M30', priority: 4, type: 'global' },
      { key: 'h1', name: 'H1', priority: 5, type: 'global' },
      { key: 'h4', name: 'H4', priority: 6, type: 'global' },
      { key: 'd1', name: 'D1', priority: 7, type: 'global' }
    ];

    // 2. COLETAR E PROCESSAR TIMEFRAMES COM FALLBACK
    const processedTimeframes: any[] = [];
    let lastValidState: any = null;

    for (const tf of timeframeHierarchy) {
      const tfData = multiTimeframeContext[tf.key];

      if (tfData) {
        // Timeframe existe - processar
        const direction = tfData.macro_trend || tfData.trend_direction ||
          (tfData.price > tfData.open ? 'bullish' :
            tfData.price < tfData.open ? 'bearish' : 'neutral');
        const strength = tfData.trend_strength ||
          (tfData.confidence || 50);

        const state = {
          timeframe: tf.name,
          key: tf.key,
          type: tf.type,
          direction,
          strength: typeof strength === 'number' ? strength : 50,
          confidence: tfData.confidence || 50,
          available: true
        };

        processedTimeframes.push(state);
        lastValidState = state;
      } else if (lastValidState) {
        // Timeframe n√£o existe - usar fallback (interpola√ß√£o do √∫ltimo v√°lido)
        processedTimeframes.push({
          timeframe: tf.name,
          key: tf.key,
          type: tf.type,
          direction: lastValidState.direction,
          strength: Math.max(30, lastValidState.strength - 10), // Reduzir for√ßa no fallback
          confidence: Math.max(30, lastValidState.confidence - 15),
          available: false,
          _fallback: true
        });
      } else {
        // Primeiro timeframe n√£o existe - usar neutral
        processedTimeframes.push({
          timeframe: tf.name,
          key: tf.key,
          type: tf.type,
          direction: 'neutral',
          strength: 0,
          confidence: 0,
          available: false,
          _fallback: true
        });
      }
    }

    // 3. DETERMINAR BIAS GLOBAL (prioridade: M30 > M15 > H1 > H4 > D1)
    const globalTimeframes = processedTimeframes.filter(tf => tf.type === 'global');
    let globalBias = {
      timeframe: 'M30',
      direction: 'neutral' as 'bullish' | 'bearish' | 'neutral',
      strength: 0,
      confidence: 0,
      duration: temporalAwareness?.duration || 0
    };

    // Prioridade: M30 > M15 > H1 > H4 > D1
    const m30 = globalTimeframes.find(tf => tf.timeframe === 'M30');
    const m15 = globalTimeframes.find(tf => tf.timeframe === 'M15');
    const h1 = globalTimeframes.find(tf => tf.timeframe === 'H1');

    if (m30 && m30.available) {
      globalBias = {
        timeframe: 'M30',
        direction: m30.direction,
        strength: m30.strength,
        confidence: m30.confidence,
        duration: temporalAwareness?.duration || 0
      };
    } else if (m15 && m15.available) {
      globalBias = {
        timeframe: 'M15',
        direction: m15.direction,
        strength: m15.strength,
        confidence: m15.confidence,
        duration: temporalAwareness?.duration || 0
      };
    } else if (h1 && h1.available) {
      globalBias = {
        timeframe: 'H1',
        direction: h1.direction,
        strength: h1.strength,
        confidence: h1.confidence,
        duration: temporalAwareness?.duration || 0
      };
    }

    // 4. DETERMINAR ENTRADA LOCAL (M1 > M5)
    const localTimeframes = processedTimeframes.filter(tf => tf.type === 'local');
    const m1 = localTimeframes.find(tf => tf.timeframe === 'M1');
    const m5 = localTimeframes.find(tf => tf.timeframe === 'M5');

    // Determinar dire√ß√£o do padr√£o
    const patternType = pattern?.type || '';
    let patternDirection: 'bullish' | 'bearish' | 'neutral' = 'neutral';

    if (patternType.includes('bullish') || patternType.includes('buy') ||
      patternType.includes('spring') || patternType.includes('hammer') ||
      patternType.includes('alta') || patternType.includes('bull')) {
      patternDirection = 'bullish';
    } else if (patternType.includes('bearish') || patternType.includes('sell') ||
      patternType.includes('upthrust') || patternType.includes('shooting') ||
      patternType.includes('baixa') || patternType.includes('bear')) {
      patternDirection = 'bearish';
    }

    const localEntry = {
      timeframe: m1?.available ? 'M1' : (m5?.available ? 'M5' : 'M1'),
      pattern: patternType || 'unknown',
      direction: patternDirection,
      score: analysis?.confidenceScore || 50,
      confidence: m1?.confidence || m5?.confidence || 50
    };

    // 5. CALCULAR TEND√äNCIA CONSOLIDADA (de todos os timeframes)
    const trends = processedTimeframes
      .filter(tf => tf.available && tf.direction !== 'neutral')
      .map(tf => ({ tf: tf.timeframe, direction: tf.direction, strength: tf.strength }));

    const bullishCount = trends.filter(t => t.direction === 'bullish').length;
    const bearishCount = trends.filter(t => t.direction === 'bearish').length;
    const alignedTrends = trends.filter(t => {
      const dominant = bullishCount > bearishCount ? 'bullish' : 'bearish';
      return t.direction === dominant;
    });

    const avgStrength = alignedTrends.length > 0
      ? alignedTrends.reduce((sum, t) => sum + t.strength, 0) / alignedTrends.length
      : 50;

    let consolidatedDirection: 'bullish' | 'bearish' | 'neutral' = 'neutral';
    if (bullishCount > bearishCount && bullishCount > 0) {
      consolidatedDirection = 'bullish';
    } else if (bearishCount > bullishCount && bearishCount > 0) {
      consolidatedDirection = 'bearish';
    }

    let consolidatedStrength: 'weak' | 'moderate' | 'strong' = 'weak';
    if (alignedTrends.length >= 3 && avgStrength > 70) {
      consolidatedStrength = 'strong';
    } else if (alignedTrends.length >= 2 && avgStrength > 50) {
      consolidatedStrength = 'moderate';
    }

    const consolidatedConfidence = trends.length > 0
      ? Math.min(100, Math.round((alignedTrends.length / trends.length) * 100 * (avgStrength / 100)))
      : 0;

    // 6. ANALISAR ALINHAMENTO E GERAR RECOMENDA√á√ÉO
    let alignment: 'aligned' | 'counter-trend' | 'neutral' | 'divergent' = 'neutral';
    let recommendation: 'PROCEED' | 'WAIT' | 'AVOID' = 'WAIT';
    let reasoning = '';
    let scoreAdjustment = 0;

    // Caso 1: Alinhado (global e local na mesma dire√ß√£o)
    if (globalBias.direction === localEntry.direction &&
      globalBias.direction !== 'neutral' &&
      localEntry.direction !== 'neutral') {
      alignment = 'aligned';
      recommendation = 'PROCEED';
      scoreAdjustment = +20;
      reasoning = `‚úÖ Alinhamento perfeito: Bias global ${globalBias.timeframe} ${globalBias.direction} + Entrada local ${localEntry.timeframe} ${localEntry.direction}. Alta probabilidade de sucesso.`;
    }
    // Caso 2: Contra-tend√™ncia
    else if (globalBias.direction !== 'neutral' &&
      localEntry.direction !== 'neutral' &&
      globalBias.direction !== localEntry.direction) {
      alignment = 'counter-trend';
      recommendation = 'AVOID';
      scoreAdjustment = -25;
      reasoning = `‚ö†Ô∏è Contra-tend√™ncia detectada: Bias global ${globalBias.timeframe} ${globalBias.direction} vs Entrada local ${localEntry.timeframe} ${localEntry.direction}. Risco elevado.`;
    }
    // Caso 3: Bias global neutro
    else if (globalBias.direction === 'neutral') {
      alignment = 'neutral';
      recommendation = 'WAIT';
      scoreAdjustment = -5;
      reasoning = `‚è≥ Bias global indefinido (${globalBias.timeframe} neutro). Aguardar defini√ß√£o de tend√™ncia maior antes de entrar.`;
    }
    // Caso 4: Padr√£o local neutro
    else if (localEntry.direction === 'neutral') {
      alignment = 'neutral';
      recommendation = 'WAIT';
      scoreAdjustment = -10;
      reasoning = `‚è≥ Padr√£o local indefinido. Aguardar confirma√ß√£o mais clara no ${localEntry.timeframe}.`;
    }
    // Caso 5: Diverg√™ncia
    else {
      alignment = 'divergent';
      recommendation = 'AVOID';
      scoreAdjustment = -15;
      reasoning = `‚ùå Diverg√™ncia: Contexto global e local mostram sinais conflitantes. Evitar entrada.`;
    }

    // Ajuste baseado na for√ßa do bias global
    if (globalBias.strength > 70 && alignment === 'aligned') {
      scoreAdjustment += 10;
      reasoning += ` Bias global muito forte (${globalBias.strength}%) - confian√ßa adicional.`;
    } else if (globalBias.strength < 30 && alignment === 'counter-trend') {
      scoreAdjustment -= 5;
      reasoning += ` Bias global fraco (${globalBias.strength}%) - risco moderado.`;
    }

    // ‚úÖ FRACTAL: Aplicar contexto de padr√µes fractais antes de calcular alinhamento
    const fractalContext: string[] = [];
    let fractalScoreAdjustment = 0;

    // D1 (Dia) - Contexto maior
    if (fractalPatterns.d1) {
      const d1Pattern = String(fractalPatterns.d1).toLowerCase();
      if (d1Pattern.includes('doji')) {
        fractalContext.push('üìÖ D1: Doji detectado - Indecis√£o no dia, ser cauteloso');
        fractalScoreAdjustment -= 10;
      } else if (d1Pattern.includes('inside')) {
        fractalContext.push('üìÖ D1: Inside Bar - Consolida√ß√£o di√°ria, aguardar rompimento');
        fractalScoreAdjustment -= 5;
      } else if (d1Pattern.includes('tri√¢ngulo') || d1Pattern.includes('triangle')) {
        fractalContext.push('üìÖ D1: Tri√¢ngulo - Consolida√ß√£o semanal, aguardar rompimento');
        fractalScoreAdjustment -= 8;
      } else if (d1Pattern.includes('cunha') || d1Pattern.includes('wedge')) {
        fractalContext.push('üìÖ D1: Cunha - Exaust√£o de tend√™ncia, poss√≠vel revers√£o');
        fractalScoreAdjustment -= 12;
      }
    }

    // H1 (Hora) - Contexto m√©dio
    if (fractalPatterns.h1) {
      const h1Pattern = String(fractalPatterns.h1).toLowerCase();
      if (h1Pattern.includes('tri√¢ngulo') || h1Pattern.includes('triangle')) {
        fractalContext.push('‚è∞ H1: Tri√¢ngulo - Consolida√ß√£o hor√°ria, aguardar rompimento');
        if (recommendation === 'PROCEED') {
          recommendation = 'WAIT'; // Mudar para WAIT se estava PROCEED
        }
        fractalScoreAdjustment -= 8;
      } else if (h1Pattern.includes('inside')) {
        fractalContext.push('‚è∞ H1: Inside Bar - Consolida√ß√£o hor√°ria');
        fractalScoreAdjustment -= 5;
      } else if (h1Pattern.includes('range') || h1Pattern.includes('ret√¢ngulo')) {
        fractalContext.push('‚è∞ H1: Range - Mercado lateral, aguardar rompimento');
        fractalScoreAdjustment -= 6;
      }
    }

    // M30 (30min) - Contexto intermedi√°rio
    if (fractalPatterns.m30) {
      const m30Pattern = String(fractalPatterns.m30).toLowerCase();
      if (m30Pattern.includes('tri√¢ngulo') || m30Pattern.includes('triangle')) {
        fractalContext.push('üìä M30: Tri√¢ngulo - Consolida√ß√£o de 30min');
        fractalScoreAdjustment -= 5;
      } else if (m30Pattern.includes('bos') || m30Pattern.includes('break of structure')) {
        fractalContext.push('üìä M30: BOS detectado - Mudan√ßa de estrutura');
        fractalScoreAdjustment += 5;
      } else if (m30Pattern.includes('choch') || m30Pattern.includes('change of character')) {
        fractalContext.push('üìä M30: CHOCH detectado - Mudan√ßa de car√°ter');
        fractalScoreAdjustment += 3;
      }
    }

    // M15 (15min) - Contexto local-alto
    if (fractalPatterns.m15) {
      const m15Pattern = String(fractalPatterns.m15).toLowerCase();
      if (m15Pattern.includes('tri√¢ngulo') || m15Pattern.includes('triangle')) {
        fractalContext.push('üìà M15: Tri√¢ngulo - Consolida√ß√£o de 15min');
        fractalScoreAdjustment -= 3;
      }
    }

    // ‚úÖ FRACTAL: M5 e M1 - Contexto local (confirmar e complementar padr√£o principal)
    if (fractalPatterns.m5) {
      const m5Pattern = String(fractalPatterns.m5).toLowerCase();
      if (m5Pattern.includes('hammer')) {
        fractalContext.push('üîç M5: Hammer detectado - Revers√£o de baixa confirmada');
        fractalScoreAdjustment += 3; // Confirma√ß√£o positiva
      } else if (m5Pattern.includes('doji')) {
        fractalContext.push('üîç M5: Doji detectado - Indecis√£o local');
        fractalScoreAdjustment -= 3; // Indecis√£o reduz confian√ßa
      } else if (m5Pattern.includes('shooting star')) {
        fractalContext.push('üîç M5: Shooting Star detectado - Revers√£o de alta');
        fractalScoreAdjustment += 3;
      } else if (m5Pattern.includes('bos') || m5Pattern.includes('break of structure')) {
        fractalContext.push('üîç M5: BOS detectado - Mudan√ßa de estrutura local');
        fractalScoreAdjustment += 5;
      } else if (m5Pattern.includes('choch') || m5Pattern.includes('change of character')) {
        fractalContext.push('üîç M5: CHOCH detectado - Mudan√ßa de car√°ter local');
        fractalScoreAdjustment += 3;
      } else if (m5Pattern.includes('fvg') || m5Pattern.includes('fair value gap')) {
        fractalContext.push('üîç M5: FVG detectado - Gap de valor justo');
        fractalScoreAdjustment += 2;
      } else if (m5Pattern.includes('order block') || m5Pattern.includes('ob')) {
        fractalContext.push('üîç M5: Order Block detectado - Zona de ordem institucional');
        fractalScoreAdjustment += 4;
      }
    }

    // ‚úÖ FRACTAL: M1 - Padr√£o de entrada local (mais importante para timing)
    if (fractalPatterns.m1) {
      const m1Pattern = String(fractalPatterns.m1).toLowerCase();
      if (m1Pattern.includes('hammer')) {
        fractalContext.push('‚ö° M1: Hammer detectado - Revers√£o de baixa iminente');
        fractalScoreAdjustment += 5; // Padr√£o forte em M1
      } else if (m1Pattern.includes('shooting star')) {
        fractalContext.push('‚ö° M1: Shooting Star detectado - Revers√£o de alta iminente');
        fractalScoreAdjustment += 5;
      } else if (m1Pattern.includes('doji')) {
        fractalContext.push('‚ö° M1: Doji detectado - Indecis√£o no momento da entrada');
        fractalScoreAdjustment -= 5; // Indecis√£o em M1 √© mais cr√≠tica
      } else if (m1Pattern.includes('engulfing')) {
        fractalContext.push('‚ö° M1: Engulfing detectado - Revers√£o forte confirmada');
        fractalScoreAdjustment += 6; // Engulfing √© muito forte
      } else if (m1Pattern.includes('bos') || m1Pattern.includes('break of structure')) {
        fractalContext.push('‚ö° M1: BOS detectado - Mudan√ßa de estrutura imediata');
        fractalScoreAdjustment += 7; // BOS em M1 √© muito significativo
      } else if (m1Pattern.includes('choch') || m1Pattern.includes('change of character')) {
        fractalContext.push('‚ö° M1: CHOCH detectado - Mudan√ßa de car√°ter imediata');
        fractalScoreAdjustment += 5;
      } else if (m1Pattern.includes('fvg') || m1Pattern.includes('fair value gap')) {
        fractalContext.push('‚ö° M1: FVG detectado - Gap de valor justo no momento');
        fractalScoreAdjustment += 4;
      } else if (m1Pattern.includes('order block') || m1Pattern.includes('ob')) {
        fractalContext.push('‚ö° M1: Order Block detectado - Zona de ordem no momento');
        fractalScoreAdjustment += 6; // OB em M1 √© muito importante
      } else if (m1Pattern.includes('liquidity sweep')) {
        fractalContext.push('‚ö° M1: Liquidity Sweep detectado - Limpeza de liquidez');
        fractalScoreAdjustment += 4;
      } else if (m1Pattern.includes('spring') || m1Pattern.includes('wyckoff')) {
        fractalContext.push('‚ö° M1: Spring (Wyckoff) detectado - Rompimento falso');
        fractalScoreAdjustment += 5;
      } else if (m1Pattern.includes('tri√¢ngulo') || m1Pattern.includes('triangle')) {
        fractalContext.push('‚ö° M1: Tri√¢ngulo detectado - Consolida√ß√£o local');
        fractalScoreAdjustment -= 3; // Consolida√ß√£o em M1 pode atrasar entrada
      } else if (m1Pattern.includes('range') || m1Pattern.includes('ret√¢ngulo')) {
        fractalContext.push('‚ö° M1: Range detectado - Mercado lateral local');
        fractalScoreAdjustment -= 2;
      }
    }

    // ‚úÖ FRACTAL: Aplicar ajustes de contexto fractal ao score final
    scoreAdjustment += fractalScoreAdjustment;
    if (fractalContext.length > 0) {
      reasoning += ' ' + fractalContext.join(' | ');
    }

    // 7. DETECTAR FASES WYCKOFF
    const phases = {
      accumulation: consolidatedDirection === 'bullish' && avgStrength < 40,
      markup: consolidatedDirection === 'bullish' && avgStrength > 60,
      distribution: consolidatedDirection === 'bearish' && avgStrength < 40,
      markdown: consolidatedDirection === 'bearish' && avgStrength > 60
    };

    // 8. RETORNAR ESTADO UNIFICADO
    return {
      // MTF Contextual (compatibilidade)
      globalBias,
      localEntry,
      alignment,
      recommendation,
      reasoning,
      scoreAdjustment,

      // ‚úÖ FRACTAL: Adicionar padr√µes detectados em m√∫ltiplos timeframes
      fractalPatterns, // { m1: 'Doji', m5: 'Tri√¢ngulo', m15: 'BOS', m30: 'Range', h1: 'Inside Bar', d1: 'Doji' }
      fractalContext, // Array de strings com contexto fractal

      // Trend State (compatibilidade)
      direction: consolidatedDirection,
      strength: consolidatedStrength,
      duration: temporalAwareness?.duration || 0,
      lastChange: temporalAwareness?.lastChange ? new Date(temporalAwareness.lastChange) : null,
      confidence: consolidatedConfidence,
      phases,

      // Dados adicionais
      processedTimeframes,
      availableTimeframes: processedTimeframes.filter(tf => tf.available).map(tf => tf.timeframe),
      fallbackTimeframes: processedTimeframes.filter(tf => tf._fallback).map(tf => tf.timeframe)
    };
  } catch (error) {
    logIntelligence('warn', 'Erro ao analisar MTF Unificado, usando fallback', { error: error?.message || error });
    // Fallback seguro
    return {
      globalBias: {
        timeframe: 'M30',
        direction: 'neutral' as const,
        strength: 0,
        confidence: 0,
        duration: 0
      },
      localEntry: {
        timeframe: 'M1',
        pattern: pattern?.type || 'unknown',
        direction: 'neutral' as const,
        score: analysis?.confidenceScore || 50,
        confidence: 0
      },
      alignment: 'neutral' as const,
      recommendation: 'WAIT' as const,
      reasoning: 'An√°lise MTF Unificada indispon√≠vel - usando contexto padr√£o',
      scoreAdjustment: 0,
      direction: 'neutral' as const,
      strength: 'weak' as const,
      duration: 0,
      lastChange: null,
      confidence: 0,
      phases: {
        accumulation: false,
        markup: false,
        distribution: false,
        markdown: false
      },
      processedTimeframes: [],
      availableTimeframes: [],
      fallbackTimeframes: []
    };
  }
}

/**
 * üÜï Analisa contexto MTF separando bias global (M30/M15) de entrada local (M1/M5)
 * LEGACY: Mantido para compatibilidade, agora usa analyzeMTFUnified internamente
 */
async function analyzeMTFContextual(multiTimeframeContext, pattern, analysis) {
  const unified = await analyzeMTFUnified(multiTimeframeContext, pattern, analysis);
  return {
    globalBias: unified.globalBias,
    localEntry: unified.localEntry,
    alignment: unified.alignment,
    recommendation: unified.recommendation,
    reasoning: unified.reasoning,
    scoreAdjustment: unified.scoreAdjustment
  };
}

/**
 * üÜï Calcula estado de tend√™ncia consolidado de todos os timeframes
 * LEGACY: Mantido para compatibilidade, agora usa analyzeMTFUnified internamente
 */
async function calculateTrendState(multiTimeframeContext, temporalAwareness) {
  const unified = await analyzeMTFUnified(multiTimeframeContext, {}, {}, temporalAwareness);
  return {
    direction: unified.direction,
    strength: unified.strength,
    duration: unified.duration,
    lastChange: unified.lastChange,
    confidence: unified.confidence,
    phases: unified.phases
  };
}
/**
 * üÜï Detecta meta-padr√µes (combina√ß√µes inteligentes de padr√µes)
 * SEGURO: N√£o modifica c√≥digo existente, apenas adiciona an√°lise
 */ function detectMetaPatterns(activePatterns, pattern, indicators, multiTimeframeContext) {
  try {
    // Definir meta-padr√µes conhecidos
    const metaPatterns = [
      {
        name: 'Institutional Setup',
        description: 'Order Block + FVG + Spring - Setup institucional completo',
        requiredPatterns: [
          'orderBlock',
          'fvg'
        ],
        optionalPatterns: [
          'spring',
          'liquiditySweep'
        ],
        score: 25,
        winRate: 0.88,
        conditions: {
          indicators: [
            'volume_spike'
          ]
        }
      },
      {
        name: 'Reversal Cluster',
        description: 'Hammer + Doji + RSI oversold + Support - Cluster de revers√£o',
        requiredPatterns: [
          'candle_hammer',
          'candle_doji'
        ],
        optionalPatterns: [
          'rsi_oversold',
          'support'
        ],
        score: 22,
        winRate: 0.85,
        conditions: {}
      },
      {
        name: 'Continuation Power',
        description: 'Bandeira + Tri√¢ngulo + Volume spike - Poder de continua√ß√£o',
        requiredPatterns: [
          'flag',
          'triangle'
        ],
        optionalPatterns: [
          'volume_spike'
        ],
        score: 20,
        winRate: 0.82,
        conditions: {}
      },
      {
        name: 'Wyckoff Complete',
        description: 'Spring + Accumulation + Breakout - Ciclo Wyckoff completo',
        requiredPatterns: [
          'wyckoff_spring'
        ],
        optionalPatterns: [
          'accumulation',
          'breakOfStructure'
        ],
        score: 28,
        winRate: 0.90,
        conditions: {}
      },
      {
        name: 'Smart Money Trap',
        description: 'Liquidity Sweep + Order Block + Reversal - Armadilha de smart money',
        requiredPatterns: [
          'liquiditySweep',
          'orderBlock'
        ],
        optionalPatterns: [
          'reversal'
        ],
        score: 24,
        winRate: 0.86,
        conditions: {}
      },
      {
        name: 'Geometric Convergence',
        description: 'Tri√¢ngulo + Cunha + Elliott - Converg√™ncia geom√©trica',
        requiredPatterns: [
          'triangle',
          'wedge'
        ],
        optionalPatterns: [
          'elliott_wave'
        ],
        score: 18,
        winRate: 0.80,
        conditions: {}
      }
    ];
    // Normalizar padr√µes ativos para compara√ß√£o
    const normalizedPatterns = activePatterns.map((p) => p.toLowerCase());
    // Verificar cada meta-padr√£o
    const detected = [];
    for (const metaPattern of metaPatterns) {
      // Verificar se todos os padr√µes requeridos est√£o presentes
      const hasRequired = metaPattern.requiredPatterns.every((req) => normalizedPatterns.some((active) => active.includes(req.toLowerCase()) || req.toLowerCase().includes(active)));
      if (hasRequired) {
        // Contar padr√µes opcionais tamb√©m presentes
        const optionalCount = metaPattern.optionalPatterns.filter((opt) => normalizedPatterns.some((active) => active.includes(opt.toLowerCase()) || opt.toLowerCase().includes(active))).length;
        // Calcular score (base + bonus por padr√µes opcionais)
        let score = metaPattern.score;
        if (optionalCount > 0) {
          score += optionalCount * 3; // +3 pontos por padr√£o opcional
        }
        // Verificar condi√ß√µes de indicadores
        if (metaPattern.conditions.indicators) {
          const hasRSIOversold = indicators?.rsi_14 < 30;
          const hasRSIOverbought = indicators?.rsi_14 > 70;
          const hasVolumeSpike = indicators?.volume_spike || indicators?.volume_z_score > 1.5;
          if (metaPattern.conditions.indicators.includes('rsi_oversold') && !hasRSIOversold) {
            score -= 5; // Penalidade se condi√ß√£o n√£o atendida
          }
          if (metaPattern.conditions.indicators.includes('volume_spike') && !hasVolumeSpike) {
            score -= 5;
          }
        }
        detected.push({
          metaPattern,
          matched: true,
          score: Math.max(0, score) // N√£o permitir score negativo
        });
      }
    }
    return detected;
  } catch (error) {
    logIntelligence('warn', 'Erro ao detectar meta-padr√µes, usando fallback', { error: error?.message || error });
    return []; // Fallback seguro - retorna vazio
  }
}
// üÜï Fun√ß√£o para formatar volume
function formatVolume(volume) {
  if (!volume || volume === 0) return '0.0M';
  if (volume >= 1000000000) {
    return `${(volume / 1000000000).toFixed(2)}B`;
  } else if (volume >= 1000000) {
    return `${(volume / 1000000).toFixed(1)}M`;
  } else if (volume >= 1000) {
    return `${(volume / 1000).toFixed(1)}K`;
  } else {
    return volume.toFixed(0);
  }
}
class LRUCache {
  cache;
  maxSize;
  ttl;
  constructor(maxSize = 100, ttl = 30000) {
    this.cache = new Map();
    this.maxSize = maxSize;
    this.ttl = ttl;
  }
  get(key) {
    const entry = this.cache.get(key);
    if (!entry) return null;
    if (Date.now() - entry.ts > this.ttl) {
      this.cache.delete(key);
      return null;
    }
    entry.accessCount++;
    this.cache.delete(key);
    this.cache.set(key, entry);
    return entry.data;
  }
  set(key, data) {
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, {
      data,
      ts: Date.now(),
      accessCount: 0
    });
  }
  clear() {
    this.cache.clear();
  }
  size() {
    return this.cache.size;
  }
}
// Caches separados para narrator
const narratorIndicatorCache = new LRUCache(50, 10000); // 10s para indicadores
const narratorKnowledgeCache = new LRUCache(100, 60000); // 60s para conhecimento
const narratorBinanceCache = new LRUCache(30, 5000); // 5s para dados Binance
const narratorOrderBookCache = new LRUCache(20, 8000); // 8s para order book (muda r√°pido mas n√£o precisa ser instant√¢neo)
// üõ°Ô∏è Cache persistente para anti-reentrada (sobrevive entre execu√ß√µes)
const signalEntryCache = new Map<string, { timestamp: number; lastCandleTime: number }>();
// ============================================================================
// üéØ SISTEMA DE LOGGING PROFISSIONAL - CORPORATIVO E LIMPO
// ============================================================================
const LOG_LEVEL = Deno.env.get('LOG_LEVEL') || 'info'; // debug, info, warn, error

// Cache para evitar logs duplicados (√∫ltimos 10 segundos)
const logCache = new Map<string, number>();
const LOG_DEDUP_WINDOW = 10000; // 10 segundos

// ‚úÖ HELPER: Serializar objetos de forma segura (evita [object Object])
// Aumentado maxDepth padr√£o para 5 (MTF tem objetos profundos)
function serializeValue(value: any, maxDepth = 5, currentDepth = 0): any {
  if (currentDepth >= maxDepth) {
    // Para objetos MTF profundos, retornar resumo ao inv√©s de erro
    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      const keys = Object.keys(value).slice(0, 5);
      return { _truncated: true, _depth: currentDepth, _sampleKeys: keys };
    }
    return '[Max Depth Reached]';
  }

  if (value === null || value === undefined) {
    return value;
  }

  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
    return value;
  }

  if (value instanceof Error) {
    return {
      name: value.name,
      message: value.message,
      stack: value.stack
    };
  }

  if (Array.isArray(value)) {
    // Limitar arrays grandes
    if (value.length > 10) {
      return {
        count: value.length,
        sample: value.slice(0, 5).map(item => serializeValue(item, maxDepth, currentDepth + 1)),
        _truncated: true
      };
    }
    return value.map(item => serializeValue(item, maxDepth, currentDepth + 1));
  }

  if (typeof value === 'object') {
    const serialized: any = {};
    const keys = Object.keys(value);
    // Limitar n√∫mero de propriedades
    const keysToProcess = keys.slice(0, 20);

    for (const key of keysToProcess) {
      try {
        serialized[key] = serializeValue(value[key], maxDepth, currentDepth + 1);
      } catch (e) {
        serialized[key] = '[Serialization Error]';
      }
    }

    if (keys.length > 20) {
      serialized._truncated = true;
      serialized._totalKeys = keys.length;
    }

    return serialized;
  }

  return String(value);
}

// ‚úÖ HELPER: Normalizar mensagem (garantir que nunca seja [object Object])
function normalizeMessage(message: any): string {
  if (typeof message === 'string') {
    return message;
  }

  if (message === null || message === undefined) {
    return '[No Message]';
  }

  if (typeof message === 'object') {
    try {
      return JSON.stringify(serializeValue(message, 2), null, 2);
    } catch (e) {
      return '[Object Serialization Failed]';
    }
  }

  return String(message);
}

// ‚úÖ FUN√á√ÉO PRINCIPAL DE LOG - PROFISSIONAL E LIMPA
function log(level: string, category: string, message: any, metadata: any = {}) {
  // Filtrar logs de debug em produ√ß√£o
  if (level === 'debug' && LOG_LEVEL !== 'debug') {
    return;
  }

  // ‚úÖ NORMALIZAR CATEGORIA: Garantir que seja sempre string v√°lida
  let normalizedCategory = typeof category === 'string' ? category : 'LOG';
  if (normalizedCategory.length > 20) {
    normalizedCategory = normalizedCategory.substring(0, 20);
  }

  // ‚úÖ NORMALIZAR MENSAGEM: Garantir que nunca seja [object Object]
  const normalizedMessage = normalizeMessage(message);

  // ‚úÖ SERIALIZAR METADATA: Garantir objetos sempre serializados
  const serializedMetadata = metadata && typeof metadata === 'object'
    ? serializeValue(metadata, 3)
    : metadata;

  // ‚úÖ DEDUPLICA√á√ÉO: Evitar logs id√™nticos em sequ√™ncia
  const logKey = `${normalizedCategory}:${normalizedMessage}:${JSON.stringify(serializedMetadata)}`;
  const now = Date.now();
  const lastLog = logCache.get(logKey);
  if (lastLog && (now - lastLog) < LOG_DEDUP_WINDOW) {
    return; // Log duplicado, ignorar
  }
  logCache.set(logKey, now);

  // Limpar cache antigo periodicamente
  if (logCache.size > 100) {
    for (const [key, timestamp] of logCache.entries()) {
      if (now - timestamp > LOG_DEDUP_WINDOW) {
        logCache.delete(key);
      }
    }
  }

  // ‚úÖ FORMATO PROFISSIONAL: [CATEGORIA] mensagem (sem emojis, limpo)
  const formattedMessage = `[${normalizedCategory}] ${normalizedMessage}`;
  const entry = {
    level,
    category: normalizedCategory,
    message: formattedMessage,
    data: serializedMetadata, // Renomeado de 'metadata' para 'data' (mais limpo)
    timestamp: new Date().toISOString(),
    functionName: 'intelligent-narrator'
  };

  // Log estruturado JSON (apenas console - SEM custo de banco)
  console.log(JSON.stringify(entry));
}

// ‚úÖ FUN√á√ïES HELPER POR CATEGORIA - FORMATO PROFISSIONAL
function logEngine(level: string, message: any, metadata: any = {}) {
  log(level, 'ENGINE', message, metadata);
}

function logData(level: string, message: any, metadata: any = {}) {
  log(level, 'DATA', message, metadata);
}

function logIntelligence(level: string, message: any, metadata: any = {}) {
  log(level, 'AI', message, metadata); // Renomeado de INTELLIGENCE para AI (mais curto)
}

function logCacheOp(level: string, message: any, metadata: any = {}) {
  log(level, 'CACHE', message, metadata);
}

function logError(level: string, message: any, metadata: any = {}) {
  log(level, 'ERROR', message, metadata);
}

function logTrade(level: string, message: any, metadata: any = {}) {
  log(level, 'TRADE', message, metadata);
}

// ‚úÖ HELPER: Log compacto de conflu√™ncias (evita repeti√ß√£o)
function logConfluences(level: string, stage: string, confluences: any[], additionalData: any = {}) {
  if (!Array.isArray(confluences) || confluences.length === 0) {
    logIntelligence(level, `${stage}: Nenhuma conflu√™ncia`, additionalData);
    return;
  }

  logIntelligence(level, `${stage}: ${confluences.length} conflu√™ncias`, {
    ...additionalData,
    count: confluences.length,
    sample: confluences.slice(0, 3), // Apenas primeiras 3
    _full: LOG_LEVEL === 'debug' ? confluences : undefined // Completo apenas em debug
  });
}

// ‚úÖ HELPER: Log de an√°lise de padr√£o (formato profissional)
function logPattern(level: string, pattern: any, metadata: any = {}) {
  const patternInfo = typeof pattern === 'object' && pattern !== null
    ? {
      type: pattern.type || pattern.patternType || 'Unknown',
      direction: pattern.direction || pattern.isBullishPattern ? 'BULLISH' : pattern.isBearishPattern ? 'BEARISH' : 'NEUTRAL',
      ...metadata
    }
    : { type: String(pattern), ...metadata };

  logIntelligence(level, 'Pattern detected', patternInfo);
}

// ‚úÖ HELPER: Log de an√°lise MTF (formato profissional)
function logMTF(level: string, mtfAnalysis: any, metadata: any = {}) {
  const mtfInfo = {
    recommendation: mtfAnalysis.recommendation,
    alignment: mtfAnalysis.alignment,
    scoreAdjustment: mtfAnalysis.scoreAdjustment,
    reasoning: mtfAnalysis.reasoning,
    ...metadata
  };

  logIntelligence(level, 'MTF analysis applied', mtfInfo);
}
// üõ°Ô∏è Limpar cache antigo de signal entry (evitar crescimento indefinido)
function cleanupSignalEntryCache() {
  if (signalEntryCache.size > 1000) {
    const now = Date.now();
    let cleaned = 0;
    for (const [key, value] of signalEntryCache.entries()) {
      if (now - value.timestamp > 3600000) { // 1 hora
        signalEntryCache.delete(key);
        cleaned++;
      }
    }
    if (cleaned > 0) {
      log('debug', 'Cache de signal entry limpo', { cleaned, remaining: signalEntryCache.size });
    }
  }
}
// ============================================================================
// üõ°Ô∏è VALIDATE SIGNAL ENTRY ‚Äî Valida√ß√£o completa antes de processar sinal
// ============================================================================
async function validateSignalEntry(
  symbol: string,
  timeframe: string,
  candlesForAnalysis: any[],
  indicators: any,
  historicalContext: any
) {
  // Prote√ß√£o contra par√¢metros inv√°lidos
  if (!symbol || !timeframe || !Array.isArray(candlesForAnalysis) || candlesForAnalysis.length < 20) {
    log('warn', 'Valida√ß√£o bloqueada - par√¢metros inv√°lidos', {
      hasSymbol: !!symbol,
      hasTimeframe: !!timeframe,
      isArray: Array.isArray(candlesForAnalysis),
      candlesLength: candlesForAnalysis?.length || 0
    });
    return { valid: false, reason: "Par√¢metros inv√°lidos para valida√ß√£o", confidenceAdjustment: -20 };
  }

  const normSymbol = String(symbol || '').replace('/', '');
  const tf = String(timeframe || '1m').toLowerCase();
  const cacheKey = `${normSymbol}_${tf}`;
  const now = Date.now();

  // ============================
  // 1. VALIDA√á√ÉO DE CANDLE
  // ============================
  const last = candlesForAnalysis[candlesForAnalysis.length - 1];
  if (!last || !last.time) {
    log('warn', 'Valida√ß√£o bloqueada - candle inv√°lido', {
      symbol: normSymbol,
      timeframe: tf,
      hasLast: !!last,
      hasTime: !!last?.time
    });
    return { valid: false, reason: "Candle inv√°lido", confidenceAdjustment: -20 };
  }

  const timeframeMs = ({
    "1m": 60000, "3m": 180000, "5m": 300000, "15m": 900000,
    "30m": 1800000, "1h": 3600000, "4h": 14400000
  }[tf]) || 60000;

  const candleAge = now - last.time;
  const candleClosed = candleAge >= timeframeMs;
  const candleProgress = candleAge / timeframeMs; // 0.0 a 1.0+

  // üéØ THRESHOLD ADAPTATIVO POR TRADING_MODE
  // PAPER: Permite entrada mais cedo (30%) para mais dados
  // LIVE: Mant√©m 60% para seguran√ßa
  const minCandleProgress = TRADING_MODE === 'PAPER' ? 0.30 : 0.60;

  // üîµ MODO FLEX: Permitir sinais se candle est√° pelo menos X% completo
  // üü† MODO STANDARD: Exigir candle fechado
  if (NARRATOR_MODE === "FLEX") {
    if (candleProgress < minCandleProgress) {
      // üéØ Em PAPER, ainda bloqueia se < 30%, mas √© menos restritivo
      log('debug', 'Candle muito novo - rejeitado', {
        progress: `${(candleProgress * 100).toFixed(0)}%`,
        required: `${(minCandleProgress * 100).toFixed(0)}%`,
        mode: TRADING_MODE,
        symbol: normSymbol,
        timeframe: tf
      });
      return { valid: false, reason: `Candle ainda n√£o fechou (${(candleProgress * 100).toFixed(0)}% completo)`, confidenceAdjustment: 0 };
    }
    // Se est√° entre threshold-100%, permitir mas com ajuste de confian√ßa
    if (candleProgress < 1.0) {
      // üéØ Ajuste adaptativo: PAPER √© mais tolerante
      let adjustment = 0;
      if (TRADING_MODE === 'PAPER') {
        // PAPER: penalidade menor para candles em forma√ß√£o
        adjustment = candleProgress < 0.40 ? -3 : candleProgress < 0.60 ? -2 : -1;
      } else {
        // LIVE: penalidade original
        adjustment = candleProgress < 0.75 ? -5 : candleProgress < 0.9 ? -3 : -2;
      }

      log('debug', 'Candle parcialmente fechado - aceito (FLEX)', {
        progress: `${(candleProgress * 100).toFixed(0)}%`,
        adjustment,
        mode: TRADING_MODE,
        symbol: normSymbol,
        timeframe: tf
      });
      return {
        valid: true,
        reason: `Candle parcialmente fechado (${(candleProgress * 100).toFixed(0)}% completo - modo ${TRADING_MODE})`,
        confidenceAdjustment: adjustment
      };
    }
  } else {
    // MODO STANDARD: Exigir candle completamente fechado
    if (!candleClosed) {
      return { valid: false, reason: "Candle ainda n√£o fechou", confidenceAdjustment: 0 };
    }
  }

  // ============================
  // 2. ANTI-REENTRADA POR CANDLE
  // ============================
  const cached = signalEntryCache.get(cacheKey);
  if (cached && cached.lastCandleTime === last.time) {
    const diff = now - cached.timestamp;
    if (diff < 8000) { // ‚úÖ AJUSTE: Reduzido de 12s para 8s - permite mais trades
      log('debug', 'Cooldown ativo - sinal bloqueado', {
        diffSeconds: (diff / 1000).toFixed(1),
        required: '12s',
        symbol: normSymbol,
        timeframe: tf
      });
      return {
        valid: false,
        reason: `Cooldown (mesmo candle - ${(diff / 1000).toFixed(0)}s/${12}s)`,
        confidenceAdjustment: -10
      };
    }
  }

  signalEntryCache.set(cacheKey, {
    timestamp: now,
    lastCandleTime: last.time
  });

  // ============================
  // 3. TESTES DE SAFETY REAL
  // ============================
  if (candlesForAnalysis.length < 20) {
    return { valid: false, reason: "Poucos candles", confidenceAdjustment: -20 };
  }

  const recent = candlesForAnalysis.slice(-20);
  const avgVolume = recent.reduce((s, c) => s + (Number(c.volume) || 0), 0) / recent.length;
  const volRatio = (Number(last.volume) || 0) / (avgVolume || 1);

  // ------------------------------
  // Volume m√≠nimo din√¢mico (flexibilizado)
  // ------------------------------
  const minVolRatio = tf === "1m" ? 0.3 : 0.6; // üéØ Reduzido: 1m de 0.45 para 0.3, outros de 0.8 para 0.6
  let adjustment = 0;
  let reason = "";

  if (volRatio < minVolRatio) {
    adjustment -= 10; // üéØ Penalidade reduzida de -15 para -10
    reason += `Volume baixo (${volRatio.toFixed(2)}x m√©dia, m√≠nimo: ${minVolRatio}x); `;
    log('debug', 'Volume abaixo do m√≠nimo - penalidade aplicada', {
      volRatio: volRatio.toFixed(2),
      minVolRatio,
      adjustment,
      symbol: normSymbol,
      timeframe: tf
    });
  }

  // ------------------------------
  // ATR simplificado / volatilidade
  // ------------------------------
  const highs = recent.map(c => Number(c.high) || 0).filter(h => h > 0);
  const lows = recent.map(c => Number(c.low) || 0).filter(l => l > 0);
  const closes = recent.map(c => Number(c.close) || 0).filter(c => c > 0);

  if (highs.length === 0 || lows.length === 0 || closes.length === 0) {
    log('warn', 'Valida√ß√£o bloqueada - dados de candle inv√°lidos', {
      symbol: normSymbol,
      timeframe: tf,
      highsCount: highs.length,
      lowsCount: lows.length,
      closesCount: closes.length
    });
    return { valid: false, reason: "Dados de candle inv√°lidos", confidenceAdjustment: -20 };
  }

  const range = Math.max(...highs) - Math.min(...lows);
  const avgPrice = closes.reduce((a, b) => a + b, 0) / closes.length;
  const volPct = avgPrice > 0 ? (range / avgPrice) * 100 : 0;
  const maxVolPct = tf === "1m" ? 4.0 : 2.0; // üéØ Aumentado: 1m de 3.0% para 4.0%, outros de 1.5% para 2.0%

  if (volPct > maxVolPct) {
    adjustment -= 15; // üéØ Penalidade reduzida de -20 para -15
    reason += `Volatilidade alta (${volPct.toFixed(2)}%, m√°ximo: ${maxVolPct}%); `;
    log('debug', 'Volatilidade acima do m√°ximo - penalidade aplicada', {
      volPct: volPct.toFixed(2),
      maxVolPct,
      adjustment,
      symbol: normSymbol,
      timeframe: tf
    });
  }

  // ------------------------------
  // Spike detection (wick anormal)
  // ------------------------------
  const lastClose = Number(last.close) || 0;
  const lastOpen = Number(last.open) || 0;
  const lastHigh = Number(last.high) || 0;
  const lastLow = Number(last.low) || 0;

  if (lastClose === 0 || lastOpen === 0 || lastHigh === 0 || lastLow === 0) {
    log('warn', 'Valida√ß√£o bloqueada - valores de candle zerados', {
      symbol: normSymbol,
      timeframe: tf,
      close: lastClose,
      open: lastOpen,
      high: lastHigh,
      low: lastLow
    });
    return { valid: false, reason: "Valores de candle inv√°lidos", confidenceAdjustment: -20 };
  }

  const body = Math.abs(lastClose - lastOpen);
  const upperWick = lastHigh - Math.max(lastClose, lastOpen);
  const lowerWick = Math.min(lastClose, lastOpen) - lastLow;

  if (upperWick > body * 2 || lowerWick > body * 2) {
    log('warn', 'Valida√ß√£o bloqueada - spike detectado', {
      symbol: normSymbol,
      timeframe: tf,
      upperWick,
      lowerWick,
      body,
      upperWickRatio: (upperWick / body).toFixed(2),
      lowerWickRatio: (lowerWick / body).toFixed(2)
    });
    return {
      valid: false,
      reason: "Spike detectado (wick anormal)",
      confidenceAdjustment: -40
    };
  }

  // ------------------------------
  // Candle anormalmente grande
  // ------------------------------
  const avgBody = recent
    .map(c => Math.abs((Number(c.close) || 0) - (Number(c.open) || 0)))
    .reduce((a, b) => a + b, 0) / recent.length;

  if (body > avgBody * 3) {
    log('warn', 'Valida√ß√£o bloqueada - candle at√≠pico', {
      symbol: normSymbol,
      timeframe: tf,
      body,
      avgBody: avgBody.toFixed(4),
      ratio: (body / avgBody).toFixed(2)
    });
    return {
      valid: false,
      reason: "Candle at√≠pico (3√ó maior)",
      confidenceAdjustment: -30
    };
  }

  // ------------------------------
  // Hist√≥rico: padr√£o fraco / over-signaled
  // ------------------------------
  if (
    historicalContext?.similarPatterns?.length > 5 &&
    historicalContext?.successRate < 0.6
  ) {
    adjustment -= 10;
    reason += "Padr√£o historicamente fraco; ";
  }

  // ================================================================
  // FINAL: resultado
  // ================================================================
  const result = {
    valid: true,
    reason: reason || "OK",
    confidenceAdjustment: Math.max(-50, adjustment),
    metrics: {
      volRatio: volRatio.toFixed(2),
      volPct: volPct.toFixed(2),
      candleAgeSeconds: (candleAge / 1000).toFixed(1)
    }
  };

  // üîç Log detalhado para debug (apenas se houver ajustes ou problemas)
  if (adjustment < 0 || reason) {
    log('debug', 'Valida√ß√£o de entrada - ajustes aplicados', {
      symbol: normSymbol,
      timeframe: tf,
      valid: result.valid,
      reason: result.reason,
      adjustment: result.confidenceAdjustment,
      metrics: result.metrics,
      candleProgress: `${(candleProgress * 100).toFixed(0)}%`
    });
  }

  return result;
}
// Fun√ß√£o para obter headers CORS din√¢micos
function getCorsHeaders(origin) {
  const allowedOrigins = [
    'http://localhost:3000',
    'http://localhost:3001',
    'http://127.0.0.1:3000',
    'http://127.0.0.1:3001',
    'https://tradevisionia.vercel.app'
  ];
  const isAllowed = allowedOrigins.includes(origin) || origin?.includes('localhost');

  // Se origin √© permitido, usar origin espec√≠fico com credentials
  // Se n√£o, usar '*' mas SEM credentials (CORS n√£o permite '*' com credentials)
  if (isAllowed && origin) {
    return {
      'Access-Control-Allow-Origin': origin,
      'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
      'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
      'Access-Control-Allow-Credentials': 'true'
    };
  } else {
    // Fallback: permitir qualquer origem mas SEM credentials
    return {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
      'Access-Control-Allow-Methods': 'POST, GET, OPTIONS'
      // N√£o incluir Access-Control-Allow-Credentials quando usar '*'
    };
  }
}
// ============================================================================
// üõ°Ô∏è CONTROLE DE RISCO PARA ALTA LEVERAGE (75x-100x+) - N√çVEL INSTITUCIONAL
// ============================================================================
/**
 * Calcula o risco m√°ximo permitido baseado na alavancagem
 * üõ°Ô∏è VERS√ÉO CONSERVADORA: Limita perda total a 2%, mesmo em 100x
 * Com trailing stop, perda real cai para 20-30% do m√°ximo te√≥rico
 */ function computeMaxRiskPctForLeverage(leverage) {
  if (leverage <= 25) return 0.03; // 3%
  if (leverage <= 50) return 0.02; // 2%
  if (leverage <= 75) return 0.012; // 1.2%
  if (leverage <= 100) return 0.005; // 0.5% SL m√≠nimo (com trailing = 20-30% perda real)
  return 0.005; // 0.5% para >100x (m√°ximo conservador)
}
/**
 * Calcula o notional permitido baseado em equity, stop loss e leverage
 * F√≥rmula: Notional = (RiskValue √ó Leverage) / StopPct
 */ function computeAllowedNotional(equity, stopPct, leverage, desiredRiskPct) {
  const maxRiskPct = computeMaxRiskPctForLeverage(leverage);
  const riskPct = desiredRiskPct ? Math.min(desiredRiskPct, maxRiskPct) : maxRiskPct;
  const riskValue = equity * riskPct;
  const notional = stopPct > 0 ? riskValue * leverage / stopPct : 0;
  return {
    notional: Number(notional.toFixed(2)),
    riskPct,
    maxRiskPct,
    riskValue: Number(riskValue.toFixed(2)),
    warning: riskPct >= maxRiskPct * 0.9 ? 'RISCO PR√ìXIMO DO LIMITE' : null,
    block: false // pode ativar se quiser bloqueio total
  };
}
/**
 * Detecta se √© um setup explosivo M1
 * Setup explosivo = M1 + volume alto + janela de a√ß√£o curta
 */ function isExplosiveSetup(timeframe, volumeZScore, actionWindowSec) {
  const isM1 = timeframe === '1' || timeframe === '1m' || timeframe === '1M' || timeframe?.toLowerCase() === '1m';
  return isM1 && volumeZScore > 1.2 && (!actionWindowSec || actionWindowSec <= 120);
}
/**
 * Valida√ß√£o completa de risco para alta leverage
 * MAIN FUNCTION - Integra tudo
 */ function validateHighLeverageRisk(params) {
  const { equity = 1000, leverage, stopPct, volumeZScore, timeframe, signalType, userAcknowledged = false, actionWindowSec } = params;
  const isExplosive = isExplosiveSetup(timeframe, volumeZScore, actionWindowSec);
  const maxRiskPct = computeMaxRiskPctForLeverage(leverage);
  const allowed = computeAllowedNotional(equity, stopPct, leverage);
  let warning = '';
  const warnings = [];
  if (leverage >= 75 && !userAcknowledged) {
    warnings.push('‚ö†Ô∏è CONFIRMA√á√ÉO DE RISCO OBRIGAT√ìRIA PARA ‚â•75x');
  }
  if (isExplosive && volumeZScore < 0.8) {
    warnings.push('VOLUME BAIXO PARA SETUP EXPLOSIVO');
  }
  if (allowed.warning) {
    warnings.push(allowed.warning);
  }
  warning = warnings.length > 0 ? warnings.join(' | ') : '';
  return {
    ...allowed,
    isExplosive,
    requiresAck: leverage >= 75,
    riskNote: warning || 'Risco controlado conforme alavancagem',
    audit: {
      leverage,
      equity_used: equity,
      stop_pct: stopPct,
      volume_z_score: volumeZScore,
      explosive_flag: isExplosive,
      timestamp: new Date().toISOString()
    }
  };
}
// üÜï FUN√á√ÉO DE FILTROS RIGOROSOS PARA ALTA LEVERAGE (75x+) - PRECIS√ÉO M√ÅXIMA
function analyzeHighLeverageFilters(technicalIndicators, marketData, pattern, multiTimeframeContext, orderBookAnalysis, candles = []) {
  const result = {
    shouldReject: false,
    penalty: 0,
    boost: 0,
    warnings: [],
    confirmations: [],
    rejectionReason: ''
  };

  // 1. FILTRO DE VOLATILIDADE (ATR) - Para 75x+, volatilidade deve ser controlada
  // üéØ FILTRO COM ATR MULTI-TIMEFRAME (M1, M5, M15, M30)
  const atr = technicalIndicators?.atr || 0;
  const currentPrice = parseFloat(String(marketData?.price || 0));
  const atrPct = currentPrice > 0 ? (atr / currentPrice) * 100 : 0;

  // ‚úÖ NOVO: Bloquear volatilidade extrema (>2.10%) - mais rigoroso que antes (2.0%)
  if (atrPct > 2.10) {
    // Volatilidade muito alta (>2.10%) = risco alto para 75x+
    result.shouldReject = true;
    result.penalty += 30;
    result.warnings.push(`üö® Volatilidade extrema (ATR Multi-TF ${atrPct.toFixed(2)}%) - RISCO ALTO para 75x+`);
    result.rejectionReason = 'Volatilidade excessiva';
  } else if (atrPct > 1.5) {
    result.penalty += 12; // ‚úÖ CALIBRA√á√ÉO: Reduzido de 15 para 12 (-20%)
    result.warnings.push(`‚ö†Ô∏è Volatilidade moderada-alta (ATR Multi-TF ${atrPct.toFixed(2)}%) - Cautela para 75x+`);
  } else if (atrPct < 0.32) {
    // ‚úÖ NOVO: Threshold m√≠nimo 0.32% (mais rigoroso que antes 0.3%)
    result.shouldReject = true;
    result.penalty += 20;
    result.warnings.push(`üö® Volatilidade muito baixa (ATR Multi-TF ${atrPct.toFixed(2)}%) - Consolida√ß√£o detectada`);
    result.rejectionReason = 'Consolida√ß√£o - ATR muito baixo';
  } else if (atrPct >= 0.32 && atrPct < 0.5) {
    result.boost += 6; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 5 para 6 (+20%)
    result.confirmations.push(`‚úÖ Volatilidade controlada (ATR Multi-TF ${atrPct.toFixed(2)}%) - Ideal para 75x+`);
  }

  // 2. DETEC√á√ÉO DE FALSE BREAKOUTS - Cr√≠tico para 75x+
  if (candles.length >= 10) {
    const recent = candles.slice(-10);
    const highs = recent.map(c => c.high);
    const lows = recent.map(c => c.low);
    const closes = recent.map(c => c.close);

    const maxHigh = Math.max(...highs);
    const minLow = Math.min(...lows);
    const currentClose = closes[closes.length - 1];

    // Verificar se houve rompimento seguido de rejei√ß√£o
    const breakoutHigh = recent.some((c, i) => {
      if (i === 0) return false;
      return c.high > maxHigh * 0.99 && closes[i] < closes[i - 1];
    });

    const breakoutLow = recent.some((c, i) => {
      if (i === 0) return false;
      return c.low < minLow * 1.01 && closes[i] > closes[i - 1];
    });

    if (breakoutHigh || breakoutLow) {
      result.shouldReject = true;
      result.penalty += 25;
      result.warnings.push(`üö® FALSE BREAKOUT detectado - RISCO ALTO para 75x+`);
      result.rejectionReason = 'False breakout detectado';
    }
  }

  // 3. AN√ÅLISE DE WICK REJECTION - Detectar rejei√ß√µes de pre√ßo (importante para stops apertados)
  if (candles.length >= 5) {
    const recent = candles.slice(-5);
    let strongRejections = 0;

    recent.forEach(candle => {
      const body = Math.abs(candle.close - candle.open);
      const range = candle.high - candle.low;
      const upperWick = candle.high - Math.max(candle.open, candle.close);
      const lowerWick = Math.min(candle.open, candle.close) - candle.low;

      // Rejei√ß√£o forte: wick > 2x body
      if (upperWick > body * 2 || lowerWick > body * 2) {
        strongRejections++;
      }
    });

    if (strongRejections >= 2) {
      result.boost += 10; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 8 para 10 (+25%)
      result.confirmations.push(`‚úÖ ${strongRejections} rejei√ß√µes fortes detectadas - Confirma√ß√£o de n√≠vel`);
    } else if (strongRejections === 0) {
      result.penalty += 8; // ‚úÖ CALIBRA√á√ÉO: Reduzido de 10 para 8 (-20%)
      result.warnings.push(`‚ö†Ô∏è Sem rejei√ß√µes claras - Menos confian√ßa para 75x+`);
    }
  }

  // 4. CONFIRMA√á√ÉO DE MOMENTUM - Para 75x+, momentum deve ser forte e claro
  const rsi = technicalIndicators?.rsi_14 || 50;
  const macd = technicalIndicators?.macd || 0;
  const macdSignal = technicalIndicators?.macd_signal || 0;
  const ema9 = technicalIndicators?.ema_9 || 0;
  const ema50 = technicalIndicators?.ema_50 || 0;

  const momentumStrength = Math.abs(macd - macdSignal);
  const avgMomentum = (Math.abs(macd) + Math.abs(macdSignal)) / 2;
  const momentumRatio = avgMomentum > 0 ? momentumStrength / avgMomentum : 0;

  if (momentumRatio < 0.3) {
    result.penalty += 12; // ‚úÖ CALIBRA√á√ÉO: Reduzido de 15 para 12 (-20%)
    result.warnings.push(`‚ö†Ô∏è Momentum fraco (${(momentumRatio * 100).toFixed(1)}%) - Risco para 75x+`);
  } else if (momentumRatio > 0.7) {
    result.boost += 12; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 10 para 12 (+20%)
    result.confirmations.push(`‚úÖ Momentum forte (${(momentumRatio * 100).toFixed(1)}%) - Ideal para 75x+`);
  }

  // Verificar alinhamento de EMAs (deve ser claro para 75x+)
  const emaAlignment = ema9 > ema50 ? 'BULLISH' : ema9 < ema50 ? 'BEARISH' : 'NEUTRAL';
  const emaDistance = Math.abs(ema9 - ema50) / Math.min(ema9, ema50) * 100;

  if (emaAlignment === 'NEUTRAL' || emaDistance < 0.1) {
    result.penalty += 10; // ‚úÖ CALIBRA√á√ÉO: Reduzido de 12 para 10 (-17%)
    result.warnings.push(`‚ö†Ô∏è EMAs n√£o alinhadas claramente - Risco para 75x+`);
  } else if (emaDistance > 0.5) {
    result.boost += 10; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 8 para 10 (+25%)
    result.confirmations.push(`‚úÖ EMAs bem alinhadas (${emaDistance.toFixed(2)}% dist√¢ncia) - Confirma√ß√£o forte`);
  }

  // 5. ALINHAMENTO MULTI-TIMEFRAME RIGOROSO - Para 75x+, TODOS devem estar alinhados
  const mtfAligned = multiTimeframeContext?.confirmation === 'aligned';
  const mtfDivergent = multiTimeframeContext?.confirmation === 'divergent';

  if (mtfDivergent) {
    result.shouldReject = true;
    result.penalty += 35;
    result.warnings.push(`üö® DIVERG√äNCIA MULTI-TIMEFRAME - REJEITAR para 75x+`);
    result.rejectionReason = 'Diverg√™ncia multi-timeframe';
  } else if (!mtfAligned) {
    result.penalty += 16; // ‚úÖ CALIBRA√á√ÉO: Reduzido de 20 para 16 (-20%)
    result.warnings.push(`‚ö†Ô∏è Alinhamento multi-timeframe parcial - Cautela para 75x+`);
  } else {
    result.boost += 15; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 12 para 15 (+25%)
    result.confirmations.push(`‚úÖ Alinhamento multi-timeframe completo - Ideal para 75x+`);
  }

  // 6. CONFIRMA√á√ÉO DE VOLUME - Volume deve confirmar movimento para 75x+
  const volumeZScore = technicalIndicators?.volume_z_score || 0;

  if (volumeZScore < 0.5) {
    result.penalty += 12; // ‚úÖ CALIBRA√á√ÉO: Reduzido de 15 para 12 (-20%)
    result.warnings.push(`‚ö†Ô∏è Volume abaixo da m√©dia (z-score ${volumeZScore.toFixed(2)}) - Risco para 75x+`);
  } else if (volumeZScore > 1.5) {
    result.boost += 12; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 10 para 12 (+20%)
    result.confirmations.push(`‚úÖ Volume alto (z-score ${volumeZScore.toFixed(2)}) - Confirma√ß√£o forte`);
  }

  // 7. AN√ÅLISE DE ORDER BOOK (se dispon√≠vel) - Para 75x+, order book deve confirmar
  if (orderBookAnalysis) {
    const { imbalance, largeOrders, signal } = orderBookAnalysis;

    // Verificar se order book confirma o sinal
    const patternDirection = pattern?.type?.toLowerCase() || '';
    const isBullishPattern = patternDirection.includes('bullish') || patternDirection.includes('alta') || patternDirection.includes('ascendente');
    const isBearishPattern = patternDirection.includes('bearish') || patternDirection.includes('baixa') || patternDirection.includes('descendente');

    if (isBullishPattern && imbalance < -0.2) {
      result.penalty += 15;
      result.warnings.push(`‚ö†Ô∏è Order Book contradiz padr√£o bullish - Caracter√≠sticas t√©cnicas de press√£o vendedora`);
    } else if (isBearishPattern && imbalance > 0.2) {
      result.penalty += 15;
      result.warnings.push(`‚ö†Ô∏è Order Book contradiz padr√£o bearish - Caracter√≠sticas t√©cnicas de press√£o compradora`);
    } else if (Math.abs(imbalance) > 0.3) {
      result.boost += 8;
      result.confirmations.push(`‚úÖ Order Book confirma padr√£o (imbalance ${(imbalance * 100).toFixed(1)}%)`);
    }

    // Grandes ordens devem estar alinhadas
    if (largeOrders.totalVolume > 0) {
      const largeBidsCount = largeOrders.bids.length;
      const largeAsksCount = largeOrders.asks.length;

      if (isBullishPattern && largeAsksCount > largeBidsCount * 1.5) {
        result.penalty += 12;
        result.warnings.push(`‚ö†Ô∏è Grandes ordens de venda superam compra - Contradi√ß√£o`);
      } else if (isBearishPattern && largeBidsCount > largeAsksCount * 1.5) {
        result.penalty += 12;
        result.warnings.push(`‚ö†Ô∏è Grandes ordens de compra superam venda - Contradi√ß√£o`);
      } else if ((isBullishPattern && largeBidsCount > largeAsksCount) || (isBearishPattern && largeAsksCount > largeBidsCount)) {
        result.boost += 6;
        result.confirmations.push(`‚úÖ Grandes ordens alinhadas com padr√£o`);
      }
    }
  }

  // 8. DETEC√á√ÉO DE LIQUIDITY SWEEP MELHORADA - Para 75x+, detectar quando grandes players varrem stops
  if (candles.length >= 8) {
    const recent = candles.slice(-8);
    const highs = recent.map(c => c.high);
    const lows = recent.map(c => c.low);
    const closes = recent.map(c => c.close);

    const maxHigh = Math.max(...highs.slice(0, -2));
    const minLow = Math.min(...lows.slice(0, -2));

    const last2Highs = highs.slice(-2);
    const last2Lows = lows.slice(-2);
    const last2Closes = closes.slice(-2);

    // Sweep de alta seguido de revers√£o (bearish)
    const sweepHigh = last2Highs.some(h => h > maxHigh * 1.002) &&
      last2Closes[last2Closes.length - 1] < last2Closes[last2Closes.length - 2];

    // Sweep de baixa seguido de revers√£o (bullish)
    const sweepLow = last2Lows.some(l => l < minLow * 0.998) &&
      last2Closes[last2Closes.length - 1] > last2Closes[last2Closes.length - 2];

    if (sweepHigh || sweepLow) {
      result.boost += 12;
      result.confirmations.push(`‚úÖ Liquidity Sweep detectado - Grandes players varrendo stops`);
    }
  }

  // 9. FILTRO DE RSI EXTREMO - Para 75x+, RSI deve estar em zona extrema OU neutro confirmado
  if (rsi < 30 || rsi > 70) {
    // RSI extremo = OK para 75x+ (revers√£o potencial)
    result.boost += 5;
    result.confirmations.push(`‚úÖ RSI em zona extrema (${rsi.toFixed(1)}) - Potencial revers√£o`);
  } else if (rsi > 45 && rsi < 55) {
    // RSI muito neutro = menos confian√ßa para 75x+
    result.penalty += 8;
    result.warnings.push(`‚ö†Ô∏è RSI muito neutro (${rsi.toFixed(1)}) - Menos confian√ßa para 75x+`);
  }

  // 10. SCORE M√çNIMO PARA 75x+ - Se ap√≥s todos os filtros, score ainda < 45, rejeitar
  // (Este ser√° aplicado depois, mas documentamos aqui)

  return result;
}
// üÜï FUN√á√ÉO PARA DETECTAR REGIME DE MERCADO (TRENDING, RANGING, VOLATILE, CONSOLIDATION)
function detectMarketRegime(candles, technicalIndicators) {
  if (!candles || candles.length < 50) return null;
  try {
    const recent = candles.slice(-50);
    const prices = recent.map(c => c.close);
    const highs = recent.map(c => c.high);
    const lows = recent.map(c => c.low);
    const atr = technicalIndicators?.atr || 0;
    const currentPrice = prices[prices.length - 1];
    const atrPct = currentPrice > 0 ? (atr / currentPrice) * 100 : 0;
    const maxHigh = Math.max(...highs);
    const minLow = Math.min(...lows);
    const priceRange = maxHigh - minLow;
    const rangePct = currentPrice > 0 ? (priceRange / currentPrice) * 100 : 0;
    const ema9 = technicalIndicators?.ema_9 || 0;
    const ema50 = technicalIndicators?.ema_50 || 0;
    const ema200 = technicalIndicators?.ema_200 || 0;
    const emaAlignment = ema9 > ema50 && ema50 > ema200 ? 'BULLISH' : ema9 < ema50 && ema50 < ema200 ? 'BEARISH' : 'NEUTRAL';
    const priceChange = ((prices[prices.length - 1] - prices[0]) / prices[0]) * 100;
    let upMoves = 0, downMoves = 0;
    for (let i = 1; i < prices.length; i++) {
      if (prices[i] > prices[i - 1]) upMoves++;
      else if (prices[i] < prices[i - 1]) downMoves++;
    }
    const directionConsistency = Math.abs(upMoves - downMoves) / prices.length;
    let regime = 'CONSOLIDATION', confidence = 0.5, scoreAdjustment = 0, recommendation = '';
    if (directionConsistency > 0.4 && emaAlignment !== 'NEUTRAL' && rangePct > 2 && rangePct < 10) {
      regime = 'TRENDING';
      confidence = Math.min(0.95, 0.6 + directionConsistency * 0.35);
      scoreAdjustment = emaAlignment === 'BULLISH' ? 12 : -12;
      recommendation = `Mercado em tend√™ncia ${emaAlignment === 'BULLISH' ? 'de alta' : 'de baixa'} - Estrat√©gia de seguimento ideal`;
    } else if (Math.abs(priceChange) < 1 && rangePct < 3 && emaAlignment === 'NEUTRAL') {
      regime = 'RANGING';
      confidence = 0.7;
      scoreAdjustment = -8;
      recommendation = 'Mercado lateralizado - Estrat√©gia de range trading ou aguardar rompimento';
    } else if (atrPct > 2.5 || rangePct > 15) {
      regime = 'VOLATILE';
      confidence = 0.75;
      scoreAdjustment = -15;
      recommendation = 'Mercado vol√°til - Reduzir posi√ß√£o e usar stops mais largos';
    } else {
      regime = 'CONSOLIDATION';
      confidence = 0.6;
      scoreAdjustment = -5;
      recommendation = 'Mercado em consolida√ß√£o - Aguardar defini√ß√£o de dire√ß√£o';
    }
    return { regime, confidence, scoreAdjustment, recommendation, metrics: { atrPct: atrPct.toFixed(2), rangePct: rangePct.toFixed(2), priceChange: priceChange.toFixed(2), directionConsistency: (directionConsistency * 100).toFixed(0), emaAlignment } };
  } catch (error) {
    log('warn', 'Erro ao detectar regime de mercado', { error: error.message });
    return null;
  }
}
// üÜï FUN√á√ÉO PARA ANALISAR CORRELA√á√ÉO COM BTC
async function analyzeAssetCorrelation(symbol, timeframe, candles = []) {
  if (symbol.includes('BTC')) return null;
  try {
    const btcSymbol = 'BTCUSDT';
    const btcUrl = `https://api.binance.com/api/v3/klines?symbol=${btcSymbol}&interval=${timeframe}&limit=50`;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 5000);
    let btcResp;
    try {
      btcResp = await fetch(btcUrl, { signal: controller.signal });
      clearTimeout(timeoutId);
    } catch (fetchError) {
      clearTimeout(timeoutId);
      return null;
    }
    if (!btcResp.ok) return null;
    const btcKlines = await btcResp.json();
    if (!Array.isArray(btcKlines) || btcKlines.length < 20) return null;
    if (!candles || candles.length < 20) return null;
    const minLength = Math.min(btcKlines.length, candles.length);
    const btcReturns = [];
    const assetReturns = [];
    for (let i = 1; i < minLength; i++) {
      const btcPrev = parseFloat(btcKlines[i - 1][4]);
      const btcCurr = parseFloat(btcKlines[i][4]);
      const assetPrev = candles[candles.length - minLength + i - 1]?.close || 0;
      const assetCurr = candles[candles.length - minLength + i]?.close || 0;
      if (btcPrev > 0 && assetPrev > 0) {
        btcReturns.push((btcCurr - btcPrev) / btcPrev);
        assetReturns.push((assetCurr - assetPrev) / assetPrev);
      }
    }
    if (btcReturns.length < 10) return null;
    const btcMean = btcReturns.reduce((a, b) => a + b, 0) / btcReturns.length;
    const assetMean = assetReturns.reduce((a, b) => a + b, 0) / assetReturns.length;
    let numerator = 0, btcVariance = 0, assetVariance = 0;
    for (let i = 0; i < btcReturns.length; i++) {
      const btcDiff = btcReturns[i] - btcMean;
      const assetDiff = assetReturns[i] - assetMean;
      numerator += btcDiff * assetDiff;
      btcVariance += btcDiff * btcDiff;
      assetVariance += assetDiff * assetDiff;
    }
    const denominator = Math.sqrt(btcVariance * assetVariance);
    const correlation = denominator > 0 ? numerator / denominator : 0;
    const recentBtcReturns = btcReturns.slice(-5);
    const recentAssetReturns = assetReturns.slice(-5);
    const btcAvgReturn = recentBtcReturns.reduce((a, b) => a + b, 0) / recentBtcReturns.length;
    const assetAvgReturn = recentAssetReturns.reduce((a, b) => a + b, 0) / recentAssetReturns.length;
    const btcLeads = Math.abs(btcAvgReturn) > Math.abs(assetAvgReturn) * 1.2 && correlation > 0.5;
    let signal = 'NEUTRAL', scoreBoost = 0;
    if (correlation > 0.7) {
      signal = 'ALIGNED';
      scoreBoost = 10;
    } else if (correlation < -0.3) {
      signal = 'DIVERGENT';
      scoreBoost = -8;
    } else if (correlation > 0.5) {
      signal = 'ALIGNED';
      scoreBoost = 5;
    }
    return { correlation, btcLeads, signal, scoreBoost, btcAvgReturn: (btcAvgReturn * 100).toFixed(2), assetAvgReturn: (assetAvgReturn * 100).toFixed(2) };
  } catch (error) {
    log('warn', 'Erro ao analisar correla√ß√£o com BTC', { error: error.message });
    return null;
  }
}
// üÜï FUN√á√ÉO PARA DETECTAR CICLOS DE MERCADO (Wyckoff)
function detectMarketCycle(candles, volumes, orderBookAnalysis) {
  if (!candles || candles.length < 30) return null;
  try {
    const recent = candles.slice(-30);
    const firstHalf = recent.slice(0, 15);
    const secondHalf = recent.slice(15);
    const firstHalfAvgVolume = firstHalf.reduce((sum, c) => sum + c.volume, 0) / firstHalf.length;
    const secondHalfAvgVolume = secondHalf.reduce((sum, c) => sum + c.volume, 0) / secondHalf.length;
    const firstHalfAvgPrice = firstHalf.reduce((sum, c) => sum + c.close, 0) / firstHalf.length;
    const secondHalfAvgPrice = secondHalf.reduce((sum, c) => sum + c.close, 0) / secondHalf.length;
    const priceChange = ((secondHalfAvgPrice - firstHalfAvgPrice) / firstHalfAvgPrice) * 100;
    const volumeChange = ((secondHalfAvgVolume - firstHalfAvgVolume) / firstHalfAvgVolume) * 100;
    const orderBookImbalance = orderBookAnalysis?.imbalance || 0;
    let phase = 'CONSOLIDATION', confidence = 0.5, scoreBoost = 0, entrySignal = 'WAIT';
    if (Math.abs(priceChange) < 2 && volumeChange > 20 && orderBookImbalance > 0.2) {
      phase = 'ACCUMULATION';
      confidence = 0.7;
      scoreBoost = 15;
      entrySignal = 'BUY';
    } else if (priceChange > 3 && volumeChange > 10 && orderBookImbalance > 0.1) {
      phase = 'MARKUP';
      confidence = 0.75;
      scoreBoost = 12;
      entrySignal = 'BUY';
    } else if (Math.abs(priceChange) < 2 && volumeChange > 20 && orderBookImbalance < -0.2) {
      phase = 'DISTRIBUTION';
      confidence = 0.7;
      scoreBoost = 15;
      entrySignal = 'SELL';
    } else if (priceChange < -3 && volumeChange > 10 && orderBookImbalance < -0.1) {
      phase = 'MARKDOWN';
      confidence = 0.75;
      scoreBoost = 12;
      entrySignal = 'SELL';
    }
    return { phase, confidence, scoreBoost, entrySignal, metrics: { priceChange: priceChange.toFixed(2), volumeChange: volumeChange.toFixed(2), orderBookImbalance: (orderBookImbalance * 100).toFixed(1) } };
  } catch (error) {
    log('warn', 'Erro ao detectar ciclo de mercado', { error: error.message });
    return null;
  }
}
// ============================================================================
// üöÄ NOVAS FUNCIONALIDADES AVAN√áADAS - MELHORIAS INSTITUCIONAIS
// ============================================================================

/**
 * üéØ APLICAR MODO NARRADOR (FLEX/STANDARD) - Ajuste de rigor baseado em contexto
 * Aplica penalidades/recompensas baseadas no modo selecionado e alavancagem
 */
function applyNarratorMode(score, context) {
  const {
    mtfAlignment,
    killSwitch,
    volatilityPct,
    volumeZ,
    trendGlobal,
    trendLocal,
    leverage = 1
  } = context;

  // ‚úÖ NOVO: Armazenar score inicial para limitar impacto total
  const scoreBeforeMode = score;
  let finalScore = score;
  let notes: string[] = [];
  let totalModePenalty = 0;

  // --------------------------------
  // üîµ MODO FLEX (mais permissivo)
  // --------------------------------
  if (NARRATOR_MODE === "FLEX") {
    // MTF divergente ‚Üí s√≥ penaliza um pouco
    if (mtfAlignment === "divergent") {
      const penalty = 8;
      totalModePenalty += penalty;
      finalScore -= penalty;
      notes.push("‚ö†Ô∏è MTF divergente ‚Äî penalidade leve (modo FLEX)");
    }

    // Volatilidade m√©dia ‚Üí penalidade leve
    if (volatilityPct > 2.0) {
      const penalty = 5;
      totalModePenalty += penalty;
      finalScore -= penalty;
      notes.push("‚ö†Ô∏è Volatilidade elevada ‚Äî penalidade leve (modo FLEX)");
    }

    // Volume ruim ‚Üí penalidade leve
    if (volumeZ < -0.8) {
      const penalty = 4;
      totalModePenalty += penalty;
      finalScore -= penalty;
      notes.push("‚ö†Ô∏è Volume fraco ‚Äî penalidade leve (modo FLEX)");
    }

    // Kill Switch ativo ‚Üí n√£o bloqueia
    if (killSwitch) {
      const penalty = 12;
      totalModePenalty += penalty;
      finalScore -= penalty;
      notes.push("‚ö†Ô∏è Kill Switch ativo ‚Äî cautela (modo FLEX)");
    }
  }

  // --------------------------------
  // üü† MODO STANDARD (balanceado)
  // --------------------------------
  if (NARRATOR_MODE === "STANDARD") {
    // MTF divergente ‚Üí penalidade moderada
    if (mtfAlignment === "divergent") {
      finalScore -= 15;
      notes.push("‚ö†Ô∏è Diverg√™ncia MTF ‚Äî penalidade moderada");
    }

    // Kill Switch ativo ‚Üí penalidade forte
    if (killSwitch) {
      finalScore -= 20;
      notes.push("üö® Kill Switch ativo ‚Äî risco elevado");
    }

    // Volatilidade alta
    if (volatilityPct > 2.0) {
      finalScore -= 12;
      notes.push("‚ö†Ô∏è Volatilidade alta ‚Äî perda de precis√£o");
    }

    // Volume muito ruim
    if (volumeZ < -1.0) {
      finalScore -= 8;
      notes.push("‚ö†Ô∏è Volume fraco ‚Äî padr√£o menos confi√°vel");
    }

    // Tend√™ncia global neutra e local oposta
    if (trendGlobal === "neutral" && trendLocal !== "neutral") {
      finalScore -= 10;
      notes.push("‚ö†Ô∏è Entrada contra tend√™ncia macro");
    }
  }

  // ---------------------------------------------
  // üü• FILTROS EXCLUSIVOS PARA ALAVANCAGEM ‚â•75x
  // ‚úÖ AJUSTE: Reduzir penalidades se score j√° est√° muito baixo (< 20)
  // ---------------------------------------------
  if (leverage >= 75) {
    // ‚úÖ NOVO: Reduzir penalidades se score j√° est√° muito baixo (n√£o destruir completamente)
    const isScoreVeryLow = scoreBeforeMode < 20;
    const leveragePenaltyMultiplier = isScoreVeryLow ? 0.5 : 1.0; // Reduzir pela metade se score < 20

    // MTF divergente em alavancagem alta = risco extremo
    if (mtfAlignment === "divergent") {
      let penalty = NARRATOR_MODE === "FLEX" ? 15 : 28;
      penalty = Math.round(penalty * leveragePenaltyMultiplier);
      totalModePenalty += penalty;
      finalScore -= penalty;
      notes.push(`üö® Diverg√™ncia MTF cr√≠tica para 75x+${isScoreVeryLow ? ' (penalidade reduzida - score baixo)' : ''}`);
    }

    // Kill Switch com alavancagem alta precisa pesar mais
    if (killSwitch) {
      let penalty = NARRATOR_MODE === "FLEX" ? 18 : 35;
      penalty = Math.round(penalty * leveragePenaltyMultiplier);
      totalModePenalty += penalty;
      finalScore -= penalty;
      notes.push(`üö® Kill Switch ativo ‚Äî risco extremo em 75x+${isScoreVeryLow ? ' (penalidade reduzida - score baixo)' : ''}`);
    }

    // Volatilidade alta √© mortal para 75x+
    if (volatilityPct > 1.8) {
      let penalty = NARRATOR_MODE === "FLEX" ? 10 : 25;
      penalty = Math.round(penalty * leveragePenaltyMultiplier);
      totalModePenalty += penalty;
      finalScore -= penalty;
      notes.push(`‚ö†Ô∏è Volatilidade ${volatilityPct.toFixed(2)}% ‚Äî perigosa para 75x+${isScoreVeryLow ? ' (penalidade reduzida - score baixo)' : ''}`);
    }

    // Volume fraco = manipula√ß√£o / fake moves
    if (volumeZ < -1.0) {
      let penalty = NARRATOR_MODE === "FLEX" ? 8 : 18;
      penalty = Math.round(penalty * leveragePenaltyMultiplier);
      totalModePenalty += penalty;
      finalScore -= penalty;
      notes.push(`‚ö†Ô∏è Volume baixo ‚Äî falso movimento prov√°vel${isScoreVeryLow ? ' (penalidade reduzida - score baixo)' : ''}`);
    }

    // Entrada contra tend√™ncia maior nunca √© boa em 75x+
    if (trendGlobal !== "neutral" && trendLocal !== trendGlobal) {
      let penalty = NARRATOR_MODE === "FLEX" ? 10 : 22;
      penalty = Math.round(penalty * leveragePenaltyMultiplier);
      totalModePenalty += penalty;
      finalScore -= penalty;
      notes.push(`‚ö†Ô∏è Entrada contra a tend√™ncia macro em 75x+${isScoreVeryLow ? ' (penalidade reduzida - score baixo)' : ''}`);
    }

    // Se tudo estiver alinhado ‚Üí recompensa (sempre aplicar, independente do score)
    if (
      mtfAlignment === "aligned" &&
      killSwitch === false &&
      volatilityPct < 1.0 &&
      volumeZ > 0.8
    ) {
      finalScore += 20;
      notes.push("‚úÖ Setup ideal para 75x+ ‚Äî alinhamento e volatilidade controlada");
    }
  }

  // ‚úÖ NOVO: LIMITAR IMPACTO TOTAL DO MODO NARRADOR
  // N√£o permitir que penalidades do modo reduzam mais de 30% do score inicial
  const maxModePenalty = Math.max(10, scoreBeforeMode * 0.3); // M√°ximo 30% do score inicial ou 10 pontos m√≠nimo
  if (totalModePenalty > maxModePenalty) {
    const excessPenalty = totalModePenalty - maxModePenalty;
    finalScore += excessPenalty; // Reverter penalidade excessiva
    notes.push(`‚ö†Ô∏è Penalidades do modo limitadas: ${totalModePenalty.toFixed(1)} ‚Üí ${maxModePenalty.toFixed(1)} (m√°x 30% do score t√©cnico)`);
  }

  return {
    finalScore: Math.max(1, Math.min(99, finalScore)),
    notes
  };
}

/**
 * üéØ RASP - Risk-Adjusted Signal Probability Engine
 * Motor de probabilidade real usando ensemble de m√∫ltiplos fatores
 */
function calculateRASP(mtfScore, patternScore, volumeScore, orderBookScore, regimeScore, weights = {}) {
  const defaultWeights = {
    mtf: 0.25,
    pattern: 0.25,
    volume: 0.20,
    orderbook: 0.15,
    regime: 0.15
  };
  const w = { ...defaultWeights, ...weights };

  // Normalizar scores para 0-1
  const normalizeScore = (score) => Math.max(0, Math.min(1, score / 100));

  const p = (
    w.mtf * normalizeScore(mtfScore || 50) +
    w.pattern * normalizeScore(patternScore || 50) +
    w.volume * normalizeScore(volumeScore || 50) +
    w.orderbook * normalizeScore(orderBookScore || 50) +
    w.regime * normalizeScore(regimeScore || 50)
  );

  return {
    probability: p,
    confidence: p >= 0.7 ? 'high' : p >= 0.5 ? 'medium' : 'low',
    breakdown: {
      mtf: normalizeScore(mtfScore || 50),
      pattern: normalizeScore(patternScore || 50),
      volume: normalizeScore(volumeScore || 50),
      orderbook: normalizeScore(orderBookScore || 50),
      regime: normalizeScore(regimeScore || 50)
    }
  };
}

/**
 * üî¨ MICROESTRUTURA DETECTION - Essencial para 75x+
 * Detecta micro-pullbacks, displacement, imbalance, compress√£o/expans√£o, ritmo de agress√µes
 */
function analyzeMicrostructure(candles, orderBookAnalysis) {
  if (!candles || candles.length < 10) return null;

  try {
    const recent = candles.slice(-10);
    const current = recent[recent.length - 1];
    const prev = recent[recent.length - 2];

    // 1. DISPLACEMENT CANDLES (velas de deslocamento r√°pido)
    const displacement = Math.abs(current.close - prev.close) / prev.close;
    const isDisplacement = displacement > 0.001 && current.volume > prev.volume * 1.5;

    // 2. MICRO-PULLBACKS (pequenos retra√ß√µes)
    const bodySize = Math.abs(current.close - current.open);
    const totalRange = current.high - current.low;
    const bodyRatio = totalRange > 0 ? bodySize / totalRange : 0;
    const hasMicroPullback = bodyRatio < 0.3 && totalRange > 0;

    // 3. IMBALANCE MICRO (desequil√≠brio entre bid/ask)
    const imbalance = orderBookAnalysis?.imbalance || 0;
    const microImbalance = Math.abs(imbalance) > 0.15;

    // 4. COMPRESS√ÉO vs EXPANS√ÉO
    const avgRange = recent.slice(0, -1).reduce((sum, c) => sum + (c.high - c.low), 0) / (recent.length - 1);
    const currentRange = current.high - current.low;
    const isCompression = currentRange < avgRange * 0.7;
    const isExpansion = currentRange > avgRange * 1.3;

    // 5. RITMO DE AGRESS√ïES (delta - diferen√ßa entre compras e vendas)
    const volumeDelta = recent.slice(-5).reduce((sum, c) => {
      const isBullish = c.close > c.open;
      return sum + (isBullish ? c.volume : -c.volume);
    }, 0);
    const avgVolume = recent.slice(-5).reduce((sum, c) => sum + c.volume, 0) / 5;
    const deltaRatio = avgVolume > 0 ? volumeDelta / avgVolume : 0;

    // 6. CANDLE SPEED (velocidade do movimento)
    const priceChange = Math.abs(current.close - prev.close);
    const timeWindow = 1; // 1 minuto para M1
    const candleSpeed = priceChange / timeWindow;

    // 7. FOOTPRINT SIMPLIFICADO (press√£o de compra vs venda)
    const buyPressure = current.close > current.open ? current.volume : 0;
    const sellPressure = current.close < current.open ? current.volume : 0;
    const footprintRatio = (buyPressure - sellPressure) / (buyPressure + sellPressure || 1);

    // Score de microestrutura (0-100)
    let microstructureScore = 50;
    if (isDisplacement) microstructureScore += 15;
    if (hasMicroPullback) microstructureScore += 10;
    if (microImbalance) microstructureScore += Math.abs(imbalance) * 20;
    if (isExpansion) microstructureScore += 10;
    if (isCompression) microstructureScore -= 5; // Compress√£o pode indicar indecis√£o
    if (Math.abs(deltaRatio) > 0.3) microstructureScore += Math.abs(deltaRatio) * 15;
    if (candleSpeed > avgRange * 0.5) microstructureScore += 10;
    if (Math.abs(footprintRatio) > 0.4) microstructureScore += Math.abs(footprintRatio) * 15;

    return {
      score: Math.max(0, Math.min(100, microstructureScore)),
      displacement: isDisplacement,
      microPullback: hasMicroPullback,
      imbalance: microImbalance,
      compression: isCompression,
      expansion: isExpansion,
      deltaRatio,
      candleSpeed,
      footprintRatio,
      signals: {
        bullish: deltaRatio > 0.2 && footprintRatio > 0.3,
        bearish: deltaRatio < -0.2 && footprintRatio < -0.3,
        neutral: Math.abs(deltaRatio) <= 0.2
      }
    };
  } catch (error) {
    log('warn', 'Erro ao analisar microestrutura', { error: error.message });
    return null;
  }
}

/**
 * üìà NEXT-CANDLE FORECASTING - Previs√£o matem√°tica de curto prazo
 * Usa Candle Drift Predictor para prever pr√≥ximo movimento
 */
function forecastNextCandle(candles, technicalIndicators) {
  if (!candles || candles.length < 14) return null;

  try {
    const recent = candles.slice(-14);
    const closes = recent.map(c => c.close);

    // EMA r√°pida (5) e lenta (14)
    const emaFast = (closes) => {
      const k = 2 / (5 + 1);
      let ema = closes[0];
      for (let i = 1; i < closes.length; i++) {
        ema = closes[i] * k + ema * (1 - k);
      }
      return ema;
    };

    const emaSlow = (closes) => {
      const k = 2 / (14 + 1);
      let ema = closes[0];
      for (let i = 1; i < closes.length; i++) {
        ema = closes[i] * k + ema * (1 - k);
      }
      return ema;
    };

    const ema5 = emaFast(closes);
    const ema14 = emaSlow(closes);
    const expectedMove = ema5 - ema14;

    // ATR para volatilidade
    const atr = technicalIndicators?.atr || 0;
    const currentPrice = closes[closes.length - 1];
    const atrPct = currentPrice > 0 ? atr / currentPrice : 0.002;
    const volProjection = atrPct * 1.2; // Coeficiente de proje√ß√£o

    // Volume Z-Score
    const volumes = recent.map(c => c.volume);
    const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
    const volumeStd = Math.sqrt(volumes.reduce((sum, v) => sum + Math.pow(v - avgVolume, 2), 0) / volumes.length);
    const volumeZ = volumeStd > 0 ? (volumes[volumes.length - 1] - avgVolume) / volumeStd : 0;

    // Momentum Ratio
    const momentum = (closes[closes.length - 1] - closes[0]) / closes[0];
    const momentumRatio = Math.abs(momentum) / (volProjection || 0.001);

    // Probabilidade de alta (sigmoid)
    const logistic = (x) => 1 / (1 + Math.exp(-x));
    const probabilityUp = logistic(expectedMove / (volProjection * currentPrice || 0.001) + volumeZ * 0.5);

    // Probabilidade de breakout
    const volatilityCompression = atrPct < 0.001 ? 1 : 0; // Baixa volatilidade = compress√£o
    const orderBookImbalance = 0; // Ser√° preenchido pela an√°lise de order book
    const volumeExpansion = volumeZ > 1 ? 1 : volumeZ > 0.5 ? 0.5 : 0;
    const breakoutProb = logistic((volatilityCompression + volumeExpansion) * 2);

    // Probabilidade de revers√£o
    const current = recent[recent.length - 1];
    const wickUpper = current.high - Math.max(current.open, current.close);
    const wickLower = Math.min(current.open, current.close) - current.low;
    const totalRange = current.high - current.low;
    const wickStrength = totalRange > 0 ? Math.max(wickUpper, wickLower) / totalRange : 0;
    const deltaReversal = Math.abs(momentum) > 0.005 && momentum * (closes[closes.length - 1] - closes[closes.length - 2]) < 0 ? 1 : 0;
    const revProb = logistic((wickStrength * 2 + deltaReversal) * 1.5);

    return {
      probabilityUp,
      probabilityDown: 1 - probabilityUp,
      breakoutProb,
      reversalProb: revProb,
      expectedMove,
      expectedDirection: expectedMove > 0 ? 'UP' : 'DOWN',
      amplitude: Math.abs(expectedMove),
      volatilityProjection: volProjection,
      momentumRatio
    };
  } catch (error) {
    log('warn', 'Erro ao prever pr√≥ximo candle', { error: error.message });
    return null;
  }
}

/**
 * üó∫Ô∏è LIQUIDITY MAP DETECTION - Detec√ß√£o completa de zonas de liquidez
 */
function detectLiquidityMap(candles, orderBookAnalysis) {
  if (!candles || candles.length < 20) return null;

  try {
    const recent = candles.slice(-20);
    const prices = recent.map(c => c.close);
    const highs = recent.map(c => c.high);
    const lows = recent.map(c => c.low);
    const volumes = recent.map(c => c.volume);

    // 1. EQUAL HIGHS/LOWS (n√≠veis iguais)
    const equalHighs = [];
    const equalLows = [];
    const tolerance = 0.001; // 0.1% de toler√¢ncia

    for (let i = 0; i < highs.length - 1; i++) {
      for (let j = i + 1; j < highs.length; j++) {
        if (Math.abs(highs[i] - highs[j]) / highs[i] < tolerance) {
          equalHighs.push((highs[i] + highs[j]) / 2);
        }
        if (Math.abs(lows[i] - lows[j]) / lows[i] < tolerance) {
          equalLows.push((lows[i] + lows[j]) / 2);
        }
      }
    }

    // 2. RESTING LIQUIDITY (liquidez em repouso - clusters de volume)
    const vwap = volumes.reduce((sum, v, i) => sum + prices[i] * v, 0) / volumes.reduce((a, b) => a + b, 0);
    const vwapClusters = [];
    recent.forEach((candle, i) => {
      const distance = Math.abs(candle.close - vwap) / vwap;
      if (distance < 0.002 && candle.volume > volumes.reduce((a, b) => a + b, 0) / volumes.length * 1.2) {
        vwapClusters.push({ price: candle.close, volume: candle.volume });
      }
    });

    // 3. MAGNET LEVELS (n√≠veis magn√©ticos - pre√ßos psicol√≥gicos)
    const currentPrice = prices[prices.length - 1];
    const roundLevels = [];
    const significantDigits = currentPrice > 1000 ? 100 : currentPrice > 100 ? 10 : currentPrice > 10 ? 1 : 0.1;
    for (let level = Math.floor(currentPrice / significantDigits) * significantDigits - significantDigits * 2;
      level <= Math.floor(currentPrice / significantDigits) * significantDigits + significantDigits * 2;
      level += significantDigits) {
      roundLevels.push(level);
    }

    // 4. IMBALANCE IMATADO (imbalance que atrai pre√ßo)
    const imbalance = orderBookAnalysis?.imbalance || 0;
    const magnetImbalance = Math.abs(imbalance) > 0.2;

    // 5. LIQUIDITY VOID DETECTOR (vazios de liquidez)
    const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
    const liquidityVoids = [];
    recent.forEach((candle, i) => {
      if (candle.volume < avgVolume * 0.5) {
        liquidityVoids.push({ price: candle.close, index: i });
      }
    });

    return {
      equalHighs: [...new Set(equalHighs)].slice(0, 5),
      equalLows: [...new Set(equalLows)].slice(0, 5),
      vwapClusters: vwapClusters.slice(0, 5),
      magnetLevels: roundLevels,
      magnetImbalance,
      liquidityVoids: liquidityVoids.slice(0, 5),
      vwap,
      score: (equalHighs.length + equalLows.length + vwapClusters.length) * 5
    };
  } catch (error) {
    log('warn', 'Erro ao detectar mapa de liquidez', { error: error.message });
    return null;
  }
}

/**
 * üö® KILL SWITCH - Detec√ß√£o de mercado perigoso
 */
function detectMarketKillSwitch(candles, orderBookAnalysis, technicalIndicators) {
  if (!candles || candles.length < 10) return { shouldBlock: false, reasons: [] };

  try {
    const recent = candles.slice(-10);
    const reasons = [];
    let shouldBlock = false;

    // 1. SPREAD SPIKE (spread muito alto)
    const current = recent[recent.length - 1];
    const spread = (current.high - current.low) / current.close;
    if (spread > 0.01) { // 1% de spread
      reasons.push(`üö® Spread spike detectado: ${(spread * 100).toFixed(2)}%`);
      shouldBlock = true;
    }

    // 2. VOLUME DIVERGENTE EXTREMO
    // ‚úÖ AJUSTE: Tornado menos restritivo (5x/0.2x ‚Üí 10x/0.1x) para permitir mais trades
    const volumes = recent.map(c => c.volume);
    const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
    const currentVolume = volumes[volumes.length - 1];
    const volumeRatio = currentVolume / (avgVolume || 1);
    if (volumeRatio > 10 || volumeRatio < 0.1) { // Ajustado: apenas extremos reais bloqueiam
      reasons.push(`üö® Volume divergente extremo: ${volumeRatio.toFixed(2)}x`);
      shouldBlock = true;
    }

    // 3. ORDERBOOK EM CONFLITO
    // ‚úÖ AJUSTE: Tornado menos restritivo (¬±10% ‚Üí ¬±5%) para permitir mais trades em consolida√ß√£o
    const imbalance = orderBookAnalysis?.imbalance || 0;
    const largeOrders = orderBookAnalysis?.largeOrders || { buy: 0, sell: 0 };
    const orderBookConflict = Math.abs(imbalance) < 0.05 && (largeOrders.buy > 0 && largeOrders.sell > 0); // Ajustado: apenas conflito real bloqueia
    if (orderBookConflict) {
      reasons.push('üö® Order book em conflito - press√£o mista');
      shouldBlock = true;
    }

    // 4. CHOP ZONE DETECTION (zona de indecis√£o extrema)
    // ‚úÖ AJUSTE: Tornado menos restritivo (0.05% ‚Üí 0.02%) para permitir trades em consolida√ß√£o normal
    const priceChanges = recent.slice(1).map((c, i) => Math.abs(c.close - recent[i].close) / recent[i].close);
    const avgChange = priceChanges.reduce((a, b) => a + b, 0) / priceChanges.length;
    const changeStd = Math.sqrt(priceChanges.reduce((sum, c) => sum + Math.pow(c - avgChange, 2), 0) / priceChanges.length);
    const isChopZone = avgChange < 0.0002 && changeStd < 0.0002; // Ajustado: apenas movimento MUITO pequeno bloqueia (0.02% vs 0.05%)
    if (isChopZone) {
      reasons.push('üö® Chop zone detectada - mercado indeciso');
      shouldBlock = true;
    }

    // 5. ATR SPIKE (volatilidade extrema)
    const atr = technicalIndicators?.atr || 0;
    const currentPrice = recent[recent.length - 1].close;
    const atrPct = currentPrice > 0 ? atr / currentPrice : 0;
    if (atrPct > 0.02) { // 2% de ATR
      reasons.push(`üö® Volatilidade extrema: ATR ${(atrPct * 100).toFixed(2)}%`);
      shouldBlock = true;
    }

    return { shouldBlock, reasons, severity: shouldBlock ? 'high' : 'low' };
  } catch (error) {
    log('warn', 'Erro ao detectar kill switch', { error: error.message });
    return { shouldBlock: false, reasons: [] };
  }
}

/**
 * üõë AUTO-STOPPER - Bloqueia entradas em condi√ß√µes perigosas
 */
function checkAutoStopper(candles, technicalIndicators, orderBookAnalysis, marketRegime) {
  if (!candles || candles.length < 5) return { shouldBlock: false, reason: '' };

  try {
    const recent = candles.slice(-5);
    const atr = technicalIndicators?.atr || 0;
    const currentPrice = recent[recent.length - 1].close;
    const atrPct = currentPrice > 0 ? atr / currentPrice : 0;

    // Condi√ß√µes para bloquear
    const conditions = {
      atrSpike: atrPct > 0.015, // ATR muito alto
      emaNeutral: true, // Ser√° verificado depois
      orderBookConflict: orderBookAnalysis && Math.abs(orderBookAnalysis.imbalance || 0) < 0.05,
      sweepWithoutFollow: false, // Ser√° verificado depois
      volatileRegime: marketRegime === 'VOLATILE'
    };

    const blockedConditions = Object.values(conditions).filter(c => c === true).length;

    if (blockedConditions >= 3) {
      return {
        shouldBlock: true,
        reason: `üö® AUTO-STOPPER: ${blockedConditions} condi√ß√µes perigosas detectadas`,
        blockDuration: 3 // 3 candles
      };
    }

    return { shouldBlock: false, reason: '' };
  } catch (error) {
    log('warn', 'Erro ao verificar auto-stopper', { error: error.message });
    return { shouldBlock: false, reason: '' };
  }
}

// ============================================================================
// üè∑Ô∏è SIGNAL CLASSIFICATION (v291) - Classifica√ß√£o clara de a√ß√£o sobre sinais
// Classes: TRADE | WAIT | SETUP | WARNING | NO_TRADE
// ============================================================================
type SignalClass = 'TRADE' | 'WAIT' | 'SETUP' | 'WARNING' | 'NO_TRADE';

interface SignalClassification {
  signalClass: SignalClass;
  reason: string;
  confidence: number;
  recommendation: string;
  canExecute: boolean;
}

/**
 * üè∑Ô∏è CLASSIFY SIGNAL - Determina a a√ß√£o sobre um sinal
 */
function classifySignal(params: {
  score: number;
  exhaustion?: { isExhausted: boolean; confidence: number };
  killSwitch?: { shouldBlock: boolean; severity?: string };
  autoStopper?: { shouldBlock: boolean };
  volumeZ?: number;
  patternWinRate?: number;
  signalType?: string;
  hasMinConfluence?: boolean;
}): SignalClassification {
  const {
    score = 0,
    exhaustion = { isExhausted: false, confidence: 0 },
    killSwitch = { shouldBlock: false },
    autoStopper = { shouldBlock: false },
    volumeZ = 0,
    patternWinRate = 0.5,
    signalType = 'NEUTRAL',
    hasMinConfluence = false
  } = params;

  // üö® WARNING: Kill Switch ou Auto-Stopper ativo
  if (killSwitch.shouldBlock || autoStopper.shouldBlock) {
    const reason = killSwitch.shouldBlock
      ? 'Kill Switch ativo - mercado perigoso'
      : 'Auto-Stopper ativo - condi√ß√µes adversas';
    console.log(`üè∑Ô∏è [SIGNAL CLASS] WARNING: ${reason}`);
    return {
      signalClass: 'WARNING',
      reason,
      confidence: 0,
      recommendation: 'Evitar qualquer entrada.',
      canExecute: false
    };
  }

  // ‚ùå NO_TRADE: Score muito baixo ou sem dire√ß√£o
  if (score < 30 || signalType === 'NEUTRAL') {
    const reason = score < 30 ? `Score baixo (${score.toFixed(0)})` : 'Sem dire√ß√£o';
    console.log(`üè∑Ô∏è [SIGNAL CLASS] NO_TRADE: ${reason}`);
    return {
      signalClass: 'NO_TRADE',
      reason,
      confidence: score,
      recommendation: 'Ignorar sinal.',
      canExecute: false
    };
  }

  // ‚è≥ WAIT: Exaust√£o detectada
  if (exhaustion.isExhausted && exhaustion.confidence >= 50) {
    console.log(`üè∑Ô∏è [SIGNAL CLASS] WAIT: Exaust√£o (${exhaustion.confidence}%)`);
    return {
      signalClass: 'WAIT',
      reason: `Exaust√£o detectada (${exhaustion.confidence}%)`,
      confidence: score,
      recommendation: 'Aguardar pullback.',
      canExecute: false
    };
  }

  // ‚è≥ WAIT: Volume muito baixo
  if (volumeZ < -1.5 && score < 50) {
    console.log(`üè∑Ô∏è [SIGNAL CLASS] WAIT: Volume baixo (z=${volumeZ.toFixed(2)})`);
    return {
      signalClass: 'WAIT',
      reason: `Volume baixo (z: ${volumeZ.toFixed(2)})`,
      confidence: score,
      recommendation: 'Aguardar volume.',
      canExecute: false
    };
  }

  // üìå SETUP: Score m√©dio com padr√£o v√°lido
  if (score >= 30 && score < 45 && (patternWinRate >= 0.4 || hasMinConfluence)) {
    console.log(`üè∑Ô∏è [SIGNAL CLASS] SETUP: Score ${score.toFixed(0)}`);
    return {
      signalClass: 'SETUP',
      reason: `Zona mapeada (score: ${score.toFixed(0)})`,
      confidence: score,
      recommendation: 'Monitorar.',
      canExecute: false
    };
  }

  // ‚úÖ TRADE: Score alto, sem exaust√£o
  if (score >= 45 && !exhaustion.isExhausted) {
    const volumeOk = volumeZ >= -0.5;
    if (score >= 60 || (score >= 45 && volumeOk && hasMinConfluence)) {
      console.log(`üè∑Ô∏è [SIGNAL CLASS] TRADE: Score ${score.toFixed(0)}, ${signalType}`);
      return {
        signalClass: 'TRADE',
        reason: `Sinal v√°lido (score: ${score.toFixed(0)})`,
        confidence: score,
        recommendation: `Executar ${signalType}.`,
        canExecute: true
      };
    }
  }

  // üìå SETUP default
  if (score >= 35) {
    console.log(`üè∑Ô∏è [SIGNAL CLASS] SETUP: Score ${score.toFixed(0)}`);
    return {
      signalClass: 'SETUP',
      reason: `Score moderado (${score.toFixed(0)})`,
      confidence: score,
      recommendation: 'Monitorar.',
      canExecute: false
    };
  }

  // ‚ùå NO_TRADE fallback
  console.log(`üè∑Ô∏è [SIGNAL CLASS] NO_TRADE: Score ${score.toFixed(0)}`);
  return {
    signalClass: 'NO_TRADE',
    reason: 'Condi√ß√µes insuficientes',
    confidence: score,
    recommendation: 'Ignorar.',
    canExecute: false
  };
}

/**
 * üéØ FILTRO INTELIGENTE DE CONFLU√äNCIAS - Otimizado para alta leverage (75%+)
 * Remove contradi√ß√µes e prioriza informa√ß√µes cr√≠ticas SEM perder performance
 */
function filterAndPrioritizeConfluences(confluences, isHighLeverage, killSwitchActive, signalType) {
  if (!Array.isArray(confluences) || confluences.length === 0) return confluences;

  // Categorias de prioridade (mais alta = mais importante)
  const priorityMap = {
    // CR√çTICO para alta leverage (prioridade 10)
    'HLS': 10,
    'Directional Confidence': 10,
    'KILL SWITCH': 10,
    'AUTO-STOPPER': 10,
    'ERI': 9,
    'HLS abaixo': 10,
    'Directional Confidence abaixo': 10,

    // ALTO para alta leverage (prioridade 8-9)
    'Order Book': 8,
    'Liquidity Map': 8,
    'Market Regime': 8,
    'Multi-timeframe': 8,
    'VWAP': 7,

    // M√âDIO (prioridade 5-7)
    'RSI': 6,
    'EMA': 6,
    'MACD': 6,
    'Volume': 6,
    'ATR': 5,

    // BAIXO (prioridade 1-4)
    'Conhecimento': 3,
    'Padr√£o recorrente': 3,
    'Confian√ßa hist√≥rica': 2,
    'Hor√°rio': 2,
    'Dia √∫til': 1
  };

  // Padr√µes de bloqueio (se presentes, remover sinais opostos)
  const blockPatterns = [
    /KILL SWITCH/i,
    /AUTO-STOPPER/i,
    /HLS abaixo/i,
    /Directional Confidence.*‚ùå/i,
    /ERI.*REVERS√ÉO FORTE/i,
    /Chop zone/i,
    /Mercado perigoso/i
  ];

  const isBlocked = blockPatterns.some(pattern =>
    confluences.some(c => pattern.test(String(c)))
  );

  // Se bloqueado, remover sinais contradit√≥rios
  const filtered = confluences.filter(c => {
    const cStr = String(c).toLowerCase();

    // Se h√° bloqueio ativo, remover sinais BUY/SELL contradit√≥rios
    if (isBlocked || killSwitchActive) {
      if (cStr.includes('sinal de entrada: buy') ||
        cStr.includes('sinal de entrada: sell') ||
        cStr.includes('entry signal: buy') ||
        cStr.includes('entry signal: sell')) {
        return false; // Remove sinais contradit√≥rios
      }
    }

    // Para alta leverage, remover informa√ß√µes redundantes/ru√≠do
    if (isHighLeverage) {
      // Remover conflu√™ncias muito gen√©ricas
      if (cStr.includes('conhecimento espec√≠fico:') && cStr.includes('entradas encontradas')) {
        // Manter apenas se for muito relevante (n√∫mero alto)
        const match = cStr.match(/(\d+)\s+entradas/);
        if (match && parseInt(match[1]) < 50) return false;
      }

      // Remover informa√ß√µes de hor√°rio (n√£o cr√≠tico para alta leverage)
      if (cStr.includes('hor√°rio') || cStr.includes('dia √∫til')) {
        return false;
      }
    }

    return true;
  });

  // Priorizar: ordenar por import√¢ncia (mais alta primeiro)
  const prioritized = filtered.sort((a, b) => {
    const aStr = String(a);
    const bStr = String(b);

    let aPriority = 0;
    let bPriority = 0;

    // Calcular prioridade de A
    for (const [key, priority] of Object.entries(priorityMap)) {
      if (aStr.includes(key)) {
        aPriority = Math.max(aPriority, priority);
      }
      if (bStr.includes(key)) {
        bPriority = Math.max(bPriority, priority);
      }
    }

    // Se √© alta leverage, aumentar prioridade de itens cr√≠ticos
    if (isHighLeverage) {
      if (aStr.includes('HLS') || aStr.includes('Directional') || aStr.includes('KILL')) {
        aPriority += 2;
      }
      if (bStr.includes('HLS') || bStr.includes('Directional') || bStr.includes('KILL')) {
        bPriority += 2;
      }
    }

    return bPriority - aPriority; // Maior prioridade primeiro
  });

  // Limitar quantidade (especialmente para alta leverage - menos ru√≠do)
  const maxConfluences = isHighLeverage ? 20 : 30;
  return prioritized.slice(0, maxConfluences);
}

/**
 * üéØ HLS - High-Leverage Score (exclusivo para 75x+)
 */
function calculateHLS(mtfAlignment, liquidityScore, orderBookPressure, volumeExpansion, microstructureScore, regimeStability) {
  const hls = (
    0.25 * (mtfAlignment || 0) +
    0.20 * (liquidityScore || 0) +
    0.20 * (orderBookPressure || 0) +
    0.15 * (volumeExpansion || 0) +
    0.10 * (microstructureScore || 0) +
    0.10 * (regimeStability || 0)
  );

  return {
    hls,
    approved: hls >= 0.72,
    breakdown: {
      mtfAlignment: mtfAlignment || 0,
      liquidityScore: liquidityScore || 0,
      orderBookPressure: orderBookPressure || 0,
      volumeExpansion: volumeExpansion || 0,
      microstructureScore: microstructureScore || 0,
      regimeStability: regimeStability || 0
    }
  };
}

/**
 * üî• IGNITION DETECTOR (75x)
 * Detecta o NASCIMENTO de movimentos, n√£o o movimento em si.
 * Entra NO IN√çCIO do spike para maximizar lucro com 75x.
 * 
 * ‚úÖ Igni√ß√£o perfeita: delta 0.15% - 0.35%
 * ‚ö†Ô∏è J√° andando: delta 0.35% - 0.50%
 * ‚ùå Tarde demais: delta > 0.60%
 */
function detectIgnition(candles: any[], pattern: any) {
  if (!candles || candles.length < 3) {
    return {
      detected: false,
      direction: 'NEUTRAL',
      quality: 'none',
      reason: 'Poucos candles',
      scoreFloor: null,
      shouldReject: false
    };
  }

  try {
    const current = candles[candles.length - 1];
    const prev = candles[candles.length - 2];

    // 1Ô∏è‚É£ EXPANS√ÉO S√öBITA - Delta da vela atual
    const delta = Math.abs(current.close - current.open) / current.open * 100;

    // 2Ô∏è‚É£ VOLUME CONFIRMA - Volume ratio
    const avgVol = candles.slice(-10).reduce((sum, c) => sum + (c.volume || 0), 0) / 10;
    const volumeRatio = avgVol > 0 ? (current.volume || 0) / avgVol : 1;

    // 3Ô∏è‚É£ DIRE√á√ÉO LIMPA - Corpo >= 65%, pavio contra < 20%
    const body = Math.abs(current.close - current.open);
    const totalRange = current.high - current.low;
    const bodyRatio = totalRange > 0 ? body / totalRange : 0;

    const isBullish = current.close > current.open;
    const wickAgainst = isBullish
      ? (current.open - current.low) // pavio inferior para bullish
      : (current.high - current.close); // pavio superior para bearish
    const wickRatio = totalRange > 0 ? wickAgainst / totalRange : 0;

    const direction = isBullish ? 'BUY' : 'SELL';

    // üî• CLASSIFICA√á√ÉO DO DELTA
    let quality = 'none';
    let shouldReject = false;
    let reason = '';

    if (delta >= 0.15 && delta <= 0.35) {
      quality = 'ignition'; // üî• Igni√ß√£o perfeita
      reason = `Igni√ß√£o detectada: delta ${delta.toFixed(2)}% (zona ideal)`;
    } else if (delta > 0.35 && delta <= 0.50) {
      quality = 'moving'; // ‚ö†Ô∏è J√° andando
      reason = `Movimento em progresso: delta ${delta.toFixed(2)}% (ainda ok)`;
    } else if (delta > 0.60) {
      quality = 'late'; // ‚ùå Tarde demais
      shouldReject = true;
      reason = `TARDE DEMAIS: delta ${delta.toFixed(2)}% > 0.60% (rejeitar)`;
    } else {
      quality = 'weak';
      reason = `Delta ${delta.toFixed(2)}% muito fraco para igni√ß√£o`;
    }

    // üõ°Ô∏è VALIDA√á√ïES ADICIONAIS
    const volumeValid = volumeRatio >= 1.4;
    const bodyValid = bodyRatio >= 0.65;
    const wickValid = wickRatio < 0.20;

    // S√≥ aceita igni√ß√£o se volume + corpo + pavio confirmam
    const isValidIgnition = (quality === 'ignition' || quality === 'moving') &&
      volumeValid && bodyValid && wickValid;

    // 4Ô∏è‚É£ PADR√ÉO ALINHADO (BOS ou ChoCh)
    const patternName = typeof pattern === 'string'
      ? pattern.toLowerCase()
      : (pattern?.type || pattern?.name || '').toLowerCase();
    const isBOS = patternName.includes('bos') || patternName.includes('break of structure');
    const isChoCh = patternName.includes('choch') || patternName.includes('change of character');
    const patternAligned = isBOS || isChoCh;

    // üéØ SCORE FLOOR - eleva o piso se igni√ß√£o v√°lida
    let scoreFloor = null;
    if (isValidIgnition && patternAligned) {
      scoreFloor = 72; // Piso m√≠nimo para igni√ß√£o v√°lida + padr√£o alinhado
      console.log(`üî• [IGNITION] Score floor elevado para ${scoreFloor}: ${reason}`);
    }

    // Log
    if (quality !== 'weak' && quality !== 'none') {
      console.log(`üî• [IGNITION] ${quality.toUpperCase()}: delta=${delta.toFixed(2)}%, vol=${volumeRatio.toFixed(2)}x, body=${(bodyRatio * 100).toFixed(0)}%, wick=${(wickRatio * 100).toFixed(0)}%`);
    }

    return {
      detected: isValidIgnition,
      direction,
      quality,
      reason,
      scoreFloor,
      shouldReject: shouldReject && !isValidIgnition,
      details: {
        delta: delta.toFixed(3),
        volumeRatio: volumeRatio.toFixed(2),
        bodyRatio: (bodyRatio * 100).toFixed(0),
        wickRatio: (wickRatio * 100).toFixed(0),
        volumeValid,
        bodyValid,
        wickValid,
        patternAligned
      }
    };
  } catch (error) {
    console.warn('‚ö†Ô∏è Erro no Ignition Detector:', error);
    return {
      detected: false,
      direction: 'NEUTRAL',
      quality: 'error',
      reason: 'Erro ao detectar igni√ß√£o',
      scoreFloor: null,
      shouldReject: false
    };
  }
}

/**
 * üß≠ DIRECTIONAL CONFIDENCE ENGINE
 * ‚úÖ MELHORIA: Considera Order Blocks para aumentar confian√ßa direcional
 * ‚úÖ 19/dez: Boost condicional +7% quando MTF confirma dire√ß√£o
 */
function calculateDirectionalConfidence(trendStrength, momentumRatio, pattern = null, mtfContext = null, indicators = null) {
  // ‚úÖ 19/dez: Boost base +10% para tornar mais sens√≠vel
  // O c√°lculo original era muito conservador - pre√ßo movia 0.70% e ainda mostrava 28%
  let dirConf = (trendStrength * 0.6) + (momentumRatio * 0.4) + 0.10; // +10% base boost
  let boostApplied = 'Base +10%';

  // ‚úÖ MELHORIA 4: Order Blocks aumentam Directional Confidence (+15%)
  // Order Blocks s√£o zonas institucionais de alta confian√ßa, mesmo sem momentum perfeito
  if (pattern) {
    const patternType = typeof pattern === 'string'
      ? pattern.toLowerCase()
      : (pattern?.type || pattern?.name || '').toLowerCase();

    const isOrderBlock = patternType.includes('order block') ||
      patternType.includes('orderblock') ||
      patternType.includes('ob');

    if (isOrderBlock) {
      // Boost de +15% para Order Blocks (zona institucional)
      dirConf = Math.min(1.0, dirConf + 0.15);
      boostApplied = 'Order Block +15%';
    }

    // ‚úÖ 19/dez: Boost condicional +7% quando MTF confirma dire√ß√£o
    // S√≥ aplica quando: MTF.m15/m30 bearish/bullish + BOS/ChoCh + EMA confirmada
    if (mtfContext && indicators && !isOrderBlock) {
      const isBOS = patternType.includes('bos') || patternType.includes('break of structure');
      const isChoCh = patternType.includes('choch') || patternType.includes('change of character');
      const isBearishPattern = patternType.includes('bearish');
      const isBullishPattern = patternType.includes('bullish');

      const m15Trend = mtfContext?.m15?.trend || 'neutral';
      const m30Trend = mtfContext?.m30?.trend || 'neutral';
      const ema9 = indicators?.ema_9 || 0;
      const ema50 = indicators?.ema_50 || 0;

      // Condi√ß√£o para SELL: MTF bearish + padr√£o bearish + EMA9 < EMA50
      const mtfConfirmsBearish = (m15Trend === 'bearish' || m30Trend === 'bearish') &&
        isBearishPattern && (isBOS || isChoCh) && ema9 < ema50;

      // Condi√ß√£o para BUY: MTF bullish + padr√£o bullish + EMA9 > EMA50
      const mtfConfirmsBullish = (m15Trend === 'bullish' || m30Trend === 'bullish') &&
        isBullishPattern && (isBOS || isChoCh) && ema9 > ema50;

      if (mtfConfirmsBearish || mtfConfirmsBullish) {
        // Boost de +7% quando macro confirma
        dirConf = Math.min(1.0, dirConf + 0.07);
        boostApplied = `MTF Confirms ${mtfConfirmsBearish ? 'Bearish' : 'Bullish'} +7%`;
        console.log(`üß≠ [DIRECTIONAL BOOST] +7% aplicado: ${boostApplied}`);
      }
    }
  }

  return {
    confidence: dirConf,
    approved: dirConf >= 0.63, // Threshold original mantido
    trendStrength,
    momentumRatio,
    hasOrderBlockBoost: boostApplied?.includes('Order Block'),
    hasMTFBoost: boostApplied?.includes('MTF'),
    boostApplied
  };
}

/**
 * üîÑ EARLY REVERSAL INDEX (ERI)
 */
function calculateERI(candles, orderBookAnalysis) {
  if (!candles || candles.length < 5) return null;

  try {
    const recent = candles.slice(-5);
    const current = recent[recent.length - 1];
    const prev = recent[recent.length - 2];

    // 1. CANDLE ABSORPTION (vela absorvida)
    const isAbsorbed = (current.high <= prev.high && current.low >= prev.low) ||
      (prev.high <= current.high && prev.low >= current.low);

    // 2. DELTA REVERSAL (revers√£o de delta)
    const prevDelta = prev.close > prev.open ? prev.volume : -prev.volume;
    const currentDelta = current.close > current.open ? current.volume : -current.volume;
    const deltaReversal = prevDelta * currentDelta < 0;

    // 3. WICK RATIO (propor√ß√£o de wick)
    const wickUpper = current.high - Math.max(current.open, current.close);
    const wickLower = Math.min(current.open, current.close) - current.low;
    const totalRange = current.high - current.low;
    const wickRatio = totalRange > 0 ? Math.max(wickUpper, wickLower) / totalRange : 0;

    // 4. VOLUME SHIFT (mudan√ßa de volume)
    const volumes = recent.map(c => c.volume);
    const volumeShift = volumes[volumes.length - 1] / (volumes.slice(0, -1).reduce((a, b) => a + b, 0) / (volumes.length - 1) || 1);

    // 5. MICRO-ORDERFLOW (fluxo de ordens micro)
    const imbalance = orderBookAnalysis?.imbalance || 0;
    const microOrderFlow = Math.abs(imbalance) > 0.15;

    // Calcular ERI
    let eri = 0;
    if (isAbsorbed) eri += 0.2;
    if (deltaReversal) eri += 0.25;
    if (wickRatio > 0.4) eri += 0.2;
    if (volumeShift > 1.5 || volumeShift < 0.7) eri += 0.15;
    if (microOrderFlow) eri += 0.2;

    return {
      eri,
      strongReversal: eri > 0.65,
      isAbsorbed,
      deltaReversal,
      wickRatio,
      volumeShift,
      microOrderFlow
    };
  } catch (error) {
    log('warn', 'Erro ao calcular ERI', { error: error.message });
    return null;
  }
}

// ============================================================================
// üéØ FUN√á√ïES AUXILIARES MATEM√ÅTICAS PARA DETEC√á√ÉO PRECISA DE PADR√ïES
// ============================================================================

/**
 * Encontra picos locais (highs maiores que vizinhos)
 */
function findLocalPeaks(candles) {
  const peaks = [];
  for (let i = 1; i < candles.length - 1; i++) {
    const prev = candles[i - 1];
    const curr = candles[i];
    const next = candles[i + 1];

    if (curr.high > prev.high && curr.high > next.high) {
      peaks.push({ index: i, value: curr.high, candle: curr });
    }
  }
  return peaks;
}

/**
 * Encontra vales locais (lows menores que vizinhos)
 */
function findLocalValleys(candles) {
  const valleys = [];
  for (let i = 1; i < candles.length - 1; i++) {
    const prev = candles[i - 1];
    const curr = candles[i];
    const next = candles[i + 1];

    if (curr.low < prev.low && curr.low < next.low) {
      valleys.push({ index: i, value: curr.low, candle: curr });
    }
  }
  return valleys;
}

/**
 * Calcula linha de tend√™ncia usando regress√£o linear
 * Retorna { slope, intercept, rSquared }
 */
function calculateTrendLine(points) {
  if (points.length < 2) return null;

  const n = points.length;
  let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

  points.forEach((point, i) => {
    const x = i;
    const y = point.value;
    sumX += x;
    sumY += y;
    sumXY += x * y;
    sumX2 += x * x;
  });

  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
  const intercept = (sumY - slope * sumX) / n;

  // Calcular R¬≤ (coeficiente de determina√ß√£o)
  const yMean = sumY / n;
  let ssRes = 0, ssTot = 0;
  points.forEach((point, i) => {
    const y = point.value;
    const yPred = slope * i + intercept;
    ssRes += Math.pow(y - yPred, 2);
    ssTot += Math.pow(y - yMean, 2);
  });
  const rSquared = ssTot > 0 ? 1 - (ssRes / ssTot) : 0;

  return { slope, intercept, rSquared };
}

/**
 * Calcula converg√™ncia entre duas linhas de tend√™ncia
 * Retorna valor entre 0 (paralelas) e 1 (totalmente convergentes)
 */
function calculateConvergence(line1, line2) {
  if (!line1 || !line2) return 0;

  // Calcular dist√¢ncia no in√≠cio e no fim
  const startDist = Math.abs((line1.intercept) - (line2.intercept));
  const endDist = Math.abs((line1.slope * 10 + line1.intercept) - (line2.slope * 10 + line2.intercept));

  if (startDist === 0) return 0;

  const convergence = (startDist - endDist) / startDist;
  return Math.max(0, Math.min(1, convergence));
}

/**
 * Calcula paralelismo entre duas linhas de tend√™ncia
 * Retorna valor entre 0 (convergentes) e 1 (totalmente paralelas)
 */
function calculateParallelism(line1, line2) {
  if (!line1 || !line2) return 0;

  const slopeDiff = Math.abs(line1.slope - line2.slope);
  const maxSlope = Math.max(Math.abs(line1.slope), Math.abs(line2.slope));

  if (maxSlope === 0) return 1; // Ambas horizontais = paralelas

  const parallelism = 1 - (slopeDiff / maxSlope);
  return Math.max(0, Math.min(1, parallelism));
}

/**
 * Detecta displacement (movimento forte ap√≥s consolida√ß√£o)
 */
function detectDisplacement(candles) {
  if (candles.length < 5) return null;

  const recent = candles.slice(-5);
  const first = recent[0];
  const last = recent[recent.length - 1];

  const priceChange = Math.abs(last.close - first.close);
  const avgRange = recent.slice(0, -1).reduce((sum, c) => sum + (c.high - c.low), 0) / (recent.length - 1);

  // Displacement: movimento > 2x o range m√©dio
  if (priceChange > avgRange * 2) {
    return {
      direction: last.close > first.close ? 'bullish' : 'bearish',
      magnitude: priceChange / avgRange
    };
  }

  return null;
}

// ============================================================================
// üéØ DETEC√á√ÉO DE PADR√ïES POR CATEGORIA
// ============================================================================

/**
 * Detecta padr√µes de candlestick com valida√ß√µes corretas
 */
function detectCandlestickPatterns(candles) {
  if (candles.length < 3) return null;

  const current = candles[candles.length - 1];
  const prev = candles[candles.length - 2];
  const prev2 = candles[candles.length - 3];

  const body = Math.abs(current.close - current.open);
  const range = current.high - current.low;
  const upperWick = current.high - Math.max(current.open, current.close);
  const lowerWick = Math.min(current.open, current.close) - current.low;
  const bodyRatio = range > 0 ? body / range : 0;

  // ‚úÖ DOJI: Corpo < 5% + sombras longas/iguais
  if (bodyRatio < 0.05 && range > 0) {
    const minWick = Math.min(upperWick, lowerWick);
    const maxWick = Math.max(upperWick, lowerWick);

    if (minWick > body * 2 && maxWick > body * 1.5 &&
      Math.abs(current.open - current.close) < range * 0.1) {
      return 'Doji';
    }
  }

  // ‚úÖ HAMMER: Sombra inferior > 2x corpo, corpo pequeno no topo
  // CORRE√á√ÉO: Hammer √© SEMPRE bullish (revers√£o de baixa), n√£o existe "Hammer Bearish"
  // Se close < open, ainda √© Hammer (revers√£o bullish ap√≥s queda)
  if (lowerWick > body * 2 && upperWick < body * 0.5 && bodyRatio < 0.3) {
    const bodyPosition = (Math.min(current.open, current.close) - current.low) / range;
    if (bodyPosition > 0.6) { // Corpo na parte superior
      return 'Hammer'; // ‚úÖ SEMPRE bullish - revers√£o de baixa
    }
  }

  // ‚úÖ SHOOTING STAR: Sombra superior > 2x corpo, corpo pequeno na base
  // CORRIGIDO: Shooting Star √© SEMPRE bearish (revers√£o de alta), n√£o pode ser "Bullish"
  if (upperWick > body * 2 && lowerWick < body * 0.5 && bodyRatio < 0.3) {
    const bodyPosition = (current.high - Math.max(current.open, current.close)) / range;
    if (bodyPosition > 0.6) { // Corpo na parte inferior
      // Shooting Star √© sempre bearish - revers√£o de alta para baixa
      return 'Shooting Star';
    }
  }

  // ‚úÖ ENGULFING: Corpo atual engolfa completamente o anterior (high + low)
  if (prev) {
    const prevBody = Math.abs(prev.close - prev.open);
    const currentBody = Math.abs(current.close - current.open);

    if (currentBody > prevBody * 1.5) {
      // Bullish Engulfing: atual engolfa bearish anterior
      if (current.close > current.open && prev.close < prev.open &&
        current.high > prev.high && current.low < prev.low) {
        return 'Bullish Engulfing';
      }
      // Bearish Engulfing: atual engolfa bullish anterior
      if (current.close < current.open && prev.close > prev.open &&
        current.high > prev.high && current.low < prev.low) {
        return 'Bearish Engulfing';
      }
    }
  }

  return null;
}

/**
 * Detecta padr√µes SMC (Smart Money Concepts) com l√≥gica correta
 */

/**
 * ‚úÖ NOVA FUN√á√ÉO: Identifica se um padr√£o deve entrar NO 1¬∫ TOQUE da zona
 * Ideal para scalping em consolida√ß√£o - captura movimento dentro do range
 * Order Block e FVG ‚Üí entrar imediatamente quando toca a zona
 */
function patternRequiresFirstTouch(patternName) {
  if (!patternName) return false;

  const normalized = String(patternName).toLowerCase();

  // üü¢ PADR√ïES QUE ENTRAM NO 1¬∫ TOQUE (melhor R:R em dias de consolida√ß√£o)
  const firstTouchPatterns = [
    'order block', 'orderblock', 'ob bullish', 'ob bearish',
    'fvg', 'fair value gap', 'fairvaluegap'
  ];

  return firstTouchPatterns.some(pattern => normalized.includes(pattern));
}

/**
 * ‚úÖ FUN√á√ÉO H√çBRIDA: Decide estrat√©gia baseado no padr√£o + regime de mercado
 * - Consolida√ß√£o + OB/FVG ‚Üí 1¬∫ toque (captura range interno)
 * - Tend√™ncia + OB/FVG ‚Üí ainda 1¬∫ toque (zona institucional)
 * - Breakout patterns ‚Üí sempre confirma√ß√£o
 */
function getEntryStrategy(patternName, marketRegime) {
  const normalized = String(patternName || '').toLowerCase();
  const isConsolidation = marketRegime === 'CONSOLIDATION' || marketRegime === 'consolidation';

  // OB/FVG: sempre 1¬∫ toque (s√£o zonas de liquidez institucional)
  if (patternRequiresFirstTouch(patternName)) {
    return {
      strategy: 'FIRST_TOUCH',
      reason: isConsolidation
        ? 'OB/FVG em consolida√ß√£o - captura range interno'
        : 'OB/FVG em tend√™ncia - zona institucional'
    };
  }

  // Breakout patterns: sempre confirma√ß√£o
  if (patternRequiresRetest(patternName)) {
    return {
      strategy: 'CONFIRMATION',
      reason: 'Padr√£o de breakout - aguardar confirma√ß√£o'
    };
  }

  // Candlestick patterns em consolida√ß√£o: 1¬∫ toque
  const candlestickPatterns = ['hammer', 'shooting star', 'doji', 'engulfing', 'morning star', 'evening star'];
  if (isConsolidation && candlestickPatterns.some(p => normalized.includes(p))) {
    return {
      strategy: 'FIRST_TOUCH',
      reason: 'Candlestick em consolida√ß√£o - entrada imediata'
    };
  }

  // Default: confirma√ß√£o
  return {
    strategy: 'CONFIRMATION',
    reason: 'Estrat√©gia padr√£o - aguardar confirma√ß√£o'
  };
}

/**
 * ‚úÖ NOVA FUN√á√ÉO: Identifica se um padr√£o precisa aguardar reteste/pullback
 * Retorna true se o padr√£o deve aguardar reteste antes de entrar
 * ‚úÖ MUDAN√áA: Order Block e FVG REMOVIDOS - agora usam 1¬∫ toque
 */
function patternRequiresRetest(patternName) {
  if (!patternName) return false;

  const normalized = String(patternName).toLowerCase();

  // üî¥ PADR√ïES QUE PRECISAM AGUARDAR PULLBACK/RETESTE (breakout patterns)
  // ‚úÖ REMOVIDO: Order Block e FVG (agora usam 1¬∫ toque)
  const retestPatterns = [
    'bos', 'break of structure', 'breakofstructure',
    'choch', 'change of character', 'changeofcharacter',
    'tri√¢ngulo', 'triangle', 'triangulo',
    'bandeira', 'flag',
    'fl√¢mula', 'pennant', 'flamula',
    'cunha', 'wedge',
    'ret√¢ngulo', 'rectangle', 'range', 'retangulo',
    'head and shoulders', 'head & shoulders', 'h&s',
    'duplo topo', 'double top', 'triplo topo', 'triple top',
    'duplo fundo', 'double bottom', 'triplo fundo', 'triple bottom'
    // ‚ùå REMOVIDO: 'order block', 'orderblock', 'ob bullish', 'ob bearish'
    // ‚ùå REMOVIDO: 'fvg', 'fair value gap', 'fairvaluegap'
  ];

  return retestPatterns.some(pattern => normalized.includes(pattern));
}

/**
 * ‚úÖ NOVA FUN√á√ÉO: Calcula o pre√ßo de entrada no in√≠cio do padr√£o (mais preciso)
 * Para padr√µes com score >= 55, usa o in√≠cio do padr√£o ao inv√©s do pre√ßo atual
 * Retorna o pre√ßo ideal baseado no in√≠cio da forma√ß√£o do padr√£o
 */
function calculatePatternStartEntryPrice(patternName, candles, signalType, currentPrice) {
  if (!patternName || !candles || candles.length < 5) {
    return currentPrice; // Fallback: usar pre√ßo atual
  }

  const normalized = String(patternName).toLowerCase();
  const isBullish = signalType === 'BUY';
  const isBearish = signalType === 'SELL';

  try {
    // üéØ RANGE: Segundo toque (reteste) - mais preciso tecnicamente
    if (normalized.includes('ret√¢ngulo') || normalized.includes('rectangle') || normalized.includes('range') || normalized.includes('retangulo')) {
      if (candles.length >= 12) {
        const last12 = candles.slice(-12);
        const highs = last12.map(c => Number(c.high) || 0);
        const lows = last12.map(c => Number(c.low) || 0);
        const maxHigh = Math.max(...highs);
        const minLow = Math.min(...lows);
        const range = maxHigh - minLow;
        const tolerance = range * 0.02; // 2% de toler√¢ncia

        // Encontrar toques no topo e fundo
        const topTouches: number[] = [];
        const bottomTouches: number[] = [];

        for (let i = 0; i < last12.length; i++) {
          const candle = last12[i];
          const candleHigh = Number(candle.high) || 0;
          const candleLow = Number(candle.low) || 0;

          if (Math.abs(candleHigh - maxHigh) < tolerance) {
            topTouches.push(candleHigh);
          }
          if (Math.abs(candleLow - minLow) < tolerance) {
            bottomTouches.push(candleLow);
          }
        }

        // ‚úÖ ESTRAT√âGIA MAIS PRECISA: Segundo toque (reteste confirma n√≠vel)
        if (isBullish && bottomTouches.length >= 2) {
          // BUY: Segundo fundo do range (reteste do suporte - mais preciso)
          return bottomTouches[1]; // Segundo toque
        } else if (isBearish && topTouches.length >= 2) {
          // SELL: Segundo topo do range (reteste da resist√™ncia - mais preciso)
          return topTouches[1]; // Segundo toque
        } else if (isBullish && bottomTouches.length >= 1) {
          // Fallback: Primeiro fundo se s√≥ houver 1 toque
          return bottomTouches[0];
        } else if (isBearish && topTouches.length >= 1) {
          // Fallback: Primeiro topo se s√≥ houver 1 toque
          return topTouches[0];
        }
      }
    }

    // üéØ CHoCH: Primeiro candle da mudan√ßa (onde ocorre a revers√£o)
    if (normalized.includes('choch') || normalized.includes('change of character')) {
      if (candles.length >= 10) {
        const last10 = candles.slice(-10);
        // Primeiro candle da segunda metade (√≠ndice 5) - onde ocorre a mudan√ßa
        const changeCandle = last10[5];
        if (changeCandle) {
          // Usar pre√ßo de fechamento do candle da mudan√ßa
          return Number(changeCandle.close) || currentPrice;
        }
      }
    }

    // üéØ BOS: Primeiro candle ap√≥s rompimento (in√≠cio da nova estrutura)
    if (normalized.includes('bos') || normalized.includes('break of structure')) {
      if (candles.length >= 15) {
        const last15 = candles.slice(-15);
        const firstHalf = last15.slice(0, 7);

        const firstMaxHigh = Math.max(...firstHalf.map(c => Number(c.high) || 0));
        const firstMinLow = Math.min(...firstHalf.map(c => Number(c.low) || 0));

        // Encontrar primeiro candle que rompe a estrutura
        for (let i = 7; i < last15.length; i++) {
          const candle = last15[i];
          const candleClose = Number(candle.close) || 0;

          if (isBullish && candleClose > firstMaxHigh) {
            // BUY: Primeiro candle que fecha acima da m√°xima anterior
            return candleClose;
          } else if (isBearish && candleClose < firstMinLow) {
            // SELL: Primeiro candle que fecha abaixo da m√≠nima anterior
            return candleClose;
          }
        }

        // Fallback: usar √∫ltimo candle se n√£o encontrou rompimento claro
        const lastCandle = last15[last15.length - 1];
        const lastClose = Number(lastCandle.close) || 0;
        if (isBullish && lastClose > firstMaxHigh) {
          return lastClose;
        } else if (isBearish && lastClose < firstMinLow) {
          return lastClose;
        }
      }
    }
  } catch (err) {
    console.warn('Erro ao calcular pre√ßo de in√≠cio do padr√£o:', err);
  }

  return currentPrice; // Fallback: usar pre√ßo atual
}

/**
 * ‚úÖ NOVA FUN√á√ÉO: Detecta a zona do Order Block (topo e fundo)
 * Retorna {top, bottom} da zona do OB para c√°lculo de reteste
 */
function detectOrderBlockZone(candles, normalizedPattern) {
  if (!candles || candles.length < 5) return null;

  try {
    const displacement = detectDisplacement(candles);
    if (!displacement) return null;

    const isBullishOB = normalizedPattern.includes('bullish') || displacement.direction === 'bullish';
    const isBearishOB = normalizedPattern.includes('bearish') || displacement.direction === 'bearish';

    // Procurar √∫ltima vela contr√°ria antes do movimento (a vela do Order Block)
    for (let i = candles.length - 2; i >= 1; i--) {
      const candle = candles[i];
      const nextCandle = candles[i + 1];

      // Verificar se √© vela contr√°ria ao movimento
      const isContrary = (displacement.direction === 'bullish' && candle.close < candle.open) ||
        (displacement.direction === 'bearish' && candle.close > candle.open);

      if (isContrary) {
        // Verificar se h√° movimento forte ap√≥s
        const movementAfter = Math.abs(nextCandle.close - candle.close);
        const candleRange = candle.high - candle.low;

        if (movementAfter > candleRange * 1.5) {
          // Esta √© a vela do Order Block
          // Retornar topo e fundo da vela (zona do OB)
          return {
            top: Number(candle.high) || 0,
            bottom: Number(candle.low) || 0,
            direction: displacement.direction
          };
        }
      }
    }
  } catch (error) {
    console.warn('‚ö†Ô∏è Erro ao detectar Order Block Zone:', error);
  }

  return null;
}

/**
 * ‚úÖ NOVO: Detecta se h√° RETESTE (2¬∫ toque) em zona de suporte/resist√™ncia
 * Reteste v√°lido = pre√ßo tocou zona pela 2¬™ vez + tem vela de revers√£o
 * @returns { isRetest: boolean, zone: 'support'|'resistance', touchCount: number }
 */
function detectRetest(candles: any[], zone: { top: number; bottom: number; direction?: string }): {
  isRetest: boolean;
  zoneType: 'support' | 'resistance' | null;
  touchCount: number;
  hasReversalCandle: boolean;
} {
  if (!candles || candles.length < 10 || !zone) {
    return { isRetest: false, zoneType: null, touchCount: 0, hasReversalCandle: false };
  }

  try {
    let touchCount = 0;
    let lastTouchIndex = -1;
    const tolerance = (zone.top - zone.bottom) * 0.5; // 50% da zona como toler√¢ncia

    // Contar quantas vezes o pre√ßo tocou a zona
    for (let i = 0; i < candles.length; i++) {
      const candle = candles[i];
      const low = Number(candle.low || candle[3]) || 0;
      const high = Number(candle.high || candle[2]) || 0;

      // Verificar se tocou zona de suporte (parte inferior)
      const touchedSupport = low <= zone.bottom + tolerance && low >= zone.bottom - tolerance;
      // Verificar se tocou zona de resist√™ncia (parte superior)
      const touchedResistance = high >= zone.top - tolerance && high <= zone.top + tolerance;

      if (touchedSupport || touchedResistance) {
        touchCount++;
        lastTouchIndex = i;
      }
    }

    // √â reteste se tocou >= 2 vezes
    const isRetest = touchCount >= 2 && lastTouchIndex >= candles.length - 3; // Toque recente (√∫ltimas 3 velas)

    // Detectar vela de revers√£o no √∫ltimo toque
    let hasReversalCandle = false;
    if (lastTouchIndex >= 0 && lastTouchIndex < candles.length) {
      const touchCandle = candles[lastTouchIndex];
      const open = Number(touchCandle.open || touchCandle[1]) || 0;
      const close = Number(touchCandle.close || touchCandle[4]) || 0;
      const high = Number(touchCandle.high || touchCandle[2]) || 0;
      const low = Number(touchCandle.low || touchCandle[3]) || 0;
      const body = Math.abs(close - open);
      const totalRange = high - low;

      // Vela de revers√£o: corpo pequeno + sombra longa na dire√ß√£o oposta
      const hasLongLowerShadow = (Math.min(open, close) - low) > body * 2;
      const hasLongUpperShadow = (high - Math.max(open, close)) > body * 2;

      hasReversalCandle = hasLongLowerShadow || hasLongUpperShadow;
    }

    // Determinar tipo de zona
    const lastLow = Number(candles[candles.length - 1].low || candles[candles.length - 1][3]) || 0;
    const zoneType = lastLow <= zone.bottom + tolerance ? 'support' : 'resistance';

    if (isRetest) {
      console.log(`üîÑ [RETEST] Detectado ${touchCount}¬∫ toque em ${zoneType} | Revers√£o: ${hasReversalCandle ? 'SIM' : 'N√ÉO'}`);
    }

    return { isRetest, zoneType, touchCount, hasReversalCandle };
  } catch (error) {
    console.warn('‚ö†Ô∏è Erro ao detectar reteste:', error);
    return { isRetest: false, zoneType: null, touchCount: 0, hasReversalCandle: false };
  }
}

/**
 * ‚úÖ NOVO: Valida se um ROMPIMENTO √© real ou falso (violinada)
 * Rompimento v√°lido = fechamento fora da zona + 2 velas consecutivas + volume acima da m√©dia
 * @returns { isValidBreakout: boolean, confirmation: 'strong'|'weak'|'none' }
 */
function validateBreakout(candles: any[], zone: { top: number; bottom: number }, direction: 'BUY' | 'SELL'): {
  isValidBreakout: boolean;
  confirmation: 'strong' | 'weak' | 'none';
  consecutiveCandles: number;
  volumeAboveAvg: boolean;
} {
  if (!candles || candles.length < 5 || !zone) {
    return { isValidBreakout: false, confirmation: 'none', consecutiveCandles: 0, volumeAboveAvg: false };
  }

  try {
    const recentCandles = candles.slice(-5);
    let consecutiveCandles = 0;

    // Calcular volume m√©dio
    const volumes = candles.slice(-20).map(c => Number(c.volume || c[5]) || 0);
    const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;

    // Verificar velas consecutivas fora da zona
    for (let i = 0; i < recentCandles.length; i++) {
      const candle = recentCandles[i];
      const close = Number(candle.close || candle[4]) || 0;

      if (direction === 'BUY') {
        // Rompimento de alta: fechamento acima da resist√™ncia
        if (close > zone.top) {
          consecutiveCandles++;
        } else {
          consecutiveCandles = 0; // Resetar se voltou para dentro
        }
      } else {
        // Rompimento de baixa: fechamento abaixo do suporte
        if (close < zone.bottom) {
          consecutiveCandles++;
        } else {
          consecutiveCandles = 0; // Resetar se voltou para dentro
        }
      }
    }

    // Verificar volume da √∫ltima vela
    const lastVolume = Number(recentCandles[recentCandles.length - 1].volume || recentCandles[recentCandles.length - 1][5]) || 0;
    const volumeAboveAvg = lastVolume > avgVolume * 1.2; // 20% acima da m√©dia

    // Determinar confirma√ß√£o
    let confirmation: 'strong' | 'weak' | 'none' = 'none';
    let isValidBreakout = false;

    if (consecutiveCandles >= 2 && volumeAboveAvg) {
      confirmation = 'strong';
      isValidBreakout = true;
    } else if (consecutiveCandles >= 2 || volumeAboveAvg) {
      confirmation = 'weak';
      isValidBreakout = consecutiveCandles >= 2; // Pelo menos 2 velas necess√°rias
    }

    if (isValidBreakout) {
      console.log(`üöÄ [BREAKOUT] ${direction} validado | Velas: ${consecutiveCandles} | Volume: ${volumeAboveAvg ? 'ACIMA' : 'NORMAL'} | Confirma√ß√£o: ${confirmation.toUpperCase()}`);
    } else {
      console.log(`‚ö†Ô∏è [BREAKOUT] ${direction} N√ÉO confirmado | Velas: ${consecutiveCandles} | Volume: ${volumeAboveAvg ? 'ACIMA' : 'NORMAL'}`);
    }

    return { isValidBreakout, confirmation, consecutiveCandles, volumeAboveAvg };
  } catch (error) {
    console.warn('‚ö†Ô∏è Erro ao validar breakout:', error);
    return { isValidBreakout: false, confirmation: 'none', consecutiveCandles: 0, volumeAboveAvg: false };
  }
}

/**
 * ‚úÖ NOVO: Detecta TRAP (armadilha) ou violinada
 * Trap = rompeu zona mas retornou para dentro em ‚â§3 velas + volume baixo + sombra longa
 * @returns { isTrap: boolean, trapType: 'bull_trap'|'bear_trap'|null }
 */
function detectTrap(candles: any[], zone: { top: number; bottom: number }): {
  isTrap: boolean;
  trapType: 'bull_trap' | 'bear_trap' | null;
  returnedWithinCandles: number;
  hasLongWick: boolean;
} {
  if (!candles || candles.length < 5 || !zone) {
    return { isTrap: false, trapType: null, returnedWithinCandles: 0, hasLongWick: false };
  }

  try {
    const recentCandles = candles.slice(-5);
    let brokeUp = false;
    let brokeDown = false;
    let breakIndex = -1;
    let returnedWithinCandles = 0;
    let currentlyInside = false;

    // Verificar se houve rompimento e retorno
    for (let i = 0; i < recentCandles.length; i++) {
      const candle = recentCandles[i];
      const high = Number(candle.high || candle[2]) || 0;
      const low = Number(candle.low || candle[3]) || 0;
      const close = Number(candle.close || candle[4]) || 0;

      // Detectar rompimento para cima
      if (high > zone.top && !brokeUp) {
        brokeUp = true;
        breakIndex = i;
      }

      // Detectar rompimento para baixo
      if (low < zone.bottom && !brokeDown) {
        brokeDown = true;
        breakIndex = i;
      }

      // Verificar se retornou para dentro da zona
      if ((brokeUp || brokeDown) && close >= zone.bottom && close <= zone.top) {
        currentlyInside = true;
        returnedWithinCandles = i - breakIndex;
      }
    }

    // Verificar sombra longa na vela de rompimento
    let hasLongWick = false;
    if (breakIndex >= 0 && breakIndex < recentCandles.length) {
      const breakCandle = recentCandles[breakIndex];
      const open = Number(breakCandle.open || breakCandle[1]) || 0;
      const close = Number(breakCandle.close || breakCandle[4]) || 0;
      const high = Number(breakCandle.high || breakCandle[2]) || 0;
      const low = Number(breakCandle.low || breakCandle[3]) || 0;
      const body = Math.abs(close - open);

      // Sombra longa = sombra > 2x o corpo
      const upperWick = high - Math.max(open, close);
      const lowerWick = Math.min(open, close) - low;
      hasLongWick = upperWick > body * 2 || lowerWick > body * 2;
    }

    // Determinar se √© trap
    const isTrap = (brokeUp || brokeDown) && currentlyInside && returnedWithinCandles <= 3;
    let trapType: 'bull_trap' | 'bear_trap' | null = null;

    if (isTrap) {
      trapType = brokeUp ? 'bull_trap' : 'bear_trap';
      console.log(`ü™§ [TRAP] ${trapType.toUpperCase()} detectado! Retornou em ${returnedWithinCandles} velas | Sombra longa: ${hasLongWick ? 'SIM' : 'N√ÉO'}`);
    }

    return { isTrap, trapType, returnedWithinCandles, hasLongWick };
  } catch (error) {
    console.warn('‚ö†Ô∏è Erro ao detectar trap:', error);
    return { isTrap: false, trapType: null, returnedWithinCandles: 0, hasLongWick: false };
  }
}

/**
 * ‚úÖ NOVO: Valida se h√° CONFLU√äNCIA M√çNIMA para abrir trade
 * Exige pelo menos 2 conflu√™ncias para abrir trade (qualidade > quantidade)
 * Conflu√™ncias poss√≠veis: padr√£o, volume, reteste, suporte/resistencia, momentum
 * @returns { hasMinConfluence: boolean, confluenceCount: number, types: string[] }
 */
function validateMinimumConfluences(params: {
  hasPattern: boolean;
  hasVolumeAboveAvg: boolean;
  hasRetest: boolean;
  hasSupportResistance: boolean;
  hasMomentumAlignment: boolean;
  patternConfidence?: number;
}): {
  hasMinConfluence: boolean;
  confluenceCount: number;
  types: string[];
  shouldProceed: boolean;
} {
  const {
    hasPattern = false,
    hasVolumeAboveAvg = false,
    hasRetest = false,
    hasSupportResistance = false,
    hasMomentumAlignment = false,
    patternConfidence = 0
  } = params;

  const types: string[] = [];

  // Contar conflu√™ncias
  if (hasPattern) types.push('PATTERN');
  if (hasVolumeAboveAvg) types.push('VOLUME');
  if (hasRetest) types.push('RETEST');
  if (hasSupportResistance) types.push('S/R');
  if (hasMomentumAlignment) types.push('MOMENTUM');

  const confluenceCount = types.length;

  // ‚úÖ Regra: M√≠nimo 2 conflu√™ncias OU confidence >= 75%
  const hasMinConfluence = confluenceCount >= 2;
  const hasHighConfidence = patternConfidence >= 75;
  const shouldProceed = hasMinConfluence || hasHighConfidence;

  if (shouldProceed) {
    console.log(`‚úÖ [CONFLUENCE] ${confluenceCount} conflu√™ncias: ${types.join(' + ')}`);
  } else {
    console.log(`‚ö†Ô∏è [CONFLUENCE] Apenas ${confluenceCount} conflu√™ncia(s): ${types.join(' + ')} - Trade bloqueado`);
  }

  return {
    hasMinConfluence,
    confluenceCount,
    types,
    shouldProceed
  };
}

/**
 * ‚úÖ NOVA FUN√á√ÉO: Detecta a zona do FVG (gap)
 * Retorna {top, bottom} do gap do FVG para c√°lculo de reteste
 */
function detectFVGZone(candles, normalizedPattern) {
  if (!candles || candles.length < 5) return null;

  try {
    const isBullishFVG = normalizedPattern.includes('bullish');
    const isBearishFVG = normalizedPattern.includes('bearish');

    // Procurar FVG: 3 candles - high(1) < low(3) OU low(1) > high(3)
    for (let i = 2; i < candles.length; i++) {
      const candle1 = candles[i - 2];
      const candle2 = candles[i - 1]; // Gap
      const candle3 = candles[i];

      // FVG Bullish: high(1) < low(3) e candle2 n√£o preenche
      const bullishFVG = candle1.high < candle3.low &&
        candle2.high < candle3.low &&
        candle2.low > candle1.high;

      // FVG Bearish: low(1) > high(3) e candle2 n√£o preenche
      const bearishFVG = candle1.low > candle3.high &&
        candle2.low > candle3.high &&
        candle2.high < candle1.low;

      if (bullishFVG && (isBullishFVG || !isBearishFVG)) {
        // Gap Bullish: fundo em candle1.high, topo em candle3.low
        return {
          top: Number(candle3.low) || 0,
          bottom: Number(candle1.high) || 0,
          direction: 'bullish'
        };
      }

      if (bearishFVG && (isBearishFVG || !isBullishFVG)) {
        // Gap Bearish: fundo em candle3.high, topo em candle1.low
        return {
          top: Number(candle1.low) || 0,
          bottom: Number(candle3.high) || 0,
          direction: 'bearish'
        };
      }
    }
  } catch (error) {
    console.warn('‚ö†Ô∏è Erro ao detectar FVG Zone:', error);
  }

  return null;
}

/**
 * ‚úÖ NOVA FUN√á√ÉO: Calcula o pre√ßo de reteste ideal para cada padr√£o
 * Retorna o pre√ßo de entrada ideal baseado no reteste da zona
 */
function calculateRetestEntryPrice(patternName, candles, currentPrice, signalType) {
  if (!patternName || !candles || candles.length < 5) {
    return currentPrice; // Fallback: usar pre√ßo atual
  }

  const normalized = String(patternName).toLowerCase();
  const isBullish = signalType === 'BUY';
  const isBearish = signalType === 'SELL';

  try {
    // üî¥ BOS (Break of Structure) - Reteste do topo/fundo rompido
    if (normalized.includes('bos') || normalized.includes('break of structure')) {
      if (candles.length >= 15) {
        const last15 = candles.slice(-15);
        const firstHalf = last15.slice(0, 7);
        const firstMaxHigh = Math.max(...firstHalf.map(c => c.high));
        const firstMinLow = Math.min(...firstHalf.map(c => c.low));

        if (isBearish && currentPrice > firstMaxHigh) {
          // SELL: Reteste do topo rompido
          return firstMaxHigh * 1.001; // Ligeiramente acima para confirma√ß√£o
        } else if (isBullish && currentPrice < firstMinLow) {
          // BUY: Reteste do fundo rompido
          return firstMinLow * 0.999; // Ligeiramente abaixo para confirma√ß√£o
        }
      }
    }

    // üî¥ CHOCH (Change of Character) - Reteste da zona de mudan√ßa
    if (normalized.includes('choch') || normalized.includes('change of character')) {
      if (candles.length >= 10) {
        const last10 = candles.slice(-10);
        const firstHalf = last10.slice(0, 5);
        const secondHalf = last10.slice(5);

        const firstMaxHigh = Math.max(...firstHalf.map(c => c.high));
        const firstMinLow = Math.min(...firstHalf.map(c => c.low));
        const secondMaxHigh = Math.max(...secondHalf.map(c => c.high));
        const secondMinLow = Math.min(...secondHalf.map(c => c.low));

        // Zona de mudan√ßa: entre os dois per√≠odos
        const changeZoneTop = Math.max(firstMaxHigh, secondMaxHigh);
        const changeZoneBottom = Math.min(firstMinLow, secondMinLow);
        const changeZoneMid = (changeZoneTop + changeZoneBottom) / 2;

        if (isBearish) {
          return changeZoneTop * 1.001; // Reteste do topo da mudan√ßa
        } else if (isBullish) {
          return changeZoneBottom * 0.999; // Reteste do fundo da mudan√ßa
        }
      }
    }

    // üî¥ TRI√ÇNGULO - Reteste da linha de suporte/resist√™ncia ap√≥s breakout
    if (normalized.includes('tri√¢ngulo') || normalized.includes('triangle')) {
      if (candles.length >= 10) {
        const peaks = findLocalPeaks(candles);
        const valleys = findLocalValleys(candles);

        if (peaks.length >= 2 && valleys.length >= 2) {
          const highLine = calculateTrendLine(peaks);
          const lowLine = calculateTrendLine(valleys);

          if (highLine && lowLine) {
            const currentIndex = candles.length - 1;
            const resistancePrice = highLine.slope * currentIndex + highLine.intercept;
            const supportPrice = lowLine.slope * currentIndex + lowLine.intercept;

            if (isBearish) {
              return resistancePrice * 1.001; // Reteste da resist√™ncia
            } else if (isBullish) {
              return supportPrice * 0.999; // Reteste do suporte
            }
          }
        }
      }
    }

    // üî¥ BANDEIRA - Reteste do topo/fundo da bandeira ap√≥s breakout
    if (normalized.includes('bandeira') || normalized.includes('flag')) {
      if (candles.length >= 8) {
        const firstHalf = candles.slice(0, Math.floor(candles.length / 2));
        const secondHalf = candles.slice(Math.floor(candles.length / 2));

        const flagTop = Math.max(...secondHalf.map(c => c.high));
        const flagBottom = Math.min(...secondHalf.map(c => c.low));

        if (isBearish) {
          return flagTop * 1.001; // Reteste do topo da bandeira
        } else if (isBullish) {
          return flagBottom * 0.999; // Reteste do fundo da bandeira
        }
      }
    }

    // üî¥ FL√ÇMULA (Pennant) - Similar √† bandeira
    if (normalized.includes('fl√¢mula') || normalized.includes('pennant') || normalized.includes('flamula')) {
      if (candles.length >= 8) {
        const firstHalf = candles.slice(0, Math.floor(candles.length / 2));
        const secondHalf = candles.slice(Math.floor(candles.length / 2));

        const pennantTop = Math.max(...secondHalf.map(c => c.high));
        const pennantBottom = Math.min(...secondHalf.map(c => c.low));

        if (isBearish) {
          return pennantTop * 1.001; // Reteste do topo da fl√¢mula
        } else if (isBullish) {
          return pennantBottom * 0.999; // Reteste do fundo da fl√¢mula
        }
      }
    }

    // üî¥ CUNHA - Reteste da linha de tend√™ncia
    // CORRIGIDO: Reconhecer novos nomes com dire√ß√£o
    if (normalized.includes('cunha') || normalized.includes('wedge')) {
      if (candles.length >= 10) {
        const peaks = findLocalPeaks(candles);
        const valleys = findLocalValleys(candles);

        if (peaks.length >= 2 && valleys.length >= 2) {
          const highLine = calculateTrendLine(peaks);
          const lowLine = calculateTrendLine(valleys);

          if (highLine && lowLine) {
            const currentIndex = candles.length - 1;
            const resistancePrice = highLine.slope * currentIndex + highLine.intercept;
            const supportPrice = lowLine.slope * currentIndex + lowLine.intercept;

            if (isBearish) {
              return resistancePrice * 1.001; // Reteste da linha superior
            } else if (isBullish) {
              return supportPrice * 0.999; // Reteste da linha inferior
            }
          }
        }
      }
    }

    // üî¥ RET√ÇNGULO/RANGE - Reteste do topo/fundo do range
    if (normalized.includes('ret√¢ngulo') || normalized.includes('rectangle') || normalized.includes('range') || normalized.includes('retangulo')) {
      if (candles.length >= 12) {
        const last12 = candles.slice(-12);
        const rangeTop = Math.max(...last12.map(c => c.high));
        const rangeBottom = Math.min(...last12.map(c => c.low));

        if (isBearish) {
          return rangeTop * 1.001; // Reteste do topo do range
        } else if (isBullish) {
          return rangeBottom * 0.999; // Reteste do fundo do range
        }
      }
    }

    // üî¥ HEAD & SHOULDERS - Reteste do neckline
    if (normalized.includes('head and shoulders') || normalized.includes('head & shoulders') || normalized.includes('h&s')) {
      if (candles.length >= 15) {
        const peaks = findLocalPeaks(candles);
        const valleys = findLocalValleys(candles);

        if (peaks.length >= 3 && valleys.length >= 2) {
          // Neckline: linha conectando os dois vales entre os ombros
          const lastTwoValleys = valleys.slice(-2);
          if (lastTwoValleys.length === 2) {
            const valley1 = lastTwoValleys[0];
            const valley2 = lastTwoValleys[1];
            const necklinePrice = (valley1.value + valley2.value) / 2;

            // H&S Topo: reteste do neckline ap√≥s romper para baixo
            if (isBearish) {
              return necklinePrice * 1.001;
            }
            // H&S Fundo: reteste do neckline ap√≥s romper para cima
            else if (isBullish) {
              return necklinePrice * 0.999;
            }
          }
        }
      }
    }

    // üî¥ DOUBLE/TRIPLE TOP - Reteste do suporte ap√≥s romper
    if (normalized.includes('duplo topo') || normalized.includes('double top') ||
      normalized.includes('triplo topo') || normalized.includes('triple top')) {
      if (candles.length >= 15) {
        const peaks = findLocalPeaks(candles);
        if (peaks.length >= 2) {
          const lastPeaks = peaks.slice(-2);
          const supportLevel = Math.min(...lastPeaks.map(p => p.value)) * 0.995; // Suporte abaixo dos topos

          if (isBearish) {
            return supportLevel * 1.001; // Reteste do suporte ap√≥s romper
          }
        }
      }
    }

    // üî¥ DOUBLE/TRIPLE BOTTOM - Reteste da resist√™ncia ap√≥s romper
    if (normalized.includes('duplo fundo') || normalized.includes('double bottom') ||
      normalized.includes('triplo fundo') || normalized.includes('triple bottom')) {
      if (candles.length >= 15) {
        const valleys = findLocalValleys(candles);
        if (valleys.length >= 2) {
          const lastValleys = valleys.slice(-2);
          const resistanceLevel = Math.max(...lastValleys.map(v => v.value)) * 1.005; // Resist√™ncia acima dos fundos

          if (isBullish) {
            return resistanceLevel * 0.999; // Reteste da resist√™ncia ap√≥s romper
          }
        }
      }
    }

    // ‚úÖ NOVO: ORDER BLOCK - Reteste da zona do OB (entrada no extremo oposto)
    if (normalized.includes('order block') || normalized.includes('orderblock') || normalized.includes('ob')) {
      const obZone = detectOrderBlockZone(candles, normalized);
      if (obZone) {
        if (isBullish && obZone.top) {
          // Order Block Bullish: entrada no TOPO do OB (zona de suporte)
          // Pre√ßo retorna ao topo do OB antes de continuar alta
          return obZone.top * 0.999; // Ligeiramente abaixo do topo para confirma√ß√£o
        } else if (isBearish && obZone.bottom) {
          // Order Block Bearish: entrada no FUNDO do OB (zona de resist√™ncia)
          // Pre√ßo retorna ao fundo do OB antes de continuar baixa
          return obZone.bottom * 1.001; // Ligeiramente acima do fundo para confirma√ß√£o
        }
      }
    }

    // ‚úÖ NOVO: FVG (Fair Value Gap) - Reteste/preenchimento do gap
    if (normalized.includes('fvg') || normalized.includes('fair value gap') || normalized.includes('fairvaluegap')) {
      const fvgZone = detectFVGZone(candles, normalized);
      if (fvgZone) {
        // Entrada quando pre√ßo preenche 50% do gap (meio do FVG)
        const midFVG = (fvgZone.top + fvgZone.bottom) / 2;
        if (isBullish || isBearish) {
          // Tanto para BUY quanto SELL, entrada no meio do gap (50% preenchido)
          return midFVG;
        }
      }
    }

  } catch (error) {
    console.warn('‚ö†Ô∏è Erro ao calcular reteste:', error);
  }

  // Fallback: retornar pre√ßo atual se n√£o conseguir calcular reteste
  return currentPrice;
}

/**
 * ‚úÖ NOVA FUN√á√ÉO: Verifica se o pre√ßo atual est√° pr√≥ximo da zona de reteste
 * Retorna true se est√° dentro de uma toler√¢ncia aceit√°vel para entrar
 */
function isPriceNearRetestZone(retestPrice, currentPrice, tolerancePct = 0.5) {
  if (!retestPrice || !currentPrice) return false;

  const diff = Math.abs(currentPrice - retestPrice);
  const tolerance = retestPrice * (tolerancePct / 100);

  return diff <= tolerance;
}

/**
 * ‚úÖ NOVA FUN√á√ÉO: Calcula stop loss baseado na zona de invalida√ß√£o do padr√£o
 * Para padr√µes com reteste/rompimento, o stop fica mais pr√≥ximo da zona de invalida√ß√£o
 * Retorna o stop price ideal ou null se n√£o conseguir calcular
 */
function calculatePatternStopPrice(patternName, candles, entryPrice, signalType) {
  if (!patternName || !candles || candles.length < 5 || !entryPrice) {
    return null;
  }

  const normalized = String(patternName).toLowerCase();
  const isBullish = signalType === 'BUY';
  const isBearish = signalType === 'SELL';

  try {
    // üî¥ BOS (Break of Structure) - Stop logo abaixo/acima do n√≠vel rompido
    if (normalized.includes('bos') || normalized.includes('break of structure')) {
      if (candles.length >= 15) {
        const last15 = candles.slice(-15);
        const firstHalf = last15.slice(0, 7);
        const firstMaxHigh = Math.max(...firstHalf.map(c => Number(c.high) || 0));
        const firstMinLow = Math.min(...firstHalf.map(c => Number(c.low) || 0));

        if (isBullish) {
          // BUY: Stop logo abaixo do fundo rompido (zona de invalida√ß√£o)
          return firstMinLow * 0.995; // ‚úÖ CORRE√á√ÉO: 0.5% abaixo para dar margem adequada (aumentado de 0.2%)
        } else if (isBearish) {
          // SELL: Stop logo acima do topo rompido (zona de invalida√ß√£o)
          return firstMaxHigh * 1.005; // ‚úÖ CORRE√á√ÉO: 0.5% acima para dar margem adequada (aumentado de 0.2%)
        }
      }
    }

    // üî¥ CHOCH (Change of Character) - Stop na zona de mudan√ßa
    if (normalized.includes('choch') || normalized.includes('change of character')) {
      if (candles.length >= 10) {
        const last10 = candles.slice(-10);
        const firstHalf = last10.slice(0, 5);
        const secondHalf = last10.slice(5);

        const firstMaxHigh = Math.max(...firstHalf.map(c => Number(c.high) || 0));
        const firstMinLow = Math.min(...firstHalf.map(c => Number(c.low) || 0));
        const secondMaxHigh = Math.max(...secondHalf.map(c => Number(c.high) || 0));
        const secondMinLow = Math.min(...secondHalf.map(c => Number(c.low) || 0));

        const changeZoneTop = Math.max(firstMaxHigh, secondMaxHigh);
        const changeZoneBottom = Math.min(firstMinLow, secondMinLow);

        if (isBullish) {
          // BUY: Stop logo abaixo do fundo da zona de mudan√ßa
          return changeZoneBottom * 0.995; // ‚úÖ CORRE√á√ÉO: 0.5% abaixo (aumentado de 0.2%)
        } else if (isBearish) {
          // SELL: Stop logo acima do topo da zona de mudan√ßa
          return changeZoneTop * 1.005; // ‚úÖ CORRE√á√ÉO: 0.5% acima (aumentado de 0.2%)
        }
      }
    }

    // üéØ RANGE/RET√ÇNGULO - Stop no extremo oposto do range
    if (normalized.includes('ret√¢ngulo') || normalized.includes('rectangle') || normalized.includes('range') || normalized.includes('retangulo')) {
      if (candles.length >= 12) {
        const last12 = candles.slice(-12);
        const highs = last12.map(c => Number(c.high) || 0);
        const lows = last12.map(c => Number(c.low) || 0);
        const rangeTop = Math.max(...highs);
        const rangeBottom = Math.min(...lows);

        if (isBullish) {
          // BUY: Stop logo abaixo do fundo do range
          return rangeBottom * 0.995; // ‚úÖ CORRE√á√ÉO: 0.5% abaixo (aumentado de 0.2%)
        } else if (isBearish) {
          // SELL: Stop logo acima do topo do range
          return rangeTop * 1.005; // ‚úÖ CORRE√á√ÉO: 0.5% acima (aumentado de 0.2%)
        }
      }
    }

    // üî∫ TRI√ÇNGULO - Stop no extremo oposto do tri√¢ngulo
    if (normalized.includes('tri√¢ngulo') || normalized.includes('triangle') || normalized.includes('triangulo')) {
      if (candles.length >= 10) {
        const last10 = candles.slice(-10);
        const highs = last10.map(c => Number(c.high) || 0);
        const lows = last10.map(c => Number(c.low) || 0);
        const triangleTop = Math.max(...highs);
        const triangleBottom = Math.min(...lows);

        if (isBullish) {
          // BUY: Stop logo abaixo do fundo do tri√¢ngulo
          return triangleBottom * 0.995; // ‚úÖ CORRE√á√ÉO: 0.5% abaixo (aumentado de 0.2%)
        } else if (isBearish) {
          // SELL: Stop logo acima do topo do tri√¢ngulo
          return triangleTop * 1.005; // ‚úÖ CORRE√á√ÉO: 0.5% acima (aumentado de 0.2%)
        }
      }
    }

    // ‚úÖ ORDER BLOCK - Stop no extremo oposto do OB
    if (normalized.includes('order block') || normalized.includes('orderblock') || normalized.includes('ob')) {
      const obZone = detectOrderBlockZone(candles, normalized);
      if (obZone) {
        if (isBullish && obZone.bottom) {
          // BUY: Stop logo abaixo do fundo do OB
          return obZone.bottom * 0.995; // ‚úÖ CORRE√á√ÉO: 0.5% abaixo (aumentado de 0.2%)
        } else if (isBearish && obZone.top) {
          // SELL: Stop logo acima do topo do OB
          return obZone.top * 1.005; // ‚úÖ CORRE√á√ÉO: 0.5% acima (aumentado de 0.2%)
        }
      }
    }

    // ‚úÖ FVG (Fair Value Gap) - Stop no extremo oposto do gap
    if (normalized.includes('fvg') || normalized.includes('fair value gap') || normalized.includes('fairvaluegap')) {
      const fvgZone = detectFVGZone(candles, normalized);
      if (fvgZone) {
        if (isBullish) {
          // BUY: Stop logo abaixo do fundo do FVG
          return fvgZone.bottom * 0.995; // ‚úÖ CORRE√á√ÉO: 0.5% abaixo (aumentado de 0.2%)
        } else if (isBearish) {
          // SELL: Stop logo acima do topo do FVG
          return fvgZone.top * 1.005; // ‚úÖ CORRE√á√ÉO: 0.5% acima (aumentado de 0.2%)
        }
      }
    }

  } catch (error) {
    console.warn('‚ö†Ô∏è Erro ao calcular stop do padr√£o:', error);
  }

  return null; // N√£o conseguiu calcular baseado no padr√£o
}

/**
 * ‚úÖ NOVA FUN√á√ÉO: Detecta se h√° rompimento (breakout) para padr√µes que requerem confirma√ß√£o
 * Retorna o pre√ßo de entrada no rompimento se detectado, ou null se n√£o houver rompimento
 */
function detectBreakoutEntryPrice(patternName, candles, signalType, currentPrice) {
  if (!patternName || !candles || candles.length < 5) {
    return null;
  }

  const normalized = String(patternName).toLowerCase();
  const isBullish = signalType === 'BUY';
  const isBearish = signalType === 'SELL';

  try {
    // üî¥ BOS (Break of Structure) - Entrada no rompimento
    if (normalized.includes('bos') || normalized.includes('break of structure')) {
      if (candles.length >= 15) {
        const last15 = candles.slice(-15);
        const firstHalf = last15.slice(0, 7);
        const firstMaxHigh = Math.max(...firstHalf.map(c => Number(c.high) || 0));
        const firstMinLow = Math.min(...firstHalf.map(c => Number(c.low) || 0));
        const currentCandle = last15[last15.length - 1];
        const currentClose = Number(currentCandle.close) || 0;

        if (isBullish && currentClose > firstMaxHigh) {
          // BUY: Rompimento acima da m√°xima anterior ‚Üí entrar no rompimento
          return currentClose;
        } else if (isBearish && currentClose < firstMinLow) {
          // SELL: Rompimento abaixo da m√≠nima anterior ‚Üí entrar no rompimento
          return currentClose;
        }
      }
    }

    // üéØ RANGE/RET√ÇNGULO - Entrada no rompimento do range
    if (normalized.includes('ret√¢ngulo') || normalized.includes('rectangle') || normalized.includes('range') || normalized.includes('retangulo')) {
      if (candles.length >= 12) {
        const last12 = candles.slice(-12);
        const highs = last12.map(c => Number(c.high) || 0);
        const lows = last12.map(c => Number(c.low) || 0);
        const rangeTop = Math.max(...highs);
        const rangeBottom = Math.min(...lows);
        const currentCandle = last12[last12.length - 1];
        const currentClose = Number(currentCandle.close) || 0;

        if (isBullish && currentClose > rangeTop) {
          // BUY: Rompimento acima do topo do range ‚Üí entrar no rompimento
          return currentClose;
        } else if (isBearish && currentClose < rangeBottom) {
          // SELL: Rompimento abaixo do fundo do range ‚Üí entrar no rompimento
          return currentClose;
        }
      }
    }

    // üî∫ TRI√ÇNGULO - Entrada no rompimento do tri√¢ngulo
    if (normalized.includes('tri√¢ngulo') || normalized.includes('triangle') || normalized.includes('triangulo')) {
      if (candles.length >= 10) {
        const last10 = candles.slice(-10);
        const highs = last10.map(c => Number(c.high) || 0);
        const lows = last10.map(c => Number(c.low) || 0);
        const triangleTop = Math.max(...highs);
        const triangleBottom = Math.min(...lows);
        const currentCandle = last10[last10.length - 1];
        const currentClose = Number(currentCandle.close) || 0;

        if (isBullish && currentClose > triangleTop) {
          // BUY: Rompimento acima do topo do tri√¢ngulo ‚Üí entrar no rompimento
          return currentClose;
        } else if (isBearish && currentClose < triangleBottom) {
          // SELL: Rompimento abaixo do fundo do tri√¢ngulo ‚Üí entrar no rompimento
          return currentClose;
        }
      }
    }

    // üö© BANDEIRA/FL√ÇMULA - Entrada no rompimento da bandeira
    if (normalized.includes('bandeira') || normalized.includes('flag') || normalized.includes('fl√¢mula') || normalized.includes('pennant') || normalized.includes('flamula')) {
      if (candles.length >= 8) {
        const last8 = candles.slice(-8);
        const highs = last8.map(c => Number(c.high) || 0);
        const lows = last8.map(c => Number(c.low) || 0);
        const flagTop = Math.max(...highs);
        const flagBottom = Math.min(...lows);
        const currentCandle = last8[last8.length - 1];
        const currentClose = Number(currentCandle.close) || 0;

        if (isBullish && currentClose > flagTop) {
          // BUY: Rompimento acima do topo da bandeira ‚Üí entrar no rompimento
          return currentClose;
        } else if (isBearish && currentClose < flagBottom) {
          // SELL: Rompimento abaixo do fundo da bandeira ‚Üí entrar no rompimento
          return currentClose;
        }
      }
    }

  } catch (error) {
    console.warn('‚ö†Ô∏è Erro ao detectar rompimento:', error);
  }

  return null; // N√£o h√° rompimento detectado
}

function detectSMCPatterns(candles) {
  if (candles.length < 5) return null;

  // ‚úÖ FVG: 3 candles - high(1) < low(3) OU low(1) > high(3)
  for (let i = 2; i < candles.length; i++) {
    const candle1 = candles[i - 2];
    const candle2 = candles[i - 1]; // Gap
    const candle3 = candles[i];

    // FVG Bullish: high(1) < low(3) e candle2 n√£o preenche
    const bullishFVG = candle1.high < candle3.low &&
      candle2.high < candle3.low &&
      candle2.low > candle1.high;

    // FVG Bearish: low(1) > high(3) e candle2 n√£o preenche
    const bearishFVG = candle1.low > candle3.high &&
      candle2.low > candle3.high &&
      candle2.high < candle1.low;

    if (bullishFVG) {
      return 'Fair Value Gap Bullish';
    }
    if (bearishFVG) {
      return 'Fair Value Gap Bearish';
    }
  }

  // ‚úÖ ORDER BLOCK: √öltima vela contr√°ria antes de displacement
  const displacement = detectDisplacement(candles);
  if (displacement) {
    // Procurar √∫ltima vela contr√°ria antes do movimento
    for (let i = candles.length - 2; i >= 1; i--) {
      const candle = candles[i];
      const nextCandle = candles[i + 1];

      // Verificar se √© vela contr√°ria ao movimento
      const isContrary = (displacement.direction === 'bullish' && candle.close < candle.open) ||
        (displacement.direction === 'bearish' && candle.close > candle.open);

      if (isContrary) {
        // Verificar se h√° movimento forte ap√≥s
        const movementAfter = Math.abs(nextCandle.close - candle.close);
        const candleRange = candle.high - candle.low;

        if (movementAfter > candleRange * 1.5) {
          return displacement.direction === 'bullish'
            ? 'Order Block Bullish'
            : 'Order Block Bearish';
        }
      }
    }
  }

  // ‚úÖ BREAK OF STRUCTURE (BOS) - CORRIGIDO: Incluir dire√ß√£o no nome
  if (candles.length >= 15) {
    const last15 = candles.slice(-15);
    const firstHalf = last15.slice(0, 7);
    const secondHalf = last15.slice(7);

    const firstMaxHigh = Math.max(...firstHalf.map(c => c.high));
    const secondMaxHigh = Math.max(...secondHalf.map(c => c.high));
    const firstMinLow = Math.min(...firstHalf.map(c => c.low));
    const secondMinLow = Math.min(...secondHalf.map(c => c.low));
    const current = candles[candles.length - 1];

    // BOS de alta: rompimento de m√°xima anterior ‚Üí BULLISH (BUY)
    if (secondMaxHigh > firstMaxHigh * 1.001 && current.close > firstMaxHigh) {
      return 'Break of Structure Bullish (BOS)';
    }
    // BOS de baixa: rompimento de m√≠nima anterior ‚Üí BEARISH (SELL)
    if (secondMinLow < firstMinLow * 0.999 && current.close < firstMinLow) {
      return 'Break of Structure Bearish (BOS)';
    }
  }

  // ‚úÖ CHANGE OF CHARACTER (CHOCH) - CORRIGIDO: Incluir dire√ß√£o no nome
  if (candles.length >= 10) {
    const last10 = candles.slice(-10);
    const firstHalf = last10.slice(0, 5);
    const secondHalf = last10.slice(5);

    const firstTrend = firstHalf[firstHalf.length - 1].close > firstHalf[0].close;
    const secondTrend = secondHalf[secondHalf.length - 1].close > secondHalf[0].close;

    if (firstTrend !== secondTrend) {
      // Verificar se h√° mudan√ßa significativa
      const firstChange = Math.abs(firstHalf[firstHalf.length - 1].close - firstHalf[0].close);
      const secondChange = Math.abs(secondHalf[secondHalf.length - 1].close - secondHalf[0].close);
      const avgRange = last10.reduce((sum, c) => sum + (c.high - c.low), 0) / last10.length;

      if (firstChange > avgRange * 0.5 && secondChange > avgRange * 0.5) {
        // CHOCH: Mudan√ßa de baixa para alta ‚Üí BULLISH (BUY)
        // CHOCH: Mudan√ßa de alta para baixa ‚Üí BEARISH (SELL)
        if (!firstTrend && secondTrend) {
          // Era baixa, agora √© alta ‚Üí Bullish
          return 'Change of Character Bullish (ChoCh)';
        } else {
          // Era alta, agora √© baixa ‚Üí Bearish (√∫nico caso restante)
          return 'Change of Character Bearish (ChoCh)';
        }
      }
    }
  }

  return null;
}

/**
 * Detecta padr√µes geom√©tricos (Tri√¢ngulos e Cunhas) com c√°lculo real
 */
function detectGeometricPatterns(candles) {
  if (candles.length < 10) return null;

  const peaks = findLocalPeaks(candles);
  const valleys = findLocalValleys(candles);

  if (peaks.length < 2 || valleys.length < 2) return null;

  const highLine = calculateTrendLine(peaks);
  const lowLine = calculateTrendLine(valleys);

  if (!highLine || !lowLine || highLine.rSquared < 0.5 || lowLine.rSquared < 0.5) {
    return null; // Linhas n√£o s√£o confi√°veis
  }

  const convergence = calculateConvergence(highLine, lowLine);
  const parallelism = calculateParallelism(highLine, lowLine);

  // ‚úÖ TRI√ÇNGULO: Linhas convergentes (converg√™ncia > 0.3)
  if (convergence > 0.3) {
    // Tri√¢ngulo Ascendente: High horizontal ou descendo, Low subindo
    if (highLine.slope < 0.0001 && lowLine.slope > 0.0001) {
      return 'Tri√¢ngulo Ascendente';
    }
    // Tri√¢ngulo Descendente: High descendo, Low horizontal ou subindo
    if (highLine.slope < -0.0001 && lowLine.slope < 0.0001) {
      return 'Tri√¢ngulo Descendente';
    }
    // Tri√¢ngulo Sim√©trico: Ambas convergem
    if (convergence > 0.5) {
      return 'Tri√¢ngulo Sim√©trico';
    }
  }

  // ‚úÖ CUNHA: Linhas paralelas inclinadas (paralelismo > 0.7)
  // CORRIGIDO: Cunha Ascendente √© BEARISH (exaust√£o de alta), Cunha Descendente √© BULLISH (exaust√£o de baixa)
  if (parallelism > 0.7) {
    // Cunha Ascendente: Ambas linhas sobem (bearish - exaust√£o de alta)
    if (highLine.slope > 0.0001 && lowLine.slope > 0.0001) {
      return 'Cunha Ascendente Bearish';
    }
    // Cunha Descendente: Ambas linhas descem (bullish - exaust√£o de baixa)
    if (highLine.slope < -0.0001 && lowLine.slope < -0.0001) {
      return 'Cunha Descendente Bullish';
    }
  }

  return null;
}

/**
 * Detecta padr√µes de continua√ß√£o (Bandeiras, Range)
 */
function detectContinuationPatterns(candles) {
  if (candles.length < 8) return null;

  // ‚úÖ BANDEIRA: Impulso seguido de consolida√ß√£o
  const firstHalf = candles.slice(0, Math.floor(candles.length / 2));
  const secondHalf = candles.slice(Math.floor(candles.length / 2));

  const firstHalfRange = Math.max(...firstHalf.map(c => c.high)) - Math.min(...firstHalf.map(c => c.low));
  const secondHalfRange = Math.max(...secondHalf.map(c => c.high)) - Math.min(...secondHalf.map(c => c.low));

  // Verificar se h√° impulso antes da consolida√ß√£o
  const firstTrend = firstHalf[firstHalf.length - 1].close > firstHalf[0].close;
  const impulseMagnitude = Math.abs(firstHalf[firstHalf.length - 1].close - firstHalf[0].close);
  const avgRange = firstHalf.reduce((sum, c) => sum + (c.high - c.low), 0) / firstHalf.length;

  // Consolida√ß√£o ap√≥s impulso significativo
  if (secondHalfRange < firstHalfRange * 0.5 && impulseMagnitude > avgRange * 1.5) {
    return firstTrend ? 'Bandeira de Alta' : 'Bandeira de Baixa';
  }

  // ‚úÖ RANGE: M√∫ltiplos toques em suporte e resist√™ncia
  if (candles.length >= 12) {
    const last12 = candles.slice(-12);
    const highs = last12.map(c => c.high);
    const lows = last12.map(c => c.low);

    const maxHigh = Math.max(...highs);
    const minLow = Math.min(...lows);
    const range = maxHigh - minLow;
    const tolerance = range * 0.02; // 2% de toler√¢ncia

    let touchesTop = 0;
    let touchesBottom = 0;

    for (const candle of last12) {
      if (Math.abs(candle.high - maxHigh) < tolerance) touchesTop++;
      if (Math.abs(candle.low - minLow) < tolerance) touchesBottom++;
    }

    // Range: pelo menos 2 toques em cada n√≠vel e range consistente
    if (touchesTop >= 2 && touchesBottom >= 2) {
      const firstHalfRange2 = Math.max(...last12.slice(0, 6).map(c => c.high)) -
        Math.min(...last12.slice(0, 6).map(c => c.low));
      const secondHalfRange2 = Math.max(...last12.slice(6).map(c => c.high)) -
        Math.min(...last12.slice(6).map(c => c.low));
      const rangeDiff = Math.abs(firstHalfRange2 - secondHalfRange2) / Math.max(firstHalfRange2, secondHalfRange2);

      if (rangeDiff < 0.15) {
        return 'Range';
      }
    }
  }

  return null;
}

/**
 * Detecta padr√µes de revers√£o (Duplo/Triplo Topo/Fundo)
 */
function detectReversalPatterns(candles) {
  if (candles.length < 10) return null; // ‚úÖ Reduzido de 15 para 10 candles

  const peaks = findLocalPeaks(candles);
  const valleys = findLocalValleys(candles);

  // ‚úÖ HEAD & SHOULDERS (Ombro Cabe√ßa Ombro) - PRIORIDADE ALTA
  if (peaks.length >= 3) {
    const lastThreePeaks = peaks.slice(-3);
    const leftShoulder = lastThreePeaks[0];
    const head = lastThreePeaks[1];
    const rightShoulder = lastThreePeaks[2];

    // Cabe√ßa deve ser maior que os ombros
    if (head.value > leftShoulder.value && head.value > rightShoulder.value) {
      // Ombros devem ser similares (toler√¢ncia 1.5% - aumentado de 0.5%)
      const shoulderDiff = Math.abs(leftShoulder.value - rightShoulder.value) / Math.max(leftShoulder.value, rightShoulder.value);
      // Cabe√ßa deve ser pelo menos 0.5% maior que os ombros (reduzido de 1%)
      const headVsLeftShoulder = (head.value - leftShoulder.value) / leftShoulder.value;
      const headVsRightShoulder = (head.value - rightShoulder.value) / rightShoulder.value;

      if (shoulderDiff < 0.015 && headVsLeftShoulder > 0.005 && headVsRightShoulder > 0.005) {
        // Verificar neckline (vales entre os picos)
        const valleyBetweenLeftAndHead = valleys.find(v => v.index > leftShoulder.index && v.index < head.index);
        const valleyBetweenHeadAndRight = valleys.find(v => v.index > head.index && v.index < rightShoulder.index);

        if (valleyBetweenLeftAndHead && valleyBetweenHeadAndRight) {
          console.log(`üéØ [H&S] Head & Shoulders detectado: LS=${leftShoulder.value.toFixed(2)}, H=${head.value.toFixed(2)}, RS=${rightShoulder.value.toFixed(2)}`);
          return 'Head and Shoulders';
        }
      }
    }
  }

  // ‚úÖ INVERSE HEAD & SHOULDERS (Ombro Cabe√ßa Ombro Invertido)
  if (valleys.length >= 3) {
    const lastThreeValleys = valleys.slice(-3);
    const leftShoulder = lastThreeValleys[0];
    const head = lastThreeValleys[1];
    const rightShoulder = lastThreeValleys[2];

    // Cabe√ßa deve ser menor que os ombros (invertido)
    if (head.value < leftShoulder.value && head.value < rightShoulder.value) {
      const shoulderDiff = Math.abs(leftShoulder.value - rightShoulder.value) / Math.max(leftShoulder.value, rightShoulder.value);
      const headVsLeftShoulder = (leftShoulder.value - head.value) / head.value;
      const headVsRightShoulder = (rightShoulder.value - head.value) / head.value;

      if (shoulderDiff < 0.015 && headVsLeftShoulder > 0.005 && headVsRightShoulder > 0.005) {
        const peakBetweenLeftAndHead = peaks.find(p => p.index > leftShoulder.index && p.index < head.index);
        const peakBetweenHeadAndRight = peaks.find(p => p.index > head.index && p.index < rightShoulder.index);

        if (peakBetweenLeftAndHead && peakBetweenHeadAndRight) {
          console.log(`üéØ [H&S] Inverse Head & Shoulders detectado: LS=${leftShoulder.value.toFixed(2)}, H=${head.value.toFixed(2)}, RS=${rightShoulder.value.toFixed(2)}`);
          return 'Inverse Head and Shoulders';
        }
      }
    }
  }

  // ‚úÖ ELLIOTT ABC CORRECTION - NOVO!
  if (peaks.length >= 2 && valleys.length >= 1) {
    // Onda A (impulso down), B (retra√ß√£o up), C (impulso down)
    const recent5 = candles.slice(-5);
    const trend = candles[0].close > candles[candles.length - 1].close ? 'down' : 'up';

    // Verificar se h√° padr√£o ABC (3 ondas corretivas)
    if (peaks.length >= 1 && valleys.length >= 2 && trend === 'down') {
      // ABC bearish: A(down), B(up), C(down)
      const lastValley1 = valleys[valleys.length - 2];
      const lastPeak = peaks[peaks.length - 1];
      const lastValley2 = valleys[valleys.length - 1];

      if (lastValley1 && lastPeak && lastValley2 &&
        lastValley1.index < lastPeak.index && lastPeak.index < lastValley2.index) {
        // B deve retrair entre 38.2% e 78.6% de A (Fibonacci)
        const aMove = lastPeak.value - lastValley1.value;
        const bRetrace = lastPeak.value - lastValley2.value;
        const retraceRatio = bRetrace / aMove;

        if (retraceRatio > 0.382 && retraceRatio < 0.786) {
          console.log(`üåä [Elliott] ABC Correction Bearish detectado: A‚ÜíB retrace ${(retraceRatio * 100).toFixed(1)}%`);
          return 'Elliott ABC Correction Bearish';
        }
      }
    }

    if (valleys.length >= 1 && peaks.length >= 2 && trend === 'up') {
      // ABC bullish: A(up), B(down), C(up)
      const lastPeak1 = peaks[peaks.length - 2];
      const lastValley = valleys[valleys.length - 1];
      const lastPeak2 = peaks[peaks.length - 1];

      if (lastPeak1 && lastValley && lastPeak2 &&
        lastPeak1.index < lastValley.index && lastValley.index < lastPeak2.index) {
        const aMove = lastValley.value - lastPeak1.value;
        const bRetrace = lastPeak2.value - lastValley.value;
        const retraceRatio = Math.abs(bRetrace / aMove);

        if (retraceRatio > 0.382 && retraceRatio < 0.786) {
          console.log(`üåä [Elliott] ABC Correction Bullish detectado: A‚ÜíB retrace ${(retraceRatio * 100).toFixed(1)}%`);
          return 'Elliott ABC Correction Bullish';
        }
      }
    }
  }

  // ‚úÖ DUPLO TOPO - Sensibilidade aumentada
  if (peaks.length >= 2) {
    const lastTwoPeaks = peaks.slice(-2);
    const top1 = lastTwoPeaks[0];
    const top2 = lastTwoPeaks[1];

    const priceDiff = Math.abs(top1.value - top2.value) / Math.max(top1.value, top2.value);

    // ‚úÖ AJUSTADO: 0.5% ‚Üí 1% toler√¢ncia, dist√¢ncia m√≠nima 2 candles (era 3)
    if (priceDiff < 0.01 && top2.index > top1.index + 2) {
      const valleyBetween = Math.min(...candles.slice(top1.index, top2.index).map(c => c.low));
      // ‚úÖ AJUSTADO: Valle 1.5% abaixo (era 2%)
      if (valleyBetween < Math.min(top1.value, top2.value) * 0.985) {
        console.log(`üîù [Double Top] Duplo Topo detectado: T1=${top1.value.toFixed(2)}, T2=${top2.value.toFixed(2)}, diff=${(priceDiff * 100).toFixed(2)}%`);
        return 'Duplo Topo';
      }
    }
  }

  // ‚úÖ DUPLO FUNDO - Sensibilidade aumentada
  if (valleys.length >= 2) {
    const lastTwoValleys = valleys.slice(-2);
    const bottom1 = lastTwoValleys[0];
    const bottom2 = lastTwoValleys[1];

    const priceDiff = Math.abs(bottom1.value - bottom2.value) / Math.max(bottom1.value, bottom2.value);

    // ‚úÖ AJUSTADO: mesma l√≥gica do Duplo Topo
    if (priceDiff < 0.01 && bottom2.index > bottom1.index + 2) {
      const peakBetween = Math.max(...candles.slice(bottom1.index, bottom2.index).map(c => c.high));
      if (peakBetween > Math.max(bottom1.value, bottom2.value) * 1.015) {
        console.log(`üîª [Double Bottom] Duplo Fundo detectado: B1=${bottom1.value.toFixed(2)}, B2=${bottom2.value.toFixed(2)}, diff=${(priceDiff * 100).toFixed(2)}%`);
        return 'Duplo Fundo';
      }
    }
  }

  // ‚úÖ TRIPLO TOPO - Sensibilidade aumentada
  if (peaks.length >= 3) {
    const lastThreePeaks = peaks.slice(-3);
    const top1 = lastThreePeaks[0];
    const top2 = lastThreePeaks[1];
    const top3 = lastThreePeaks[2];

    const priceDiff12 = Math.abs(top1.value - top2.value) / Math.max(top1.value, top2.value);
    const priceDiff23 = Math.abs(top2.value - top3.value) / Math.max(top2.value, top3.value);

    // ‚úÖ AJUSTADO: 0.5% ‚Üí 1%, dist√¢ncia 2 candles
    if (priceDiff12 < 0.01 && priceDiff23 < 0.01 &&
      top2.index > top1.index + 2 && top3.index > top2.index + 2) {
      const valley1 = Math.min(...candles.slice(top1.index, top2.index).map(c => c.low));
      const valley2 = Math.min(...candles.slice(top2.index, top3.index).map(c => c.low));
      if (valley1 < Math.min(top1.value, top2.value) * 0.985 &&
        valley2 < Math.min(top2.value, top3.value) * 0.985) {
        return 'Triplo Topo';
      }
    }
  }

  // ‚úÖ TRIPLO FUNDO - Sensibilidade aumentada
  if (valleys.length >= 3) {
    const lastThreeValleys = valleys.slice(-3);
    const bottom1 = lastThreeValleys[0];
    const bottom2 = lastThreeValleys[1];
    const bottom3 = lastThreeValleys[2];

    const priceDiff12 = Math.abs(bottom1.value - bottom2.value) / Math.max(bottom1.value, bottom2.value);
    const priceDiff23 = Math.abs(bottom2.value - bottom3.value) / Math.max(bottom2.value, bottom3.value);

    if (priceDiff12 < 0.01 && priceDiff23 < 0.01 &&
      bottom2.index > bottom1.index + 2 && bottom3.index > bottom2.index + 2) {
      const peak1 = Math.max(...candles.slice(bottom1.index, bottom2.index).map(c => c.high));
      const peak2 = Math.max(...candles.slice(bottom2.index, bottom3.index).map(c => c.high));
      if (peak1 > Math.max(bottom1.value, bottom2.value) * 1.015 &&
        peak2 > Math.max(bottom2.value, bottom3.value) * 1.015) {
        return 'Triplo Fundo';
      }
    }
  }

  return null;
}

// üÜï FUN√á√ÉO PARA DETECTAR PADR√ïES REAIS A PARTIR DOS DADOS DE VELAS (REESCRITA COMPLETA)
async function detectRealPattern(candles, technicalIndicators) {
  if (!candles || candles.length < 50) return 'Estrutura t√©cnica';

  try {
    const recent = candles.slice(-50); // √öltimas 50 velas (aumentado de 20 para melhor contexto)

    // ‚úÖ ORDEM DE PRIORIDADE: Padr√µes mais espec√≠ficos primeiro

    // 1. PADR√ïES DE CANDLESTICK (mais espec√≠ficos, verificam vela atual)
    const candlestickPattern = detectCandlestickPatterns(recent);
    if (candlestickPattern) return candlestickPattern;

    // 2. PADR√ïES SMC (Smart Money Concepts) - FVG, OB, BOS, CHOCH
    const smcPattern = detectSMCPatterns(recent);
    if (smcPattern) return smcPattern;

    // 3. PADR√ïES GEOM√âTRICOS (Tri√¢ngulos, Cunhas) - requerem an√°lise de m√∫ltiplas velas
    const geometricPattern = detectGeometricPatterns(recent);
    if (geometricPattern) return geometricPattern;

    // 4. PADR√ïES DE CONTINUA√á√ÉO (Bandeiras, Range)
    const continuationPattern = detectContinuationPatterns(recent);
    if (continuationPattern) return continuationPattern;

    // 5. PADR√ïES DE REVERS√ÉO (Duplo/Triplo Topo/Fundo)
    const reversalPattern = detectReversalPatterns(recent);
    if (reversalPattern) return reversalPattern;

    // 6. LIQUIDITY SWEEP (rompimento r√°pido seguido de revers√£o)
    if (recent.length >= 5) {
      const last5 = recent.slice(-5);
      const current = recent[recent.length - 1];
      const prev = recent[recent.length - 2];
      const highs = last5.map(c => c.high);
      const lows = last5.map(c => c.low);
      const maxHigh = Math.max(...highs);
      const minLow = Math.min(...lows);

      // Sweep de alta seguido de revers√£o
      if (current.high > maxHigh * 1.001 && current.close < prev.close) {
        return 'Liquidity Sweep';
      }
      // Sweep de baixa seguido de revers√£o
      if (current.low < minLow * 0.999 && current.close > prev.close) {
        return 'Liquidity Sweep';
      }
    }

    // 7. SPRING (Wyckoff) - rompimento falso abaixo de suporte
    if (recent.length >= 10) {
      const last10 = recent.slice(-10);
      const support = Math.min(...last10.slice(0, 7).map(c => c.low));
      const current = recent[recent.length - 1];

      if (current.low < support * 0.998 && current.close > support) {
        return 'Spring (Wyckoff)';
      }
    }

    // Fallback: usar indicadores t√©cnicos para inferir padr√£o
    if (technicalIndicators?.rsi_14) {
      if (technicalIndicators.rsi_14 < 30) {
        return 'RSI Oversold - Revers√£o Potencial';
      } else if (technicalIndicators.rsi_14 > 70) {
        return 'RSI Overbought - Revers√£o Potencial';
      }
    }

    return 'Estrutura t√©cnica'; // Fallback final
  } catch (error) {
    logIntelligence('warn', 'Erro ao detectar padr√£o real', { error: error?.message || error });
    return 'Estrutura t√©cnica';
  }
}

serve(async (req) => {
  // ‚úÖ PROTE√á√ÉO EVENT LOOP: Timeout de 50 segundos (limite Supabase √© 60s)
  const executionTimeout = setTimeout(() => {
    console.error('‚ö†Ô∏è [TIMEOUT] Execu√ß√£o excedeu 50 segundos, abortando...');
  }, 50000);

  try {
    // ‚úÖ Fun√ß√£o helper para garantir headers CORS sempre dispon√≠veis
    const getSafeCorsHeaders = () => {
      try {
        const origin = req?.headers?.get('origin') || '';
        return getCorsHeaders(origin);
      } catch (corsError) {
        // Fallback absoluto se getCorsHeaders falhar
        return {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
          'Access-Control-Allow-Methods': 'POST, GET, OPTIONS'
        };
      }
    };

    // ‚úÖ Headers CORS padr√£o sempre dispon√≠veis
    const defaultCorsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
      'Access-Control-Allow-Methods': 'POST, GET, OPTIONS'
    };

    let corsHeaders = defaultCorsHeaders;
    try {
      corsHeaders = getSafeCorsHeaders();
    } catch (e) {
      // Se falhar, usar headers padr√£o
      corsHeaders = defaultCorsHeaders;
    }

    if (req.method === 'OPTIONS') {
      return new Response(null, {
        status: 200,
        headers: {
          ...corsHeaders,
          'Content-Length': '0',
          'Access-Control-Max-Age': '86400' // Cache preflight por 24h
        }
      });
    }
    // Tratar GET requests (acesso direto via navegador ou health checks)
    if (req.method === 'GET') {
      return new Response(JSON.stringify({
        name: 'intelligent-narrator',
        version: '2.0',
        status: 'active',
        description: 'AI Narrator Edge Function - An√°lise t√©cnica avan√ßada com detec√ß√£o de padr√µes',
        usage: 'Esta fun√ß√£o requer autentica√ß√£o e deve ser chamada via POST com body JSON',
        endpoints: {
          method: 'POST',
          body: {
            userId: 'string',
            marketData: {
              symbol: 'string (ex: BTC/USDT)',
              timeframe: 'string (ex: 1m)',
              price: 'string',
              volume: 'string',
              timestamp: 'number'
            },
            pattern: {
              type: 'string',
              detected_at: 'number'
            },
            technicalIndicators: 'object (opcional)'
          }
        },
        features: [
          'Detec√ß√£o de 22+ padr√µes t√©cnicos',
          'An√°lise multi-timeframe',
          'Order Book Analysis',
          'Filtros para alta leverage (75x+)',
          'Regime de Mercado',
          'Correla√ß√£o BTC',
          'Ciclos de Mercado (Wyckoff)'
        ]
      }), {
        status: 200,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }

    log('info', 'Narrator iniciado', {});
    log('debug', 'Request recebido', {
      method: req.method,
      url: req.url,
      hasBody: !!req.body,
      contentType: req.headers.get('content-type'),
      contentLength: req.headers.get('content-length')
    });
    // Utilidade: retry com timeout para chamadas possivelmente inst√°veis (edge functions externas)
    async function retryWithTimeout(fn, options = {}) {
      const { retries = 2, timeoutMs = 10000, label = 'operation' } = options;
      let lastError;
      for (let attempt = 1; attempt <= retries + 1; attempt++) {
        try {
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), timeoutMs);
          const result = await fn();
          clearTimeout(timeout);
          return result;
        } catch (err) {
          lastError = err;
          console.warn(`‚ö†Ô∏è ${label} falhou (tentativa ${attempt}/${retries + 1})`, err?.message || err);
          if (attempt <= retries) {
            await new Promise((r) => setTimeout(r, 300));
            continue;
          }
        }
      }
      throw lastError;
    }

    // ‚úÖ MELHORIA: Tratar erros de parse do JSON com mais detalhes
    // NOTA: N√£o validamos req.body aqui porque no Deno pode ser ReadableStream
    // A valida√ß√£o ser√° feita ao tentar fazer parse do JSON
    let body;
    try {
      log('debug', 'Tentando fazer parse do body...', {});
      // ‚úÖ CORRE√á√ÉO: Tentar usar req.json() diretamente (m√©todo recomendado do Deno)
      // Se falhar, tentar ler como texto e fazer parse manual
      try {
        body = await req.json();
        log('debug', 'Body parseado com sucesso via req.json()', {
          bodySize: JSON.stringify(body).length,
          hasUserId: !!body?.userId,
          hasMarketData: !!body?.marketData
        });
      } catch (jsonError) {
        // Se req.json() falhar, tentar ler como texto
        log('warn', 'req.json() falhou, tentando ler como texto', {
          error: jsonError?.message || String(jsonError),
          errorName: jsonError?.name
        });

        // ‚úÖ CORRE√á√ÉO: Se req.json() falhou, o body pode j√° ter sido consumido
        // Tentar clonar o request ANTES de chamar req.json() n√£o √© poss√≠vel aqui
        // Ent√£o vamos tentar ler como texto diretamente (pode falhar se j√° foi consumido)
        let bodyText;
        try {
          // Tentar clonar o request primeiro (se ainda n√£o foi consumido)
          const clonedReq = req.clone();
          bodyText = await clonedReq.text();
        } catch (cloneError) {
          // Se clonar falhar, pode ser que o body j√° foi consumido
          // Nesse caso, usar body vazio e continuar
          log('warn', 'N√£o foi poss√≠vel clonar request (body pode ter sido consumido)', {
            cloneError: cloneError?.message
          });
          // ‚úÖ FALLBACK: Usar body vazio e continuar com valores padr√£o
          log('warn', 'Usando body vazio e continuando com valores padr√£o');
          body = {};
          bodyText = undefined; // Marcar como undefined para n√£o tentar parse
        }

        if (bodyText !== undefined) {
          log('debug', 'Body recebido como texto', {
            bodyLength: bodyText?.length || 0,
            bodyPreview: bodyText?.substring(0, 200) || '',
            isJSON: bodyText?.trim().startsWith('{') || bodyText?.trim().startsWith('[')
          });

          // Tentar fazer parse do JSON manualmente
          if (bodyText && bodyText.trim().length > 0) {
            try {
              body = JSON.parse(bodyText);
              log('debug', 'Body parseado com sucesso via JSON.parse()', {
                bodyKeys: Object.keys(body || {})
              });
            } catch (parseError) {
              log('error', 'Erro ao fazer parse do JSON', {
                error: parseError?.message || String(parseError),
                bodyText: bodyText.substring(0, 500)
              });
              // ‚úÖ FALLBACK: Em vez de retornar 400, usar body vazio e continuar
              log('warn', 'JSON inv√°lido, usando body vazio e continuando com valores padr√£o');
              body = {};
            }
          } else {
            // ‚úÖ FALLBACK: Body vazio, usar valores padr√£o
            log('warn', 'Body vazio, usando valores padr√£o');
            body = {};
          }
        }
      }

      // ‚úÖ GARANTIR: Se body ainda for undefined, usar objeto vazio
      if (!body || typeof body !== 'object') {
        log('warn', 'Body inv√°lido ou undefined, usando objeto vazio');
        body = {};
      }
    } catch (parseError) {
      log('error', 'Erro ao ler body do request', {
        error: parseError?.message || String(parseError),
        errorType: parseError?.constructor?.name,
        stack: parseError?.stack?.substring(0, 500)
      });
      // ‚úÖ FALLBACK: Em vez de retornar 400, usar body vazio e continuar
      log('warn', 'Erro ao ler body, usando valores padr√£o e continuando');
      body = {};
    }

    log('debug', 'Body recebido', {
      bodySize: JSON.stringify(body).length
    });
    // ‚úÖ MELHORIA: Valida√ß√£o robusta com fallbacks inteligentes
    const pattern = body?.pattern || {};
    const marketData = body?.marketData || {};
    const technicalIndicators = body?.technicalIndicators || {};

    // ‚úÖ MELHORIA: Usar userId do body ou fallback para 'system-ai'
    let userId = body?.userId;
    if (!userId || typeof userId !== 'string' || userId.trim() === '') {
      console.warn('‚ö†Ô∏è [intelligent-narrator] userId n√£o fornecido, usando system-ai como fallback');
      userId = 'system-ai';
    }
    userId = userId.trim();

    // ‚úÖ MELHORIA: Validar symbol com fallback para BTC/USDT
    let symbol = marketData?.symbol;
    if (!symbol || typeof symbol !== 'string' || symbol.trim() === '') {
      console.warn('‚ö†Ô∏è [intelligent-narrator] Symbol n√£o fornecido, usando BTC/USDT como fallback');
      symbol = 'BTC/USDT';
    }
    symbol = symbol.trim();

    // ‚úÖ MELHORIA: Garantir que marketData tenha valores v√°lidos
    const safeMarketData = {
      symbol: symbol,
      timeframe: marketData?.timeframe || '1m',
      price: marketData?.price || '0',
      volume: marketData?.volume || '0',
      change24h: marketData?.change24h || 0,
      timestamp: marketData?.timestamp || Date.now()
    };

    log('info', 'Dados extra√≠dos (com fallbacks)', {
      userId: userId,
      symbol: safeMarketData.symbol,
      patternType: pattern?.type,
      hasTechnicalIndicators: !!technicalIndicators,
      usedFallbacks: {
        userId: body?.userId ? false : true,
        symbol: marketData?.symbol ? false : true
      }
    });
    // üîß Validar se o pre√ßo √© recente (< 5 segundos)
    const priceTimestamp = safeMarketData.timestamp || 0;
    const now = Date.now();
    const priceAge = now - priceTimestamp;

    // ‚úÖ PATCH 1: VALIDA√á√ÉO COMPLETA DE ENTRADA (Pre√ßo, RSI, EMAs)
    // ‚úÖ CORRE√á√ÉO: Usar 'let' ao inv√©s de 'const' para permitir reatribui√ß√£o quando buscar da Binance
    // ‚úÖ CORRE√á√ÉO: Permitir pre√ßo 0 inicialmente, pois a fun√ß√£o busca da Binance depois
    let currentPrice = typeof safeMarketData.price === 'string'
      ? parseFloat(safeMarketData.price.replace(/[$,]/g, ''))
      : (typeof safeMarketData.price === 'number' ? safeMarketData.price : 0);

    // ‚úÖ NOTA: Valida√ß√£o de pre√ßo ser√° feita DEPOIS de tentar buscar da Binance (linha ~3612)
    // Isso permite que o frontend envie price: '0' e a fun√ß√£o busque automaticamente

    // ‚úÖ MELHORIA: Validar RSI com fallback (n√£o retornar 400, apenas logar warning)
    if (technicalIndicators?.rsi_14 !== undefined && technicalIndicators.rsi_14 !== null) {
      const rsi = Number(technicalIndicators.rsi_14);
      if (!Number.isFinite(rsi) || rsi < 0 || rsi > 100) {
        console.warn('‚ö†Ô∏è [intelligent-narrator] RSI inv√°lido detectado, usando fallback:', {
          receivedRSI: technicalIndicators.rsi_14,
          rsiType: typeof technicalIndicators.rsi_14,
          symbol: safeMarketData.symbol,
          userId: userId
        });
        // ‚úÖ MELHORIA: N√£o retornar 400, apenas remover RSI inv√°lido
        technicalIndicators.rsi_14 = undefined;
      }
    }

    // 3. Validar EMAs (se dispon√≠veis e fornecidas)
    if (technicalIndicators?.ema_9 !== undefined ||
      technicalIndicators?.ema_50 !== undefined ||
      technicalIndicators?.ema_200 !== undefined) {
      const ema9 = Number(technicalIndicators.ema_9);
      const ema50 = Number(technicalIndicators.ema_50);
      const ema200 = Number(technicalIndicators.ema_200);

      // ‚úÖ MELHORIA: N√£o retornar 400, apenas remover EMAs inv√°lidas e logar warning
      if (technicalIndicators.ema_9 !== undefined && technicalIndicators.ema_9 !== null && (!Number.isFinite(ema9) || ema9 <= 0)) {
        console.warn('‚ö†Ô∏è [intelligent-narrator] EMA_9 inv√°lida, removendo:', technicalIndicators.ema_9);
        technicalIndicators.ema_9 = undefined;
      }
      if (technicalIndicators.ema_50 !== undefined && technicalIndicators.ema_50 !== null && (!Number.isFinite(ema50) || ema50 <= 0)) {
        console.warn('‚ö†Ô∏è [intelligent-narrator] EMA_50 inv√°lida, removendo:', technicalIndicators.ema_50);
        technicalIndicators.ema_50 = undefined;
      }
      if (technicalIndicators.ema_200 !== undefined && technicalIndicators.ema_200 !== null && (!Number.isFinite(ema200) || ema200 <= 0)) {
        console.warn('‚ö†Ô∏è [intelligent-narrator] EMA_200 inv√°lida, removendo:', technicalIndicators.ema_200);
        technicalIndicators.ema_200 = undefined;
      }
    }

    // ‚úÖ NOTA: safeMarketData j√° foi criado acima com fallbacks (linha ~3015)

    // ===== NORMALIZA√á√ÉO DE S√çMBOLO (movida para antes do uso) =====
    const normalizeSymbol = (sym) => {
      const s = String(sym || '').trim();
      return {
        withSlash: s.includes('/') ? s : `${s.slice(0, -4)}/${s.slice(-4)}`,
        binance: s.includes('/') ? s.replace('/', '') : s
      };
    };
    const norm = normalizeSymbol(safeMarketData.symbol);

    // üÜï DETEC√á√ÉO REAL DE PADR√ïES A PARTIR DOS DADOS DE VELAS
    let detectedPattern = pattern.type || null;
    let klines = null; // Vari√°vel para armazenar klines para an√°lise de order book

    // ‚úÖ PATCH 9: MELHORAR AUTO-DETECT - Retornar erro se dados insuficientes
    if (!detectedPattern || detectedPattern.toLowerCase() === 'auto-detect' || detectedPattern.toLowerCase() === 'estrutura t√©cnica') {
      try {
        // Buscar dados de velas para an√°lise
        const symbolNoSlash = norm.binance;
        const timeframe = safeMarketData.timeframe || '1m';
        const klinesUrl = `https://api.binance.com/api/v3/klines?symbol=${symbolNoSlash}&interval=${timeframe}&limit=100`;

        // Usar AbortController para timeout (compat√≠vel com Deno)
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);

        let klinesResp;
        try {
          klinesResp = await fetch(klinesUrl, { signal: controller.signal });
          clearTimeout(timeoutId);
        } catch (fetchError) {
          clearTimeout(timeoutId);
          throw fetchError;
        }

        if (!klinesResp.ok) {
          throw new Error(`Binance API error: ${klinesResp.status}`);
        }

        // ‚úÖ MELHORIA: Tratar erros de parse do JSON
        try {
          klines = await klinesResp.json(); // Armazenar para uso posterior
        } catch (parseError) {
          log('error', 'Erro ao fazer parse do JSON das klines', {
            error: parseError?.message || String(parseError),
            symbol: symbolNoSlash,
            timeframe: timeframe
          });
          throw new Error(`Failed to parse klines JSON: ${parseError?.message || 'Unknown error'}`);
        }

        // ‚úÖ Validar se temos dados suficientes ANTES de detectar
        if (!Array.isArray(klines) || klines.length < 20) {
          // ‚úÖ FALLBACK: Em vez de retornar 400, usar padr√£o fallback e continuar
          log('warn', 'Dados insuficientes para detec√ß√£o autom√°tica, usando fallback', {
            receivedCandles: klines?.length || 0,
            required: 20
          });
          detectedPattern = 'Estrutura t√©cnica'; // Usar fallback
        } else {
          // Converter para formato de an√°lise
          const candles = klines.map(k => ({
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5]),
            time: k[0]
          }));

          // Detectar padr√£o real
          detectedPattern = await detectRealPattern(candles, technicalIndicators);

          // ‚úÖ Se n√£o detectou padr√£o ou retornou fallback, usar fallback e continuar
          if (!detectedPattern || detectedPattern === 'Estrutura t√©cnica') {
            log('warn', 'Padr√£o n√£o detectado, usando fallback', {
              candlesCount: candles.length
            });
            detectedPattern = 'Estrutura t√©cnica'; // Usar fallback
          } else {
            log('info', 'Padr√£o detectado automaticamente', {
              detectedPattern,
              candlesCount: candles.length
            });
          }
        }
      } catch (detectError) {
        const errorMessage = detectError?.message || detectError?.toString() || JSON.stringify(detectError) || 'Erro desconhecido';
        log('warn', 'Erro ao detectar padr√£o autom√°tico, usando fallback', {
          error: errorMessage,
          errorType: typeof detectError,
          symbol: norm.binance,
          stack: detectError?.stack?.substring(0, 200)
        });
        // ‚úÖ FALLBACK: Em vez de retornar 400, usar padr√£o fallback e continuar
        detectedPattern = 'Estrutura t√©cnica'; // Usar fallback
      }
    }

    const safePattern = {
      type: detectedPattern || 'Estrutura t√©cnica',
      detected_at: pattern.detected_at || now
    };
    // ===== FALLBACK ROBUSTO DE INDICADORES (Edge) =====
    /**
     * üéØ CALCULAR ATR MULTI-TIMEFRAME
     * Calcula ATR de M1, M5, M15, M30 e retorna m√©dia ponderada
     * F√≥rmula: ATR_final = (M1 * 0.45) + (M5 * 0.30) + (M15 * 0.15) + (M30 * 0.10)
     */
    async function calculateMultiTimeframeATR(symbolNoSlash, currentPrice) {
      try {
        const timeframes = [
          { interval: '1m', weight: 0.45 },
          { interval: '5m', weight: 0.30 },
          { interval: '15m', weight: 0.15 },
          { interval: '30m', weight: 0.10 }
        ];

        const atrValues: number[] = [];
        const weights: number[] = [];

        for (const tf of timeframes) {
          try {
            const url = `https://api.binance.com/api/v3/klines?symbol=${symbolNoSlash}&interval=${tf.interval}&limit=100`;
            const resp = await fetch(url, { signal: AbortSignal.timeout(3000) });
            const rows = await resp.json();

            if (Array.isArray(rows) && rows.length > 0) {
              const trs: number[] = [];
              let prevClose: number | null = null;

              for (const k of rows.slice(-100)) {
                const high = +k[2];
                const low = +k[3];
                const close = +k[4];

                if (prevClose === null) {
                  trs.push(high - low);
                } else {
                  trs.push(Math.max(
                    high - low,
                    Math.abs(high - prevClose),
                    Math.abs(low - prevClose)
                  ));
                }
                prevClose = close;
              }

              const atr = trs.length > 0
                ? trs.reduce((a, b) => a + b, 0) / trs.length
                : currentPrice * 0.002; // fallback 0.2%

              if (Number.isFinite(atr) && atr > 0) {
                atrValues.push(atr);
                weights.push(tf.weight);
              }
            }
          } catch (error) {
            // Se falhar em um timeframe, continua com os outros
            log('debug', `Erro ao calcular ATR para ${tf.interval}`, { error: error?.message });
          }
        }

        // Calcular m√©dia ponderada
        if (atrValues.length === 0) {
          // Fallback: usar apenas ATR de M1 se todos falharem
          return currentPrice * 0.002; // 0.2% padr√£o
        }

        // Se temos todos os timeframes, usar pesos originais
        // Se faltam alguns, normalizar pesos dispon√≠veis
        const totalWeight = weights.reduce((a, b) => a + b, 0);
        const normalizedWeights = totalWeight > 0
          ? weights.map(w => w / totalWeight)
          : weights.map(() => 1 / weights.length);

        const weightedATR = atrValues.reduce((sum, atr, idx) => {
          return sum + (atr * normalizedWeights[idx]);
        }, 0);

        return weightedATR;
      } catch (error) {
        log('warn', 'Erro ao calcular ATR multi-timeframe', { error: error?.message });
        return currentPrice * 0.002; // Fallback seguro
      }
    }

    async function computeServerIndicators(symbolNoSlash, interval = '1m') {
      try {
        // Verificar cache primeiro
        const cacheKey = `binance:${symbolNoSlash}:${interval}`;
        const cached = narratorBinanceCache.get(cacheKey);
        if (cached) {
          log('debug', 'Cache hit para indicadores Binance', {
            symbol: symbolNoSlash
          });
          return cached;
        }
        const url = `https://api.binance.com/api/v3/klines?symbol=${symbolNoSlash}&interval=${interval}&limit=500`;
        const resp = await fetch(url, {
          signal: AbortSignal.timeout(5000)
        });
        const rows = await resp.json();
        if (!Array.isArray(rows) || rows.length === 0) return {};
        const closes = rows.map((r) => parseFloat(r[4]));
        const highs = rows.map((r) => parseFloat(r[2]));
        const lows = rows.map((r) => parseFloat(r[3]));
        const vols = rows.map((r) => parseFloat(r[5]));
        const ema = (series, period) => {
          const k = 2 / (period + 1);
          let val = series[0];
          for (let i = 1; i < series.length; i++)val = series[i] * k + val * (1 - k);
          return val;
        };
        const emaN = (series, period) => ema(series, period);
        // EMAs
        const ema9 = emaN(closes, 9);
        const ema50 = emaN(closes, 50);
        const ema200 = emaN(closes, 200);
        // MACD (12,26,9)
        const k12 = 2 / (12 + 1);
        const k26 = 2 / (26 + 1);
        let e12 = closes[0];
        let e26 = closes[0];
        const macdSeries = [];
        for (let i = 1; i < closes.length; i++) {
          e12 = closes[i] * k12 + e12 * (1 - k12);
          e26 = closes[i] * k26 + e26 * (1 - k26);
          macdSeries.push(e12 - e26);
        }
        const macdSignal = emaN(macdSeries, 9);
        const macd = macdSeries[macdSeries.length - 1] || 0;
        // RSI14 - ‚úÖ CORRE√á√ÉO: Validar se h√° candles suficientes (precisa de pelo menos 15 para RSI de 14 per√≠odos)
        const rsiPeriod = 14;
        let rsi14 = 50; // Fallback padr√£o
        if (closes.length >= rsiPeriod + 1) {
          let gains = 0, losses = 0;
          for (let i = 1; i <= rsiPeriod; i++) {
            if (i < closes.length && closes[i] !== undefined && closes[i - 1] !== undefined) {
              const diff = closes[i] - closes[i - 1];
              gains += Math.max(diff, 0);
              losses += Math.max(-diff, 0);
            }
          }
          let avgGain = gains / rsiPeriod;
          let avgLoss = losses / rsiPeriod;
          for (let i = rsiPeriod + 1; i < closes.length; i++) {
            if (closes[i] !== undefined && closes[i - 1] !== undefined) {
              const diff = closes[i] - closes[i - 1];
              avgGain = (avgGain * (rsiPeriod - 1) + Math.max(diff, 0)) / rsiPeriod;
              avgLoss = (avgLoss * (rsiPeriod - 1) + Math.max(-diff, 0)) / rsiPeriod;
            }
          }
          const rs = avgLoss === 0 ? 100 : avgGain / (avgLoss || 1e-9);
          const calculatedRSI = 100 - 100 / (1 + rs);
          // Validar se o RSI calculado √© v√°lido
          if (Number.isFinite(calculatedRSI) && calculatedRSI >= 0 && calculatedRSI <= 100) {
            rsi14 = calculatedRSI;
          }
        } else {
          log('warn', 'Candles insuficientes para calcular RSI', {
            candlesCount: closes.length,
            required: rsiPeriod + 1
          });
        }
        // Volume z-score simples
        const meanVol = vols.reduce((a, b) => a + b, 0) / vols.length;
        const stdVol = Math.sqrt(vols.map((v) => (v - meanVol) ** 2).reduce((a, b) => a + b, 0) / vols.length) || 1;
        const volume_z_score = (vols[vols.length - 1] - meanVol) / stdVol;
        // ATR (14)
        const trs = [];
        let prevClose = null;
        for (const k of rows.slice(-100)) {
          const high = +k[2];
          const low = +k[3];
          const close = +k[4];
          if (prevClose == null) trs.push(high - low);
          else trs.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
          prevClose = close;
        }
        const atr = trs.length ? trs.reduce((a, b) => a + b, 0) / trs.length : parseFloat(String(safeMarketData.price)) * 0.002 || 1;
        // ===== INDICADORES AVAN√áADOS PARA PRECIS√ÉO 85-95% =====
        // VWAP (Volume Weighted Average Price)
        const vwap = (() => {
          let totalVolume = 0;
          let totalValue = 0;
          for (let i = 0; i < rows.length; i++) {
            const typicalPrice = (parseFloat(rows[i][2]) + parseFloat(rows[i][3]) + parseFloat(rows[i][4])) / 3;
            const volume = parseFloat(rows[i][5]);
            totalValue += typicalPrice * volume;
            totalVolume += volume;
          }
          return totalVolume > 0 ? totalValue / totalVolume : closes[closes.length - 1];
        })();
        // Volume Profile (POC - Point of Control)
        const volumeProfile = (() => {
          const priceRange = Math.max(...highs) - Math.min(...lows);
          const buckets = 20;
          const bucketSize = priceRange / buckets;
          const profile = {};
          for (let i = 0; i < rows.length; i++) {
            const typicalPrice = (parseFloat(rows[i][2]) + parseFloat(rows[i][3]) + parseFloat(rows[i][4])) / 3;
            const volume = parseFloat(rows[i][5]);
            const bucket = Math.floor((typicalPrice - Math.min(...lows)) / bucketSize);
            const key = `bucket_${bucket}`;
            profile[key] = (profile[key] || 0) + volume;
          }
          let maxVolume = 0;
          let pocBucket = 0;
          for (const [key, volume] of Object.entries(profile)) {
            if (volume > maxVolume) {
              maxVolume = volume;
              pocBucket = parseInt(key.split('_')[1]);
            }
          }
          const pocPrice = Math.min(...lows) + pocBucket * bucketSize;
          return {
            poc: pocPrice,
            maxVolume,
            profile
          };
        })();
        // Volume Delta (Buy vs Sell Pressure)
        const volumeDelta = (() => {
          let buyVolume = 0;
          let sellVolume = 0;
          for (let i = 0; i < rows.length; i++) {
            const open = parseFloat(rows[i][1]);
            const close = parseFloat(rows[i][4]);
            const volume = parseFloat(rows[i][5]);
            if (close > open) {
              buyVolume += volume;
            } else if (close < open) {
              sellVolume += volume;
            }
          }
          return {
            buyVolume,
            sellVolume,
            delta: buyVolume - sellVolume
          };
        })();
        // Bollinger Bands
        const bollingerBands = (() => {
          const period = 20;
          const stdDev = 2;
          if (closes.length < period) return {
            upper: 0,
            middle: 0,
            lower: 0,
            width: 0
          };
          const sma = closes.slice(-period).reduce((a, b) => a + b, 0) / period;
          const variance = closes.slice(-period).reduce((a, b) => a + Math.pow(b - sma, 2), 0) / period;
          const standardDeviation = Math.sqrt(variance);
          return {
            upper: sma + standardDeviation * stdDev,
            middle: sma,
            lower: sma - standardDeviation * stdDev,
            width: standardDeviation * stdDev * 2 / sma * 100
          };
        })();
        // Stochastic Oscillator
        const stochastic = (() => {
          const period = 14;
          if (closes.length < period) return {
            k: 50,
            d: 50
          };
          const recentHighs = highs.slice(-period);
          const recentLows = lows.slice(-period);
          const recentCloses = closes.slice(-period);
          const highestHigh = Math.max(...recentHighs);
          const lowestLow = Math.min(...recentLows);
          const currentClose = recentCloses[recentCloses.length - 1];
          const k = (currentClose - lowestLow) / (highestHigh - lowestLow) * 100;
          const d = k; // Simplificado
          return {
            k,
            d
          };
        })();
        const result = {
          ema_9: ema9,
          ema_50: ema50,
          ema_200: ema200,
          macd,
          macd_signal: macdSignal,
          rsi_14: rsi14,
          volume_z_score,
          atr,
          // Indicadores Avan√ßados
          vwap: vwap,
          volume_profile: volumeProfile,
          volume_delta: volumeDelta,
          bollinger_bands: bollingerBands,
          stochastic: stochastic
        };
        // Salvar no cache
        narratorBinanceCache.set(cacheKey, result);
        log('debug', 'Indicadores Binance calculados e cacheados', {
          symbol: symbolNoSlash
        });
        return result;
      } catch (err) {
        log('error', 'Erro ao calcular indicadores Binance', {
          symbol: symbolNoSlash,
          error: err.message
        });
        return {};
      }
    }
    // ===== AN√ÅLISE DE ORDER BOOK (OTIMIZADA COM CACHE) =====
    async function analyzeOrderBook(symbolNoSlash, currentPrice, candles = []) {
      try {
        // Verificar cache primeiro (mesma l√≥gica de otimiza√ß√£o)
        const cacheKey = `orderbook:${symbolNoSlash}`;
        const cached = narratorOrderBookCache.get(cacheKey);
        if (cached) {
          log('debug', 'Cache hit para order book', { symbol: symbolNoSlash });
          return cached;
        }
        // Buscar order book apenas quando necess√°rio (n√£o em todas as an√°lises)
        const depthUrl = `https://api.binance.com/api/v3/depth?symbol=${symbolNoSlash}&limit=100`;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);

        let depthResp;
        try {
          depthResp = await fetch(depthUrl, { signal: controller.signal });
          clearTimeout(timeoutId);
        } catch (fetchError) {
          clearTimeout(timeoutId);
          log('warn', 'Erro ao buscar order book (timeout ou erro)', { symbol: symbolNoSlash });
          return null; // Retorna null em caso de erro (n√£o quebra an√°lise)
        }

        if (!depthResp.ok) {
          log('warn', 'Order book API error', { status: depthResp.status, symbol: symbolNoSlash });
          return null;
        }

        const depthData = await depthResp.json();
        if (!depthData.bids || !depthData.asks) {
          return null;
        }

        // Converter strings para n√∫meros
        const bids = depthData.bids.map(([p, v]) => [parseFloat(p), parseFloat(v)]);
        const asks = depthData.asks.map(([p, v]) => [parseFloat(p), parseFloat(v)]);

        // 1. ORDER BOOK IMBALANCE (desequil√≠brio bid/ask)
        const topBids = bids.slice(0, 20);
        const topAsks = asks.slice(0, 20);
        const bidVolume = topBids.reduce((sum, [p, v]) => sum + v, 0);
        const askVolume = topAsks.reduce((sum, [p, v]) => sum + v, 0);
        const totalVolume = bidVolume + askVolume;
        const imbalance = totalVolume > 0 ? (bidVolume - askVolume) / totalVolume : 0; // -1 a +1

        // 2. DETEC√á√ÉO DE ORDENS GRANDES (percentil 95)
        const allVolumes = [...bids, ...asks].map(([p, v]) => v).sort((a, b) => b - a);
        const percentile95Index = Math.floor(allVolumes.length * 0.05);
        const threshold = allVolumes[percentile95Index] || 0;

        const largeBids = bids.filter(([p, v]) => v >= threshold).map(([p, v]) => ({ price: p, volume: v }));
        const largeAsks = asks.filter(([p, v]) => v >= threshold).map(([p, v]) => ({ price: p, volume: v }));
        const totalLargeVolume = largeBids.reduce((sum, o) => sum + o.volume, 0) +
          largeAsks.reduce((sum, o) => sum + o.volume, 0);

        // 3. DETEC√á√ÉO DE ZONAS DE LIQUIDA√á√ÉO
        const liquidationZones = [];

        // 3.1. Aglomera√ß√£o de ordens (clusters)
        const clusterTolerance = currentPrice * 0.001; // 0.1% de toler√¢ncia
        const clusters = [];
        for (let i = 0; i < bids.length; i++) {
          const [price, volume] = bids[i];
          const existingCluster = clusters.find(c => Math.abs(c.price - price) < clusterTolerance);
          if (existingCluster) {
            existingCluster.volume += volume;
            existingCluster.count++;
          } else {
            clusters.push({ price, volume, count: 1 });
          }
        }
        for (let i = 0; i < asks.length; i++) {
          const [price, volume] = asks[i];
          const existingCluster = clusters.find(c => Math.abs(c.price - price) < clusterTolerance);
          if (existingCluster) {
            existingCluster.volume += volume;
            existingCluster.count++;
          } else {
            clusters.push({ price, volume, count: 1 });
          }
        }

        // Filtrar clusters significativos (volume > m√©dia)
        const avgClusterVolume = clusters.reduce((sum, c) => sum + c.volume, 0) / clusters.length;
        const significantClusters = clusters
          .filter(c => c.volume > avgClusterVolume * 1.5 && c.count >= 3)
          .map(c => ({ price: c.price, strength: Math.min(1, c.volume / (avgClusterVolume * 2)), type: 'order_cluster' }));
        liquidationZones.push(...significantClusters);

        // 3.2. N√≠veis psicol√≥gicos pr√≥ximos (round numbers)
        const roundNumbers = [
          Math.floor(currentPrice / 1000) * 1000,
          Math.floor(currentPrice / 100) * 100,
          Math.floor(currentPrice / 10) * 10
        ].filter(p => Math.abs(p - currentPrice) < currentPrice * 0.05); // Apenas pr√≥ximos (5%)
        liquidationZones.push(...roundNumbers.map(p => ({ price: p, strength: 0.6, type: 'psychological' })));

        // 3.3. M√°ximas/m√≠nimas recentes (onde stops geralmente ficam)
        if (candles && candles.length >= 20) {
          const recentHigh = Math.max(...candles.slice(-20).map(c => c.high));
          const recentLow = Math.min(...candles.slice(-20).map(c => c.low));
          liquidationZones.push(
            { price: recentHigh, strength: 0.8, type: 'recent_high' },
            { price: recentLow, strength: 0.8, type: 'recent_low' }
          );
        }

        // Ordenar zonas por proximidade ao pre√ßo atual
        liquidationZones.sort((a, b) => Math.abs(a.price - currentPrice) - Math.abs(b.price - currentPrice));

        // 4. AN√ÅLISE DE FLUXO (buy vs sell pressure)
        const buyPressure = imbalance > 0.3 ? imbalance : 0;
        const sellPressure = imbalance < -0.3 ? Math.abs(imbalance) : 0;
        const netFlow = imbalance;

        // ‚úÖ FASE 1: Calcular spread real do order book
        const bestBid = bids.length > 0 ? bids[0][0] : 0;
        const bestAsk = asks.length > 0 ? asks[0][0] : 0;
        const realSpread = (bestBid > 0 && bestAsk > bestBid)
          ? (bestAsk - bestBid) / bestBid
          : 0.0002; // Fallback: 0.02% se n√£o conseguir calcular

        const result = {
          imbalance, // -1 a +1
          bidVolume,
          askVolume,
          ratio: askVolume > 0 ? bidVolume / askVolume : 1,
          largeOrders: {
            threshold,
            bids: largeBids.slice(0, 5), // Top 5 apenas
            asks: largeAsks.slice(0, 5),
            totalVolume: totalLargeVolume
          },
          liquidationZones: liquidationZones.slice(0, 5), // Top 5 zonas mais pr√≥ximas
          orderFlow: {
            buyPressure,
            sellPressure,
            netFlow
          },
          signal: imbalance > 0.3 && netFlow > 0.2 ? 'BULLISH' :
            imbalance < -0.3 && netFlow < -0.2 ? 'BEARISH' : 'NEUTRAL',
          // ‚úÖ FASE 1: Adicionar dados para c√°lculo de spread real
          bestBid: bestBid,
          bestAsk: bestAsk,
          realSpread: realSpread // Spread real calculado do order book
        };

        // Salvar no cache (8s TTL)
        narratorOrderBookCache.set(cacheKey, result);
        log('debug', 'Order book analisado e cacheado', { symbol: symbolNoSlash });

        return result;
      } catch (err) {
        log('warn', 'Erro ao analisar order book', { symbol: symbolNoSlash, error: err.message });
        return null; // N√£o quebra an√°lise se order book falhar
      }
    }

    // ‚úÖ CORRE√á√ÉO CR√çTICA: Validar pre√ßo ANTES de calcular indicadores
    // Garantir que price √© num√©rico (reutilizar currentPrice j√° declarado na linha 3012)
    currentPrice = typeof safeMarketData.price === 'string' ? parseFloat(safeMarketData.price.replace(/[$,]/g, '')) : safeMarketData.price;

    // üö® CORRE√á√ÉO: Se pre√ßo √© inv√°lido ou zero, buscar da Binance ANTES de calcular indicadores
    if (!currentPrice || currentPrice === 0 || !Number.isFinite(currentPrice)) {
      console.log(`‚ö†Ô∏è Pre√ßo inv√°lido detectado (${currentPrice}), buscando da Binance para s√≠mbolo: ${norm.binance}`);
      const binanceSymbol = norm.binance;

      // Primeiro, tentar usar o pre√ßo das klines se j√° foram buscadas
      if (klines && Array.isArray(klines) && klines.length > 0) {
        const lastCandle = klines[klines.length - 1];
        const priceFromKlines = parseFloat(lastCandle[4]); // close price
        if (priceFromKlines && priceFromKlines > 0 && Number.isFinite(priceFromKlines)) {
          currentPrice = priceFromKlines;
          console.log(`‚úÖ Usando pre√ßo da √∫ltima vela: ${currentPrice}`);
        }
      }

      // Se ainda n√£o tem pre√ßo v√°lido, buscar da API
      if (!currentPrice || currentPrice === 0 || !Number.isFinite(currentPrice)) {
        try {
          // üêõ FIX: Tentar primeiro ticker/price, depois ticker/24hr como fallback
          let binanceUrl = `https://api.binance.com/api/v3/ticker/price?symbol=${binanceSymbol}`;
          console.log(`üîç Buscando pre√ßo em: ${binanceUrl}`);

          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000);

          let binanceResponse;
          try {
            binanceResponse = await fetch(binanceUrl, { signal: controller.signal });
            clearTimeout(timeoutId);
          } catch (fetchError) {
            clearTimeout(timeoutId);
            // Se falhar, tentar fallback
            console.warn(`‚ö†Ô∏è Erro ao buscar ticker/price, tentando fallback...`);
            binanceUrl = `https://api.binance.com/api/v3/ticker/24hr?symbol=${binanceSymbol}`;
            const fallbackController = new AbortController();
            const fallbackTimeout = setTimeout(() => fallbackController.abort(), 3000);
            try {
              binanceResponse = await fetch(binanceUrl, { signal: fallbackController.signal });
              clearTimeout(fallbackTimeout);
            } catch (fallbackError) {
              clearTimeout(fallbackTimeout);
              throw fallbackError;
            }
          }

          if (binanceResponse && binanceResponse.ok) {
            const binanceData = await binanceResponse.json();
            // ticker/price retorna { price: "..." }, ticker/24hr retorna { lastPrice: "..." }
            const priceValue = binanceData.price || binanceData.lastPrice;
            if (priceValue) {
              currentPrice = parseFloat(priceValue);
              console.log(`‚úÖ Pre√ßo obtido da Binance: ${currentPrice} para ${binanceSymbol}`);
            } else {
              console.warn('‚ö†Ô∏è Binance retornou resposta sem pre√ßo:', binanceData);
            }
          } else if (binanceResponse) {
            const errorText = await binanceResponse.text().catch(() => 'Erro desconhecido');
            console.warn(`‚ö†Ô∏è Binance retornou erro ${binanceResponse.status}: ${errorText}`);
          }
        } catch (error) {
          console.error(`‚ùå Erro ao buscar pre√ßo da Binance para ${binanceSymbol}:`, error?.message || error);
        }
      }
    }

    // Validar novamente ap√≥s buscar da Binance
    if (!currentPrice || currentPrice === 0 || !Number.isFinite(currentPrice)) {
      // üêõ FIX: Tentar usar pre√ßo m√©dio das klines como √∫ltimo recurso antes de retornar erro
      if (klines && Array.isArray(klines) && klines.length > 0) {
        const prices = klines.map(k => parseFloat(k[4])).filter(p => p > 0 && Number.isFinite(p));
        if (prices.length > 0) {
          const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;
          if (avgPrice > 0 && Number.isFinite(avgPrice)) {
            currentPrice = avgPrice;
            console.log(`‚úÖ Usando pre√ßo m√©dio das klines como fallback: ${currentPrice}`);
          }
        }
      }

      // Se ainda n√£o tem pre√ßo v√°lido, usar fallback padr√£o
      if (!currentPrice || currentPrice === 0 || !Number.isFinite(currentPrice)) {
        const defaultPrices: Record<string, number> = {
          'BTCUSDT': 60000,
          'ETHUSDT': 3000,
          'BNBUSDT': 300,
          'SOLUSDT': 100
        };
        const symbolKey = norm.binance.toUpperCase();
        currentPrice = defaultPrices[symbolKey] || 50000; // Fallback gen√©rico
        console.warn(`‚ö†Ô∏è [intelligent-narrator] Usando pre√ßo fallback: ${currentPrice} para ${symbolKey}`);
      }
    }

    // ‚úÖ Pre√ßo validado ANTES de calcular indicadores
    if (priceAge > 5000) {
      console.warn(`‚ö†Ô∏è Pre√ßo antigo detectado (${priceAge}ms). Usando do marketData sem valida√ß√£o de frescor.`);
    }
    console.log(`üí∞ Pre√ßo validado: ${currentPrice} (idade: ${priceAge}ms)`);

    // üîß CORRE√á√ÉO CR√çTICA: Atualizar marketData.price e safeMarketData.price com o valor validado
    // Isso garante que TODOS os lugares que leem marketData.price usar√£o o pre√ßo correto
    marketData.price = currentPrice;
    safeMarketData.price = currentPrice;

    // ‚úÖ Agora sim calcular indicadores com pre√ßo validado
    // Sempre computar indicadores no servidor para garantir disponibilidade
    let serverInd = {};
    try {
      serverInd = await computeServerIndicators(norm.binance, safeMarketData.timeframe || '1m');
    } catch (error) {
      console.warn('‚ö†Ô∏è Erro ao calcular indicadores no servidor:', error);
      serverInd = {};
    }

    // üéØ NOVO: Calcular ATR multi-timeframe (M1, M5, M15, M30 com m√©dia ponderada)
    const px = currentPrice; // ‚úÖ Usar pre√ßo j√° validado
    let multiTimeframeATR = px * 0.002; // Fallback padr√£o
    try {
      multiTimeframeATR = await calculateMultiTimeframeATR(norm.binance, currentPrice);
      log('debug', 'ATR multi-timeframe calculado', {
        atr: multiTimeframeATR,
        atrPercent: ((multiTimeframeATR / currentPrice) * 100).toFixed(3) + '%',
        symbol: norm.binance
      });
    } catch (error) {
      log('warn', 'Erro ao calcular ATR multi-timeframe, usando fallback', { error: error?.message });
    }

    // Garantir que todos os indicadores estejam dispon√≠veis
    let safeTechnicalIndicators = {
      rsi_14: Number.isFinite(technicalIndicators.rsi_14) ? technicalIndicators.rsi_14 : Number.isFinite(serverInd.rsi_14) ? serverInd.rsi_14 : 50,
      macd: Number.isFinite(technicalIndicators.macd) ? technicalIndicators.macd : Number.isFinite(serverInd.macd) ? serverInd.macd : 0,
      macd_signal: Number.isFinite(technicalIndicators.macd_signal) ? technicalIndicators.macd_signal : Number.isFinite(serverInd.macd_signal) ? serverInd.macd_signal : 0,
      ema_9: Number.isFinite(technicalIndicators.ema_9) ? technicalIndicators.ema_9 : Number.isFinite(serverInd.ema_9) ? serverInd.ema_9 : px * 1.01,
      ema_50: Number.isFinite(technicalIndicators.ema_50) ? technicalIndicators.ema_50 : Number.isFinite(serverInd.ema_50) ? serverInd.ema_50 : px * 0.99,
      ema_200: Number.isFinite(technicalIndicators.ema_200) ? technicalIndicators.ema_200 : Number.isFinite(serverInd.ema_200) ? serverInd.ema_200 : px * 0.98,
      volume_z_score: Number.isFinite(technicalIndicators.volume_z_score) ? technicalIndicators.volume_z_score : Number.isFinite(serverInd.volume_z_score) ? serverInd.volume_z_score : 0,
      atr: multiTimeframeATR // ‚úÖ NOVO: Usar ATR multi-timeframe ao inv√©s de apenas M1
    };
    safeTechnicalIndicators.rsi_14 = Number.isFinite(safeTechnicalIndicators.rsi_14) ? safeTechnicalIndicators.rsi_14 : 50;
    safeTechnicalIndicators.macd = Number.isFinite(safeTechnicalIndicators.macd) ? safeTechnicalIndicators.macd : 0;
    safeTechnicalIndicators.macd_signal = Number.isFinite(safeTechnicalIndicators.macd_signal) ? safeTechnicalIndicators.macd_signal : 0;
    safeTechnicalIndicators.ema_9 = Number.isFinite(safeTechnicalIndicators.ema_9) ? safeTechnicalIndicators.ema_9 : px;
    safeTechnicalIndicators.ema_50 = Number.isFinite(safeTechnicalIndicators.ema_50) ? safeTechnicalIndicators.ema_50 : px;
    safeTechnicalIndicators.ema_200 = Number.isFinite(safeTechnicalIndicators.ema_200) ? safeTechnicalIndicators.ema_200 : px;
    safeTechnicalIndicators.volume_z_score = Number.isFinite(safeTechnicalIndicators.volume_z_score) ? safeTechnicalIndicators.volume_z_score : 0;
    safeTechnicalIndicators.atr = Number.isFinite(safeTechnicalIndicators.atr) && safeTechnicalIndicators.atr > 0 ? safeTechnicalIndicators.atr : multiTimeframeATR;

    // ‚úÖ CORRE√á√ÉO: Log dos indicadores DEPOIS da valida√ß√£o do pre√ßo
    // Garante que sempre mostre o pre√ßo validado, n√£o price: 0
    console.log('üîç Indicadores calculados no servidor:', {
      rsi: serverInd.rsi_14,
      macd: serverInd.macd,
      ema9: serverInd.ema_9,
      ema50: serverInd.ema_50,
      volume_z: serverInd.volume_z_score,
      hasValidData: !!(serverInd.rsi_14 || serverInd.macd || serverInd.ema_9),
      price: currentPrice  // ‚úÖ Usa pre√ßo validado (j√° foi validado antes de calcular indicadores)
    });

    logIntelligence('debug', 'Analisando padr√£o detectado', { pattern: safePattern?.type || 'unknown' });
    const supabaseUrl = Deno.env.get('SUPABASE_URL') || '';
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || '';
    const supabase = createClient(supabaseUrl, supabaseKey);
    // 1. CONSULTAR CONTEXTO MULTI-TIMEFRAME (DADOS DIRETOS DA BINANCE)
    logData('info', 'Multi-timeframe (M1‚ÜíM5‚ÜíM15‚ÜíM30) carregado da Binance', { symbol: marketData.symbol });
    let multiTimeframeContext;
    try {
      multiTimeframeContext = await getMultiTimeframeContextDirect(norm.binance);
    } catch (error) {
      logError('warn', 'Erro ao buscar contexto multi-timeframe', { error: error?.message || error });
      multiTimeframeContext = {
        m1: {
          trend: 'neutral',
          price: currentPrice
        },
        m5: {
          trend: 'neutral',
          price: currentPrice
        },
        m15: {
          trend: 'neutral',
          price: currentPrice
        },
        m30: {
          trend: 'neutral',
          price: currentPrice
        },
        confirmation: 'neutral',
        shouldReject: false,
        rejectionReason: ''
      };
    }
    // 1.1. Se n√£o h√° dados multi-timeframe, criar contexto b√°sico
    if (!multiTimeframeContext.m1 && !multiTimeframeContext.m5 && !multiTimeframeContext.m15 && !multiTimeframeContext.m30) {
      logData('warn', 'Nenhum dado multi-timeframe encontrado, criando contexto b√°sico');
      multiTimeframeContext.confirmation = 'neutral';
      multiTimeframeContext.shouldReject = false;
      multiTimeframeContext.rejectionReason = '';
    }
    logData('debug', 'Contexto temporal carregado', {
      m1_available: !!multiTimeframeContext.m1,
      m5_available: !!multiTimeframeContext.m5,
      m15_available: !!multiTimeframeContext.m15,
      m30_available: !!multiTimeframeContext.m30
    });
    // üö® OTIMIZA√á√ÉO: Executar queries independentes em paralelo para reduzir tempo total
    // 2. Buscar conhecimento t√©cnico relevante (EXPANDIDO) - COM CACHE
    let knowledge = [];
    let tradeHistory = [];
    let narratorFeedback = [];
    let previousSignals = [];
    let learningProgress = [];

    // Executar queries independentes em paralelo (patternMemory mantido separado devido √† l√≥gica complexa)
    // üö® OTIMIZA√á√ÉO: Adicionar timeout individual para evitar que uma query lenta trave tudo
    try {
      const queryTimeout = 8000; // 8 segundos por query
      const timeoutPromise = (promise, timeoutMs) => {
        return Promise.race([
          promise,
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error(`Query timeout ap√≥s ${timeoutMs}ms`)), timeoutMs)
          )
        ]);
      };

      const [knowledgeResult, tradeHistoryResult, narratorFeedbackResult, previousSignalsResult, learningProgressResult] = await Promise.allSettled([
        // Knowledge
        (async () => {
          const cacheKey = `knowledge:all`;
          const cached = narratorKnowledgeCache.get(cacheKey);
          if (cached) {
            log('debug', 'Cache hit para conhecimento', {});
            return cached;
          }
          log('debug', 'Cache miss para conhecimento - buscando do banco', {});
          // üö® OTIMIZA√á√ÉO: Reduzir limite para evitar timeout (500 ‚Üí 200)
          const { data: knowledgeData } = await supabase.from('bot_knowledge').select('*').order('usage_count', {
            ascending: false
          }).limit(200); // Reduzido de 500 para 200 para evitar timeout
          const result = knowledgeData || [];
          narratorKnowledgeCache.set(cacheKey, result);
          return result;
        })(),

        // Trade History
        (async () => {
          const cacheKey = `trade_history:${marketData.symbol}`;
          const cached = narratorKnowledgeCache.get(cacheKey);
          if (cached) {
            log('debug', 'Cache hit para trade history', { symbol: marketData.symbol });
            return cached;
          }
          log('debug', 'Cache miss para trade history - buscando do banco', { symbol: marketData.symbol });
          const symbolForTradeSearch = marketData.symbol?.replace('/', '') || marketData.symbol || '';
          const { data: tradeHistoryData, error: tradeHistoryError } = await supabase.from('trade_analysis')
            .select('*')
            .or(`symbol.eq.${symbolForTradeSearch},symbol.eq.${marketData.symbol || ''}`)
            .eq('analysis_type', 'narrator')
            .order('created_at', { ascending: false })
            .limit(50);
          if (tradeHistoryError) {
            log('warn', 'Erro ao buscar trade history', { error: tradeHistoryError.message, symbol: symbolForTradeSearch });
          }
          const result = tradeHistoryData || [];
          if (result.length === 0) {
            log('info', 'Hist√≥rico de trades vazio - ser√° populado conforme trades s√£o executados', { symbol: marketData.symbol });
          }
          narratorKnowledgeCache.set(cacheKey, result);
          return result;
        })(),

        // Narrator Feedback
        (async () => {
          try {
            const { data: narratorFeedbackData, error: feedbackError } = await supabase.from('narrator_feedback').select('*').eq('user_id', userId).order('created_at', {
              ascending: false
            }).limit(20);
            if (feedbackError) {
              const errorMsg = feedbackError?.message || feedbackError?.toString() || '';
              if (errorMsg.includes('does not exist') || errorMsg.includes('PGRST205')) {
                console.log('‚ÑπÔ∏è Tabela narrator_feedback n√£o existe (opcional - continuando)');
              } else {
                console.warn('‚ö†Ô∏è Erro ao buscar feedback do narrador:', feedbackError);
              }
              return [];
            }
            return narratorFeedbackData || [];
          } catch (error) {
            const errorMsg = error?.message || error?.toString() || '';
            if (!errorMsg.includes('does not exist') && !errorMsg.includes('PGRST205')) {
              console.warn('‚ö†Ô∏è Erro ao buscar feedback do narrador:', error);
            }
            return [];
          }
        })(),

        // Previous Signals
        (async () => {
          const cacheKey = `previous_signals:${marketData.symbol}`;
          const cached = narratorKnowledgeCache.get(cacheKey);
          if (cached) {
            log('debug', 'Cache hit para previous signals', { symbol: marketData.symbol });
            return cached;
          }
          log('debug', 'Cache miss para previous signals - buscando do banco', { symbol: marketData.symbol });
          let { data: previousSignalsData } = await supabase.from('narrator_signals').select('*').eq('symbol', marketData.symbol).order('created_at', {
            ascending: false
          }).limit(30);
          if ((!previousSignalsData || previousSignalsData.length === 0) && marketData.symbol.includes('/')) {
            const symbolNoSlash = marketData.symbol.replace('/', '');
            const { data: altData } = await supabase.from('narrator_signals').select('*').eq('symbol', symbolNoSlash).order('created_at', {
              ascending: false
            }).limit(30);
            if (altData && altData.length > 0) {
              previousSignalsData = altData;
            }
          }
          if (!previousSignalsData || previousSignalsData.length === 0) {
            const { data: globalData } = await supabase.from('narrator_signals').select('*').order('created_at', {
              ascending: false
            }).limit(30);
            previousSignalsData = globalData || [];
          }
          const result = previousSignalsData || [];
          narratorKnowledgeCache.set(cacheKey, result);
          return result;
        })(),

        // Learning Progress
        (async () => {
          try {
            // üö® OTIMIZA√á√ÉO: Reduzir limite para evitar timeout (200 ‚Üí 100)
            const { data: learningProgressData } = await supabase.from('learning_progress').select('*').order('created_at', {
              ascending: false
            }).limit(100); // Reduzido de 200 para 100 para evitar timeout
            return learningProgressData || [];
          } catch (error) {
            console.warn('‚ö†Ô∏è Erro ao buscar progresso de aprendizado:', error);
            return [];
          }
        })()
      ].map(p => timeoutPromise(p, queryTimeout)));

      // Processar resultados do Promise.allSettled
      knowledge = knowledgeResult.status === 'fulfilled' ? (knowledgeResult.value || []) : [];
      tradeHistory = tradeHistoryResult.status === 'fulfilled' ? (tradeHistoryResult.value || []) : [];
      narratorFeedback = narratorFeedbackResult.status === 'fulfilled' ? (narratorFeedbackResult.value || []) : [];
      previousSignals = previousSignalsResult.status === 'fulfilled' ? (previousSignalsResult.value || []) : [];
      learningProgress = learningProgressResult.status === 'fulfilled' ? (learningProgressResult.value || []) : [];

      // Log de erros individuais sem bloquear
      if (knowledgeResult.status === 'rejected') {
        log('warn', 'Erro ao buscar knowledge (continuando)', { error: knowledgeResult.reason?.message });
      }
      if (tradeHistoryResult.status === 'rejected') {
        log('warn', 'Erro ao buscar tradeHistory (continuando)', { error: tradeHistoryResult.reason?.message });
      }
      if (narratorFeedbackResult.status === 'rejected') {
        log('warn', 'Erro ao buscar narratorFeedback (continuando)', { error: narratorFeedbackResult.reason?.message });
      }
      if (previousSignalsResult.status === 'rejected') {
        log('warn', 'Erro ao buscar previousSignals (continuando)', { error: previousSignalsResult.reason?.message });
      }
      if (learningProgressResult.status === 'rejected') {
        log('warn', 'Erro ao buscar learningProgress (continuando)', { error: learningProgressResult.reason?.message });
      }
    } catch (error) {
      log('error', 'Erro ao buscar dados hist√≥ricos em paralelo', {
        error: error?.message,
        errorType: error?.constructor?.name
      });
      // üö® OTIMIZA√á√ÉO: Em caso de erro, tentar buscar pelo menos os dados cr√≠ticos individualmente
      // Manter arrays vazios em caso de erro - n√£o bloquear a execu√ß√£o
      try {
        // Tentar buscar pelo menos knowledge se falhou
        if (!knowledge || knowledge.length === 0) {
          const cacheKey = `knowledge:all`;
          const cached = narratorKnowledgeCache.get(cacheKey);
          if (cached) {
            knowledge = cached;
          }
        }
      } catch (fallbackError) {
        // Ignorar erro no fallback
      }
    }
    // 2.0.5. Buscar PATTERN MEMORY (EXPANDIDO) - COM CACHE
    let patternMemory = [];
    try {
      const patternHash = `${safePattern.type}_${marketData.symbol}_${marketData.timeframe || '1m'}`;
      const cacheKey = `pattern_memory:${patternHash}`;
      const cached = narratorKnowledgeCache.get(cacheKey);
      if (cached) {
        log('debug', 'Cache hit para pattern memory', {
          patternHash
        });
        patternMemory = cached;
      } else {
        log('debug', 'Cache miss para pattern memory - buscando do banco', {
          patternHash
        });
        // ‚úÖ CORRE√á√ÉO: Normalizar s√≠mbolo para busca (pode estar com ou sem barra)
        const symbolForPatternSearch = marketData.symbol?.replace('/', '') || marketData.symbol || '';
        const patternNameForSearch = safePattern.type || '';

        log('debug', 'Buscando pattern memory', {
          patternName: patternNameForSearch,
          symbolOriginal: marketData.symbol,
          symbolNormalized: symbolForPatternSearch
        });

        // Buscar pattern memory por pattern_name e symbol (n√£o existe pattern_hash)
        // ‚úÖ CORRE√á√ÉO: Buscar com s√≠mbolo normalizado (sem barra) OU com barra OU 'ALL'
        // üéØ MELHORIA: Busca mais flex√≠vel - m√∫ltiplas estrat√©gias de busca
        let patternMemoryData = null;
        let patternMemoryError = null;

        // üéØ ESTRAT√âGIA 1: Busca espec√≠fica (pattern + symbol + timeframe) - para contexto mais relevante
        const { data: specificData, error: specificError } = await supabase.from('ai_pattern_memory')
          .select('*')
          .ilike('pattern_name', `%${patternNameForSearch}%`)
          .or(`symbol.eq.${symbolForPatternSearch},symbol.eq.${marketData.symbol?.replace('/', '') || ''},symbol.eq.ALL`)
          .eq('timeframe', marketData.timeframe || '1m')
          .order('win_rate', { ascending: false })
          .order('total_occurrences', { ascending: false })
          .limit(50);

        if (specificError) {
          log('warn', 'Erro na busca espec√≠fica de pattern memory', {
            error: specificError.message,
            patternName: patternNameForSearch,
            symbol: symbolForPatternSearch,
            timeframe: marketData.timeframe
          });
        }

        // üéØ ESTRAT√âGIA 2: Buscar TODOS os padr√µes (sem filtros) para contexto geral completo
        // ‚úÖ 19/dez: Usar CACHE para reduzir queries (TTL: 5 minutos)
        const allPatternsCacheKey = 'pattern_memory_all';
        let allData = getCached<any[]>(allPatternsCacheKey);
        let allError = null;

        if (!allData) {
          const result = await supabase.from('ai_pattern_memory')
            .select('*')
            .order('total_occurrences', { ascending: false })
            .order('win_rate', { ascending: false })
            .limit(100); // Buscar os 100 padr√µes mais relevantes

          allData = result.data;
          allError = result.error;

          if (!allError && allData) {
            setCache(allPatternsCacheKey, allData, CACHE_TTL.PATTERN_MEMORY);
          }
        }

        if (allError) {
          log('warn', 'Erro na busca geral de pattern memory', {
            error: allError.message
          });
        }

        // üéØ COMBINAR: Usar dados espec√≠ficos se encontrados, mas sempre incluir todos para contexto
        if (specificData && specificData.length > 0) {
          // Combinar espec√≠ficos + todos (removendo duplicatas)
          const specificIds = new Set(specificData.map(p => p.id));
          const additionalPatterns = (allData || []).filter(p => !specificIds.has(p.id));
          patternMemoryData = [...specificData, ...additionalPatterns].slice(0, 100); // Limitar a 100 no total
          log('debug', 'Pattern Memory combinado (espec√≠ficos + todos)', {
            specific: specificData.length,
            additional: additionalPatterns.length,
            total: patternMemoryData.length
          });
        } else {
          // Se n√£o encontrou espec√≠ficos, usar todos
          patternMemoryData = allData || [];
          patternMemoryError = allError || specificError;

          // üéØ ESTRAT√âGIA 3: Se ainda n√£o encontrou, buscar por s√≠mbolo (qualquer padr√£o do s√≠mbolo)
          if (!patternMemoryData || patternMemoryData.length === 0) {
            const { data: symbolData, error: symbolError } = await supabase.from('ai_pattern_memory')
              .select('*')
              .or(`symbol.eq.${symbolForPatternSearch},symbol.eq.${marketData.symbol?.replace('/', '') || ''},symbol.eq.ALL`)
              .order('total_occurrences', { ascending: false })
              .order('win_rate', { ascending: false })
              .limit(50);

            if (symbolError) {
              log('warn', 'Erro na busca por s√≠mbolo de pattern memory', {
                error: symbolError.message,
                symbol: symbolForPatternSearch
              });
            }

            if (symbolData && symbolData.length > 0) {
              patternMemoryData = symbolData;
              log('debug', 'Pattern Memory encontrado por s√≠mbolo', {
                count: symbolData.length,
                symbol: symbolForPatternSearch
              });
            }
          } else {
            log('debug', 'Pattern Memory encontrado (busca geral - todos os padr√µes)', {
              count: patternMemoryData.length
            });
          }
        }

        if (patternMemoryError) {
          log('warn', 'Erro ao buscar pattern memory', {
            error: patternMemoryError.message,
            patternName: patternNameForSearch,
            symbol: symbolForPatternSearch
          });
        }

        patternMemory = patternMemoryData || [];

        if (patternMemory.length === 0) {
          log('info', 'Pattern Memory vazio - ser√° populado quando trades atingirem TP/SL', {
            pattern: patternNameForSearch,
            symbol: symbolForPatternSearch,
            timeframe: marketData.timeframe,
            note: 'Pattern Memory s√≥ √© criado quando h√° trades finalizados (TP ou SL)'
          });
        } else {
          log('debug', 'Pattern Memory encontrado', {
            count: patternMemory.length,
            patterns: patternMemory.slice(0, 3).map(p => ({
              name: p.pattern_name,
              symbol: p.symbol,
              timeframe: p.timeframe,
              winRate: p.win_rate,
              occurrences: p.total_occurrences
            }))
          });
        }
        narratorKnowledgeCache.set(cacheKey, patternMemory);
      }
    } catch (error) {
      log('error', 'Erro ao buscar pattern memory', {
        error: error?.message
      });
      patternMemory = [];
    }
    // ‚úÖ Queries acima j√° foram executadas em paralelo acima
    console.log('üìö Conhecimento carregado:', (knowledge || [])?.length || 0, 'entradas');
    console.log('üéØ Pattern Memory carregado:', (patternMemory || [])?.length || 0, 'entradas');
    console.log('üìä Hist√≥rico de trades:', (tradeHistory || [])?.length || 0, 'entradas');
    console.log('üí¨ Feedback do narrador:', (narratorFeedback || [])?.length || 0, 'entradas');
    console.log('üîç Sinais anteriores:', (previousSignals || [])?.length || 0, 'entradas');
    console.log('üß† Learning progress:', (learningProgress || [])?.length || 0, 'linhas');
    // 3. CONSULTAR KNOWLEDGE BASE HIST√ìRICO ANTES DA AN√ÅLISE
    console.log('üß† Consultando Knowledge Base hist√≥rico...');
    log('debug', 'Iniciando busca de contexto hist√≥rico', {
      symbol: norm.withSlash,
      patternType: safePattern.type
    });
    const historicalContextStartTime = Date.now();
    let historicalContext;
    try {
      historicalContext = await getHistoricalContext(supabase, norm.withSlash, safePattern.type, knowledge || []);
      const historicalContextDuration = Date.now() - historicalContextStartTime;
      log('debug', 'Contexto hist√≥rico carregado com sucesso', {
        duration: `${historicalContextDuration}ms`,
        hasEarlyReturn: !historicalContext?.similarPatterns && !historicalContext?.recentFeedback
      });
    } catch (error) {
      const historicalContextDuration = Date.now() - historicalContextStartTime;
      log('error', 'Erro ao buscar contexto hist√≥rico', {
        error: error?.message || String(error),
        duration: `${historicalContextDuration}ms`
      });
      console.warn('‚ö†Ô∏è Erro ao buscar contexto hist√≥rico:', error);
      historicalContext = {
        similarPatterns: [],
        recentSignals: [],
        successRate: 0.5,
        recentFeedback: [],
        knowledgeMatches: [],
        patternFrequency: 0,
        isOverSignaled: false,
        avgConfidence: 50
      };
    }
    console.log('üìö Contexto hist√≥rico carregado:', {
      similarPatterns: historicalContext?.similarPatterns?.length || 0,
      successRate: historicalContext?.successRate || 0,
      recentFeedback: historicalContext?.recentFeedback?.length || 0,
      knowledgeMatches: historicalContext?.knowledgeMatches?.length || 0
    });
    // 4. An√°lise inteligente propriet√°ria COM CONTEXTO TEMPORAL + HIST√ìRICO
    log('debug', 'Preparando para an√°lise inteligente', {
      hasHistoricalContext: !!historicalContext,
      hasKlines: !!klines && Array.isArray(klines),
      klinesLength: klines?.length || 0
    });
    // Preparar candles para an√°lise de order book (se dispon√≠veis)
    let candlesForAnalysis = [];
    if (detectedPattern && klines && Array.isArray(klines) && klines.length >= 20) {
      candlesForAnalysis = klines.map(k => ({
        open: parseFloat(k[1]),
        high: parseFloat(k[2]),
        low: parseFloat(k[3]),
        close: parseFloat(k[4]),
        volume: parseFloat(k[5]),
        time: k[0]
      }));
    }

    // ‚úÖ CORRE√á√ÉO CR√çTICA: Declarar confidenceScore MUITO ANTES (antes de qualquer uso)
    // Inicializar com valor padr√£o, ser√° atualizado depois quando analysis for criado
    let confidenceScore = 50; // Valor padr√£o inicial

    // üõ°Ô∏è VALIDAR ENTRADA ANTES DE PROCESSAR (Fast-path early-exit)
    log('debug', 'Iniciando valida√ß√£o de entrada', {});
    let signalValidation = null;
    if (Array.isArray(candlesForAnalysis) && candlesForAnalysis.length >= 20) {
      try {
        cleanupSignalEntryCache(); // Limpar cache antigo periodicamente

        signalValidation = await validateSignalEntry(
          norm.binance,
          safeMarketData.timeframe || '1m',
          candlesForAnalysis,
          safeTechnicalIndicators,
          historicalContext
        );

        // üõ°Ô∏è PROTE√á√ÉO INTELIGENTE PARA 75x: 
        // - Bloqueia riscos CR√çTICOS (dados inv√°lidos, volatilidade extrema)
        // - Permite valida√ß√µes t√©cnicas com penalidade (sistema tem outras camadas de prote√ß√£o)
        if (signalValidation && !signalValidation.valid) {
          // üö® VALIDA√á√ïES CR√çTICAS: Bloquear completamente (risco extremo para 75x)
          const criticalReasons = [
            "Valores de candle inv√°lidos",      // Dados corrompidos
            "Dados de candle inv√°lidos",        // Dados insuficientes
            "Candle inv√°lido",                  // Estrutura inv√°lida
            "Par√¢metros inv√°lidos para valida√ß√£o", // Configura√ß√£o errada
            "Spike detectado (wick anormal)",   // Volatilidade extrema = liquida√ß√£o em 75x
            "Candle at√≠pico (3√ó maior)"         // Volatilidade extrema = risco de stop
          ];

          const isCritical = criticalReasons.some(reason =>
            signalValidation.reason?.includes(reason) ||
            signalValidation.reason === reason
          );

          if (isCritical) {
            // üö® BLOQUEAR: Riscos cr√≠ticos que podem causar liquida√ß√£o em 75x
            log('error', 'üö® Sinal bloqueado por valida√ß√£o CR√çTICA (75x safety)', {
              reason: signalValidation.reason,
              adjustment: signalValidation.confidenceAdjustment,
              leverage: '75x',
              risk: 'CRITICAL'
            });
            return new Response(JSON.stringify({
              success: false,
              reason: signalValidation.reason,
              score: 0,
              confidenceAdjustment: signalValidation.confidenceAdjustment,
              metadata: {
                validation: signalValidation,
                timestamp: new Date().toISOString(),
                blocked: true,
                reason: 'critical_validation_failed',
                leverage: '75x'
              }
            }), {
              status: 200,
              headers: {
                ...corsHeaders,
                'Content-Type': 'application/json'
              }
            });
          } else {
            // ‚ö†Ô∏è PERMITIR COM PENALIDADE: Valida√ß√µes t√©cnicas n√£o-cr√≠ticas
            // O sistema tem outras camadas de prote√ß√£o (score m√≠nimo, TradeVision AI, MTF, etc.)
            // que v√£o filtrar sinais ruins mesmo com valida√ß√£o t√©cnica falhando
            log('warn', '‚ö†Ô∏è Valida√ß√£o t√©cnica falhou - aplicando penalidade, outras camadas v√£o filtrar', {
              reason: signalValidation.reason,
              adjustment: signalValidation.confidenceAdjustment,
              leverage: '75x',
              note: 'Sistema tem m√∫ltiplas camadas de prote√ß√£o (score m√≠nimo, AI, MTF, risk management)'
            });
            // O ajuste de confian√ßa ser√° aplicado mais tarde no c√≥digo (linha ~4513)
            // Isso reduz o score, e se ficar abaixo do m√≠nimo (30-35), n√£o cria trade
          }
        }

        if (signalValidation && signalValidation.valid) {
          log('debug', 'Valida√ß√£o de entrada passou', {
            reason: signalValidation.reason,
            adjustment: signalValidation.confidenceAdjustment,
            metrics: signalValidation.metrics
          });
        }
      } catch (validationError) {
        log('warn', 'Erro na valida√ß√£o de entrada (continuando)', {
          error: validationError?.message || validationError?.toString(),
          errorType: typeof validationError
        });
        // Continuar sem valida√ß√£o se houver erro
        signalValidation = null;
      }
    } else {
      log('warn', 'Candles insuficientes para valida√ß√£o de entrada', {
        candlesCount: Array.isArray(candlesForAnalysis) ? candlesForAnalysis.length : 0,
        isArray: Array.isArray(candlesForAnalysis)
      });
    }

    // üöÄ NOVO: An√°lises avan√ßadas antes de analyzePatternIntelligently
    let orderBookAnalysis = null;
    let marketRegime = null;

    try {
      // Order Book Analysis (apenas se candles dispon√≠veis e score > 50)
      if (candlesForAnalysis.length >= 20) {
        orderBookAnalysis = await analyzeOrderBook(norm.binance, currentPrice, candlesForAnalysis);
        console.log('üìä Order Book Analysis:', orderBookAnalysis ? 'OK' : 'N/A');
      }

      // Market Regime Detection
      if (candlesForAnalysis.length >= 30) {
        marketRegime = detectMarketRegime(candlesForAnalysis, safeTechnicalIndicators);
        console.log('üìä Market Regime:', marketRegime?.regime || 'N/A');
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Erro nas an√°lises avan√ßadas (continuando):', error);
    }

    const analysis = await analyzePatternIntelligently(safePattern, safeMarketData, safeTechnicalIndicators, knowledge || [], multiTimeframeContext, {
      tradeHistory: tradeHistory || [],
      narratorFeedback: narratorFeedback || [],
      previousSignals: previousSignals || [],
      learningProgress: learningProgress || [],
      historicalContext: historicalContext,
      candles: candlesForAnalysis, // Passar candles para an√°lise de order book
      patternMemory: patternMemory || [],
      supabase: supabase, // üß† [RL] Passar supabase para buscar pesos din√¢micos
      orderBookAnalysis: orderBookAnalysis, // üöÄ NOVO: Order book analysis
      marketRegime: marketRegime, // üöÄ NOVO: Market regime
      leverage: body?.leverage || 1, // üöÄ NOVO: Leverage para HLS
      currentPrice: currentPrice // üîß CORRE√á√ÉO CR√çTICA: Passar pre√ßo validado para todas as fun√ß√µes
    });
    console.log('üß† An√°lise completa. Score:', analysis.confidenceScore);
    console.log('üîç Dados da an√°lise:', {
      pattern: pattern?.type,
      marketData: {
        symbol: marketData.symbol,
        price: marketData.price,
        volume: marketData.volume,
        change24h: marketData.change24h,
        timestamp: marketData.timestamp
      },
      technicalIndicators: {
        rsi_14: technicalIndicators?.rsi_14,
        volume_z_score: technicalIndicators?.volume_z_score,
        ema_9: technicalIndicators?.ema_9,
        ema_50: technicalIndicators?.ema_50
      },
      analysis: {
        confidenceScore: analysis.confidenceScore,
        recommendation: analysis.recommendation,
        confluences: analysis.confluences
      }
    });
    // ‚úÖ Log compacto: Conflu√™ncias da an√°lise (debug apenas)
    logConfluences('debug', 'Conflu√™ncias da an√°lise', analysis.confluences || []);
    // üÜï APLICAR APRENDIZADO DOS DADOS HIST√ìRICOS ANTES DA VALIDA√á√ÉO
    // Definir safeTimeframe antes de usar
    const currentTimeframe = typeof safeMarketData?.timeframe === 'string' && safeMarketData.timeframe.trim().length > 0 ? safeMarketData.timeframe : '1h';
    const historicalLearningAdjustment = applyHistoricalLearning({
      tradeHistory: tradeHistory || [],
      narratorFeedback: narratorFeedback || [],
      previousSignals: previousSignals || [],
      learningProgress: learningProgress || [],
      pattern: pattern,
      symbol: norm.withSlash,
      timeframe: currentTimeframe
    });

    if (historicalLearningAdjustment.adjustment !== 0) {
      analysis.confidenceScore = Math.max(0, Math.min(100,
        analysis.confidenceScore + historicalLearningAdjustment.adjustment
      ));
      if (historicalLearningAdjustment.reasons.length > 0) {
        analysis.confluences.push(...historicalLearningAdjustment.reasons);
        console.log(`üìö Aprendizado hist√≥rico aplicado: ${historicalLearningAdjustment.adjustment > 0 ? '+' : ''}${historicalLearningAdjustment.adjustment.toFixed(1)} pontos`);
        console.log(`   Raz√µes: ${historicalLearningAdjustment.reasons.join(', ')}`);
      }
    }

    // 4. VALIDA√á√ÉO CONTEXTUAL PROFUNDA COM TRADEVISION IA + MULTI-TIMEFRAME
    const tradeVisionValidation = await validateWithTradeVisionAI(analysis, pattern, marketData, technicalIndicators, knowledge || [], multiTimeframeContext, {
      tradeHistory: tradeHistory || [],
      narratorFeedback: narratorFeedback || [],
      previousSignals: previousSignals || [],
      historicalContext: historicalContext
    });
    console.log('ü§ñ Valida√ß√£o TradeVision IA:', tradeVisionValidation.recommendation);
    // üß† BLOCO 1: Mem√≥ria Neural Entre Sess√µes COM PATTERN WEIGHTS
    const neuralState = await loadNeuralState(supabase, marketData.symbol);
    console.log('üß† Estado neural:', neuralState ? 'Carregado' : 'Nova sess√£o');
    // üéØ APLICAR PATTERN WEIGHTS APRENDIDOS
    if (neuralState?.pattern_weights && Object.keys(neuralState.pattern_weights).length > 0) {
      const patternKey = pattern.type || analysis.patternDescription;
      const learnedWeight = neuralState.pattern_weights[patternKey];
      if (learnedWeight) {
        const successRate = learnedWeight.weight || 0.5;
        const adjustmentFactor = (successRate - 0.5) * 40; // -20 a +20 pontos
        analysis.confidenceScore = Math.max(0, Math.min(100, analysis.confidenceScore + adjustmentFactor));
        console.log(`üéì Aprendizado aplicado para "${patternKey}": ${successRate * 100}% sucesso ‚Üí ${adjustmentFactor > 0 ? '+' : ''}${adjustmentFactor.toFixed(0)} pontos`);
      }
    }
    // üõ°Ô∏è APLICAR AJUSTE DE VALIDA√á√ÉO DE ENTRADA (sempre aplicar, mesmo se valid: false)
    // üêõ FIX: Aplicar ajuste mesmo quando valida√ß√£o falha, para permitir sinais com alta confian√ßa
    if (signalValidation && typeof signalValidation.confidenceAdjustment === 'number') {
      analysis.confidenceScore = Math.max(0, Math.min(100,
        analysis.confidenceScore + signalValidation.confidenceAdjustment
      ));
      if (signalValidation.confidenceAdjustment !== 0) {
        const status = signalValidation.valid ? '‚úÖ' : '‚ö†Ô∏è';
        console.log(`üõ°Ô∏è ${status} Ajuste de valida√ß√£o: ${signalValidation.confidenceAdjustment > 0 ? '+' : ''}${signalValidation.confidenceAdjustment.toFixed(0)} pontos (${signalValidation.reason})`);
      }
    }

    // =======================
    // üéØ Aplicar modo narrador (FLEX/STANDARD)
    // =======================
    // Calcular volatilidade (ATR percentual)
    // üîß CORRE√á√ÉO: Usar currentPrice validado (j√° est√° no escopo, n√£o precisa de additionalData aqui)
    const atr = technicalIndicators?.atr || 0;
    // currentPrice j√° foi validado anteriormente (linha ~3885), usar diretamente
    const currentPriceNum = currentPrice || 0;
    const volatilityPct = currentPriceNum > 0 ? (atr / currentPriceNum) * 100 : 0;

    // Mapear MTF alignment
    const mtfConfirmation = multiTimeframeContext?.confirmation || 'neutral';
    let mtfAlignment = 'neutral';
    if (mtfConfirmation === 'bullish' || mtfConfirmation === 'bearish') {
      mtfAlignment = 'aligned';
    } else if (mtfConfirmation === 'divergent') {
      mtfAlignment = 'divergent';
    }

    // Obter tend√™ncias global e local
    const trendGlobal = multiTimeframeContext?.m30?.macro_trend ||
      multiTimeframeContext?.m30?.trend_direction ||
      multiTimeframeContext?.m15?.trend_direction ||
      'neutral';
    const trendLocal = multiTimeframeContext?.m1?.trend_direction ||
      multiTimeframeContext?.m5?.trend_direction ||
      'neutral';

    // Calcular Kill Switch para usar no modo narrador
    let killSwitchActive = false;
    try {
      if (candlesForAnalysis && candlesForAnalysis.length >= 20) {
        const killSwitch = detectMarketKillSwitch(candlesForAnalysis, orderBookAnalysis, technicalIndicators);
        killSwitchActive = killSwitch?.shouldBlock || false;
      }
    } catch (ksError) {
      console.warn('‚ö†Ô∏è Erro ao calcular Kill Switch para modo narrador (continuando):', ksError);
    }

    // Obter leverage (padr√£o 75x)
    const leverage = body?.leverage || 75;

    // Aplicar modo narrador
    const modeApplied = applyNarratorMode(analysis.confidenceScore, {
      mtfAlignment: mtfAlignment,
      killSwitch: killSwitchActive,
      volatilityPct: volatilityPct,
      volumeZ: technicalIndicators?.volume_z_score || 0,
      trendGlobal: trendGlobal,
      trendLocal: trendLocal,
      leverage: leverage
    });

    // üîç DEBUG: Log antes e depois do modo
    const scoreBeforeMode = analysis.confidenceScore;
    analysis.confidenceScore = modeApplied.finalScore;
    const scoreAfterMode = analysis.confidenceScore;

    // ‚úÖ NOVO: BOOST GERAL DE SCORES - Calibrar para aumentar scores finais
    // Objetivo: Score de 30% ‚Üí 38% (+8 pontos)
    // Aplicar boost proporcional: scores baixos ganham mais boost
    const scoreBeforeBoost = analysis.confidenceScore;
    let scoreBoost = 0;

    // ‚úÖ F√ìRMULA CALIBRADA: Score 30 ‚Üí +8 = 38
    if (scoreBeforeBoost <= 30) {
      // Scores ‚â§30: Boost fixo de +8 pontos (30 ‚Üí 38)
      scoreBoost = 8;
    } else if (scoreBeforeBoost < 40) {
      // Scores 31-39: Boost decrescente de +8 a +5
      scoreBoost = 8 - (scoreBeforeBoost - 30) * 0.3; // +8 para 30, +5 para 40
    } else if (scoreBeforeBoost < 60) {
      // Scores 40-60: Boost moderado (+5 a +3 pontos)
      scoreBoost = 5 - (scoreBeforeBoost - 40) * 0.1; // +5 para 40, +3 para 60
    } else if (scoreBeforeBoost < 80) {
      // Scores 60-80: Boost leve (+3 a +1 pontos)
      scoreBoost = 3 - (scoreBeforeBoost - 60) * 0.1; // +3 para 60, +1 para 80
    } else {
      // Scores ‚â•80: Boost m√≠nimo (+1 ponto)
      scoreBoost = 1;
    }

    // Garantir que boost seja sempre positivo e arredondado
    scoreBoost = Math.max(1, Math.round(scoreBoost));

    analysis.confidenceScore = Math.min(99, Math.max(1, analysis.confidenceScore + scoreBoost));
    const scoreAfterBoost = analysis.confidenceScore;

    console.log(`üéØ Modo ${NARRATOR_MODE} aplicado: Score ${scoreBeforeMode.toFixed(1)} ‚Üí ${scoreAfterMode.toFixed(1)} (${scoreAfterMode - scoreBeforeMode > 0 ? '+' : ''}${(scoreAfterMode - scoreBeforeMode).toFixed(1)})`);
    console.log(`üìà Score Boost aplicado: ${scoreBeforeBoost.toFixed(1)} ‚Üí ${scoreAfterBoost.toFixed(1)} (+${scoreBoost.toFixed(0)} pontos)`);

    if (modeApplied.notes.length > 0) {
      // Adicionar notas √†s conflu√™ncias
      if (!Array.isArray(analysis.confluences)) {
        analysis.confluences = [];
      }
      analysis.confluences.push(...modeApplied.notes);
      console.log(`üéØ Notas do modo: ${modeApplied.notes.join(' | ')}`);
    }

    // üß† BLOCO 2: Score Consolidado Multi-Frame
    const consolidatedScore = await calculateConsolidatedScore(supabase, multiTimeframeContext, neuralState);
    console.log('üìä Score consolidado:', consolidatedScore);
    // üß† BLOCO 3: Consci√™ncia Temporal
    const temporalAwareness = await evaluateTemporalAwareness(supabase, norm.withSlash, multiTimeframeContext);
    console.log('‚è±Ô∏è Tend√™ncia h√°', temporalAwareness.duration, 'minutos');
    // 5. Filtrar sinais ruins COM VALIDA√á√ÉO MULTI-TIMEFRAME + HIST√ìRICO (MUITO PERMISSIVO)
    const rejectReasons = [];
    let shouldReject = false;

    // Verificar cada condi√ß√£o de rejei√ß√£o separadamente para logs detalhados
    if (tradeVisionValidation.recommendation === 'STRONG_AVOID') {
      shouldReject = true;
      rejectReasons.push('TradeVision AI: STRONG_AVOID');
    }
    if (analysis.confidenceScore < 0.001 && tradeVisionValidation.aiConfidence < 0.001) {
      shouldReject = true;
      rejectReasons.push(`Score muito baixo: ${analysis.confidenceScore.toFixed(3)} / AI: ${tradeVisionValidation.aiConfidence.toFixed(3)}`);
    }
    // ‚úÖ AJUSTE: MTF divergent n√£o bloqueia mais, apenas penaliza (ajustado em outro lugar)
    // Removido bloqueio autom√°tico - apenas penaliza√ß√£o de score
    // ‚úÖ AJUSTE: Over-signaled n√£o bloqueia mais, apenas penaliza (ajustado em outro lugar)
    // Bloquear apenas se over-signaled + score < 20 (muito baixo)
    if (historicalContext?.isOverSignaled && analysis.confidenceScore < 20) {
      shouldReject = true;
      rejectReasons.push(`Over-signaled hist√≥rico + score muito baixo: ${analysis.confidenceScore.toFixed(1)}`);
    }

    // üîç DEBUG: Log detalhado do motivo de rejei√ß√£o (sempre logar para debug)
    if (shouldReject) {
      log('warn', 'Sinal rejeitado - filtros aplicados', {
        symbol: norm.withSlash,
        timeframe: marketData.timeframe,
        pattern: safePattern.type,
        reasons: rejectReasons,
        recommendation: tradeVisionValidation.recommendation,
        confidenceScore: analysis.confidenceScore,
        aiConfidence: tradeVisionValidation.aiConfidence,
        mtfShouldReject: multiTimeframeContext.shouldReject,
        mtfConfirmation: multiTimeframeContext.confirmation,
        mtfRejectionReason: multiTimeframeContext.rejectionReason,
        isOverSignaled: historicalContext?.isOverSignaled,
        reasoning: tradeVisionValidation.reasoning,
        confluencesCount: analysis.confluences?.length || 0
      });
      console.log('‚ùå Sinal rejeitado - Motivos:', rejectReasons.join(' | '));
      return new Response(JSON.stringify({
        success: false,
        reason: multiTimeframeContext.shouldReject ? 'rejected_by_timeframe_analysis' : 'rejected_by_ai',
        score: analysis.confidenceScore,
        aiConfidence: tradeVisionValidation.aiConfidence,
        recommendation: tradeVisionValidation.recommendation,
        reasoning: tradeVisionValidation.reasoning,
        timeframeRejection: multiTimeframeContext.rejectionReason
      }), {
        status: 200,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
    // 6. Gerar sinal ENRIQUECIDO com valida√ß√£o TradeVision IA + MULTI-TIMEFRAME
    const detectionTime = new Date();
    const analysisTime = Date.now() - (safePattern.detected_at || Date.now());
    const actionWindow = tradeVisionValidation.suggestedActionWindow || 300;
    // Formatar conflu√™ncias em strings leg√≠veis para o frontend
    // üõ°Ô∏è GARANTIR que sempre temos um array v√°lido
    const rawConfluences = analysis.confluences || [];
    // ‚úÖ Log compacto: Conflu√™ncias brutas (debug apenas)
    logConfluences('debug', 'Conflu√™ncias brutas', rawConfluences);
    const activeConfluences = Array.isArray(rawConfluences) && rawConfluences.length > 0 ? rawConfluences.map((c) => {
      if (typeof c === 'string') return c;
      if (c?.label) return c.label;
      if (c?.type && c?.detail) return `${c.type}: ${c.detail}`;
      if (c?.type && c?.value) return `${c.type} ${c.value}`;
      // Se √© objeto, tentar stringify apenas se n√£o for muito grande
      if (typeof c === 'object' && c !== null) {
        try {
          const str = JSON.stringify(c);
          if (str.length < 100) return str;
          return String(c);
        } catch {
          return String(c);
        }
      }
      if (c?.type) return c.type;
      return '';
    }).filter((c) => c && c.trim().length > 0) // üîß Filtro mais permissivo
      : [];
    // ‚úÖ Log compacto: Conflu√™ncias formatadas (debug apenas)
    logConfluences('debug', 'Conflu√™ncias formatadas', activeConfluences);
    // Sanitiza√ß√£o e defaults para evitar null/valores inv√°lidos em campos obrigat√≥rios
    const safePatternRaw = safePattern?.type || analysis?.patternDescription;
    const safePatternName = typeof safePatternRaw === 'string' && safePatternRaw.trim().length > 0 ? safePatternRaw.trim() : 'Estrutura t√©cnica';
    const safeFigure = typeof safePattern?.type === 'string' && safePattern.type.trim().length > 0 ? safePattern.type.trim() : 'Estrutura detectada';
    // ‚ö†Ô∏è NOTA: safeProbability ser√° calculado DEPOIS da corre√ß√£o de discrep√¢ncia de scores
    // Por enquanto, apenas definir vari√°vel tempor√°ria - ser√° sobrescrita depois
    let safeProbability = 50; // Valor tempor√°rio, ser√° corrigido abaixo
    const priceNum = currentPrice; // üîß Usar pre√ßo validado e fresco
    const priceStr = Number.isFinite(priceNum) ? priceNum.toString() : '0';
    const safeSymbol = typeof safeMarketData?.symbol === 'string' && safeMarketData.symbol.trim().length > 0 ? safeMarketData.symbol : 'BTC/USDT';
    const safeTimeframe = typeof safeMarketData?.timeframe === 'string' && safeMarketData.timeframe.trim().length > 0 ? safeMarketData.timeframe : '1h';
    // üõ°Ô∏è FALLBACK: Se n√£o h√° conflu√™ncias, criar uma b√°sica baseada na an√°lise
    if (activeConfluences.length === 0) {
      log('warn', 'Nenhuma conflu√™ncia encontrada, criando fallback', {
        confidenceScore: analysis.confidenceScore,
        signalType: analysis.signalType
      });
      // Criar conflu√™ncias b√°sicas baseadas nos dados dispon√≠veis
      if (analysis.summary) {
        activeConfluences.push(analysis.summary);
      }
      if (analysis.marketContext) {
        activeConfluences.push(`Contexto: ${analysis.marketContext}`);
      }
      if (analysis.riskNote) {
        activeConfluences.push(`Risco: ${analysis.riskNote}`);
      }
      if (safePattern?.type) {
        activeConfluences.push(`Padr√£o detectado: ${safePattern.type}`);
      }
      if (analysis.confidenceScore) {
        activeConfluences.push(`Confian√ßa: ${analysis.confidenceScore}%`);
      }
      // Se ainda estiver vazio, adicionar uma mensagem padr√£o
      if (activeConfluences.length === 0) {
        activeConfluences.push(`An√°lise t√©cnica gerada para ${safeSymbol} ${safeTimeframe}`);
      }
    }
    log('debug', 'Conflu√™ncias formatadas', {
      count: activeConfluences.length,
      first: activeConfluences[0]?.substring(0, 50)
    });
    // ‚úÖ Log compacto: Conflu√™ncias finais (debug apenas)
    logConfluences('debug', 'Conflu√™ncias finais', activeConfluences);
    // Normalizar signal_type para obedecer a constraint do DB
    const normalizedSignalType = (() => {
      const raw = String(analysis?.signalType || '').trim().toUpperCase();
      if (raw === 'BUY' || raw === 'SELL' || raw === 'NEUTRAL' || raw === 'WAIT') return raw;
      if (raw === 'BULLISH') return 'BUY';
      if (raw === 'BEARISH') return 'SELL';
      return 'NEUTRAL';
    })();
    // üõ°Ô∏è CONTROLE DE RISCO PARA ALTA LEVERAGE (75x-100x+)
    let riskManagement = null;
    try {
      const userLeverage = body.leverage || 100; // Default 100x se n√£o informado
      const userEquity = body.userEquity || body.capital || 1000; // Default $1,000 se n√£o informado
      const userAcknowledged = body.riskAcknowledged || false;
      // Calcular StopPct baseado em ATR ou fallback
      // üêõ FIX: Usar currentPrice validado (j√° buscado da Binance se necess√°rio)
      const currentPriceForRisk = (currentPrice && currentPrice > 0 && Number.isFinite(currentPrice))
        ? currentPrice
        : (Number.isFinite(priceNum) && priceNum > 0 ? priceNum : parseFloat(priceStr) || 0);
      const atr = technicalIndicators?.atr || 0;
      const atrPct = currentPriceForRisk > 0 && atr > 0 ? atr / currentPriceForRisk : 0.002;
      const stopPct = Math.max(0.001, atrPct * 1.2); // m√≠nimo 0.1%
      const volumeZScore = technicalIndicators?.volume_z_score || 0;
      const actionWindowSec = tradeVisionValidation.suggestedActionWindow || 300;
      riskManagement = validateHighLeverageRisk({
        equity: userEquity,
        leverage: userLeverage,
        stopPct,
        volumeZScore,
        timeframe: safeTimeframe,
        signalType: analysis.signalType || normalizedSignalType || 'NEUTRAL',
        userAcknowledged,
        actionWindowSec
      });
      // Adicionar ao risk_note (sem sobrescrever, apenas adicionar)
      if (riskManagement.riskNote && riskManagement.riskNote !== 'Risco controlado conforme alavancagem') {
        analysis.riskNote = (analysis.riskNote || '') + (analysis.riskNote ? ' | ' : '') + riskManagement.riskNote;
      }
      console.log('üõ°Ô∏è [High Leverage Risk Control] Validado:', {
        leverage: userLeverage,
        equity: userEquity,
        notional: riskManagement.notional,
        risk_pct: (riskManagement.riskPct * 100).toFixed(2) + '%',
        max_risk_pct: (riskManagement.maxRiskPct * 100).toFixed(2) + '%',
        explosive: riskManagement.isExplosive,
        requiresAck: riskManagement.requiresAck,
        warning: riskManagement.warning
      });
    } catch (riskError) {
      console.warn('‚ö†Ô∏è [Risk Control] Erro na valida√ß√£o de risco (continuando):', riskError?.message || riskError);
      // NUNCA QUEBRA O FLUXO - continua normalmente
    }
    // Extrair valores de indicadores t√©cnicos para compatibilidade com Pattern Memory Engine
    const rsiValue = safeTechnicalIndicators?.rsi_14 || technicalIndicators?.rsi_14 || analysis?.technicalIndicators?.rsi_14 || null;
    // Calcular MACD histogram (macd - macd_signal)
    const macdValue = safeTechnicalIndicators?.macd || serverInd?.macd || 0;
    const macdSignalValue = safeTechnicalIndicators?.macd_signal || serverInd?.macd_signal || 0;
    const macdHistogram = macdValue - macdSignalValue;
    // Calcular BB position (posi√ß√£o do pre√ßo entre as bandas)
    const bbData = serverInd?.bollinger_bands || {};
    const bbPosition = bbData.upper && bbData.lower && currentPrice ?
      ((currentPrice - bbData.lower) / (bbData.upper - bbData.lower) * 100) : null;
    const trendValue = normalizedSignalType === 'BUY' ? 'bullish' : normalizedSignalType === 'SELL' ? 'bearish' : 'neutral';
    const narrativeText = analysis.narration?.analystComment || analysis.summary || '';

    // Calcular entry_price, stop_price, target_price para salvar diretamente na tabela
    // üêõ FIX: Usar currentPrice (j√° validado e buscado da Binance se necess√°rio) em vez de priceNum/priceStr
    let baseEntryPrice = (currentPrice && currentPrice > 0 && Number.isFinite(currentPrice))
      ? currentPrice
      : (Number.isFinite(priceNum) && priceNum > 0 ? priceNum : parseFloat(priceStr) || 0);

    // ‚úÖ NOVA L√ìGICA: Calcular entry_price com reteste OU rompimento para padr√µes que precisam confirma√ß√£o
    // ‚úÖ NOVO: Entrada antecipada quando probabilidade >= 65%
    let entryPrice = baseEntryPrice;
    const candles = candlesForAnalysis || [];

    // ‚úÖ CORRE√á√ÉO CR√çTICA: Atualizar confidenceScore com valor real de analysis
    // confidenceScore j√° foi declarado antes (linha ~6660), apenas atualizar valor
    confidenceScore = analysis?.confidenceScore || confidenceScore || 50;

    // ‚úÖ CALCULAR PROBABILIDADE PARA ENTRADA ANTECIPADA
    // Buscar RASP e forecast das vari√°veis calculadas anteriormente (linhas 10047 e 10083)
    // Eles est√£o no escopo da fun√ß√£o, mas precisamos buscar do analysis.metadata ou recalcular
    // Vou buscar do analysis.metadata que ser√° preenchido abaixo, ou usar valores do escopo se dispon√≠veis
    let rasp = null;
    let forecast = null;

    // Tentar buscar do escopo (se dispon√≠vel) ou recalcular
    try {
      // RASP e forecast s√£o calculados nas linhas 10065 e 10101, mas est√£o em escopo diferente
      // Vou recalcular aqui para garantir disponibilidade usando vari√°veis do escopo atual
      // ‚úÖ CORRE√á√ÉO: confidenceScore j√° foi declarado acima, ent√£o pode ser usado com seguran√ßa
      const mtfScore = multiTimeframeContext?.confirmation === 'bullish' || multiTimeframeContext?.confirmation === 'bearish' ? 70 : 50;
      const patternScore = confidenceScore; // ‚úÖ Agora pode usar confidenceScore diretamente (j√° declarado acima)
      const volumeScore = safeTechnicalIndicators?.volume_z_score ? (safeTechnicalIndicators.volume_z_score * 10 + 50) : 50;
      const orderBookScore = orderBookAnalysis ? (Math.abs(orderBookAnalysis.imbalance || 0) * 50 + 50) : 50;
      const regimeScore = marketRegime?.scoreAdjustment ? (marketRegime.scoreAdjustment + 50) : 50;
      rasp = calculateRASP(mtfScore, patternScore, volumeScore, orderBookScore, regimeScore);
      forecast = forecastNextCandle(candles, safeTechnicalIndicators || technicalIndicators);
    } catch (e) {
      console.warn('‚ö†Ô∏è Erro ao calcular RASP/forecast para entrada antecipada:', e);
    }

    // Calcular probabilidade combinada (RASP ou forecast, o que for maior)
    let combinedProbability = 0;
    if (rasp && rasp.probability) {
      combinedProbability = rasp.probability * 100; // Converter de 0-1 para 0-100
    }
    if (forecast) {
      const forecastProb = normalizedSignalType === 'BUY'
        ? forecast.probabilityUp * 100
        : forecast.probabilityDown * 100;
      combinedProbability = Math.max(combinedProbability, forecastProb);
    }

    // ‚úÖ NOVA L√ìGICA H√çBRIDA: Decidir estrat√©gia baseado no padr√£o + regime de mercado
    // - OB/FVG ‚Üí 1¬∫ toque (captura zona institucional)
    // - Breakout patterns ‚Üí confirma√ß√£o (evita violinadas)
    // - Candlestick em consolida√ß√£o ‚Üí 1¬∫ toque
    const entryStrategy = getEntryStrategy(safePatternName, marketRegime?.regime);
    console.log(`üéØ [Entry Strategy] ${safePatternName}: ${entryStrategy.strategy} - ${entryStrategy.reason}`);

    // ‚úÖ ENTRADA ANTECIPADA: Se probabilidade >= 65%, entrar no pre√ßo atual (sem esperar confirma√ß√£o)
    if (combinedProbability >= 65) {
      entryPrice = baseEntryPrice; // Entrar no pre√ßo atual
      console.log(`üöÄ [Entrada Antecipada] Probabilidade ${combinedProbability.toFixed(1)}% >= 65% - Entry no pre√ßo atual: ${entryPrice.toFixed(2)}`);
      if (Array.isArray(activeConfluences)) {
        activeConfluences.push(`üöÄ Entrada antecipada (probabilidade ${combinedProbability.toFixed(1)}%)`);
      }
    }
    // ‚úÖ PRIMEIRO TOQUE: OB/FVG e candlesticks em consolida√ß√£o entram imediatamente na zona
    else if (entryStrategy.strategy === 'FIRST_TOUCH' && safePatternName && candles.length >= 5) {
      // Detectar zona do OB ou FVG
      const normalized = String(safePatternName).toLowerCase();
      let zoneEntry = baseEntryPrice;

      if (normalized.includes('order block') || normalized.includes('orderblock') || normalized.includes('ob ')) {
        const obZone = detectOrderBlockZone(candles, normalized);
        if (obZone) {
          // BUY: entrar no TOPO do OB (melhor R:R)
          // SELL: entrar no FUNDO do OB (melhor R:R)
          zoneEntry = normalizedSignalType === 'BUY' ? obZone.top : obZone.bottom;
          console.log(`üéØ [1¬∫ Toque OB] Zone: ${obZone.bottom.toFixed(2)} - ${obZone.top.toFixed(2)} | Entry: ${zoneEntry.toFixed(2)}`);
        }
      } else if (normalized.includes('fvg') || normalized.includes('fair value gap')) {
        const fvgZone = detectFVGZone(candles, normalized);
        if (fvgZone) {
          // BUY: entrar no 50% do FVG (meio do gap)
          // SELL: entrar no 50% do FVG (meio do gap)
          zoneEntry = (fvgZone.top + fvgZone.bottom) / 2;
          console.log(`üéØ [1¬∫ Toque FVG] Zone: ${fvgZone.bottom.toFixed(2)} - ${fvgZone.top.toFixed(2)} | Entry: ${zoneEntry.toFixed(2)} (50%)`);
        }
      }

      // Verificar se pre√ßo atual est√° pr√≥ximo da zona (dentro de 0.3%)
      if (isPriceNearRetestZone(zoneEntry, baseEntryPrice, 0.3)) {
        entryPrice = zoneEntry;
        console.log(`‚úÖ [1¬∫ Toque] Padr√£o ${safePatternName} - Entry na zona: ${entryPrice.toFixed(2)} (regime: ${marketRegime?.regime || 'unknown'})`);
        if (Array.isArray(activeConfluences)) {
          activeConfluences.push(`üéØ Entrada no 1¬∫ toque (${entryStrategy.reason})`);
        }
      } else {
        entryPrice = baseEntryPrice;
        console.log(`‚è≥ [1¬∫ Toque] Padr√£o ${safePatternName} - Aguardando toque na zona. Pre√ßo: ${baseEntryPrice.toFixed(2)}, Zona: ${zoneEntry.toFixed(2)}`);
      }
    }
    // ‚úÖ CONFIRMA√á√ÉO: Breakout patterns aguardam reteste ou rompimento
    else if (safePatternName && candles.length >= 5 && patternRequiresRetest(safePatternName)) {
      // ‚úÖ PRIORIDADE 1: Verificar se h√° rompimento (breakout) - entrar no rompimento
      const breakoutPrice = detectBreakoutEntryPrice(safePatternName, candles, normalizedSignalType, baseEntryPrice);

      if (breakoutPrice && breakoutPrice > 0) {
        // H√° rompimento detectado ‚Üí entrar no rompimento
        entryPrice = breakoutPrice;
        console.log(`‚úÖ [Rompimento] Padr√£o ${safePatternName} - Entry no rompimento: ${entryPrice.toFixed(2)} (original: ${baseEntryPrice.toFixed(2)})`);
        if (Array.isArray(activeConfluences)) {
          activeConfluences.push(`üìä Rompimento t√©cnico observado - Caracter√≠sticas de rompimento identificadas.`);
        }
      } else {
        // ‚úÖ PRIORIDADE 2: Verificar se h√° reteste - entrar no reteste
        const retestPrice = calculateRetestEntryPrice(safePatternName, candles, baseEntryPrice, normalizedSignalType);

        // Verificar se o pre√ßo atual est√° pr√≥ximo da zona de reteste (dentro de 0.5%)
        if (isPriceNearRetestZone(retestPrice, baseEntryPrice, 0.5)) {
          // Pre√ßo est√° na zona de reteste - usar pre√ßo de reteste
          entryPrice = retestPrice;
          console.log(`‚úÖ [Reteste] Padr√£o ${safePatternName} - Entry ajustado para reteste: ${entryPrice.toFixed(2)} (original: ${baseEntryPrice.toFixed(2)})`);
        } else {
          // Pre√ßo ainda n√£o chegou na zona de reteste - usar pre√ßo atual mas adicionar nota
          entryPrice = baseEntryPrice;
          console.log(`‚è≥ [Aguardando] Padr√£o ${safePatternName} - Aguardando rompimento ou reteste. Pre√ßo atual: ${baseEntryPrice.toFixed(2)}, Zona de reteste: ${retestPrice.toFixed(2)}`);
          if (Array.isArray(activeConfluences)) {
            activeConfluences.push(`‚è≥ Aguardar rompimento ou reteste da zona em ${retestPrice.toFixed(2)}`);
          }
        }
      }
    }

    const targets = analysis.targets || null;

    // üéØ NOVA L√ìGICA: Calcular stop baseado na zona de invalida√ß√£o do padr√£o (mais pr√≥ximo)
    let stopPrice = null;

    // ‚úÖ PRIORIDADE 1: Tentar calcular stop baseado no padr√£o (zona de invalida√ß√£o)
    if (safePatternName && candles.length >= 5) {
      stopPrice = calculatePatternStopPrice(safePatternName, candles, entryPrice, normalizedSignalType);
      if (stopPrice && stopPrice > 0) {
        console.log(`‚úÖ [Stop Pattern] Padr√£o ${safePatternName} - Stop calculado pela zona de invalida√ß√£o: ${stopPrice.toFixed(2)}`);
      }
    }

    // ‚úÖ PRIORIDADE 2: Usar stop dos targets se dispon√≠vel
    if (!stopPrice && targets?.sl) {
      stopPrice = targets.sl;
    }

    // ‚úÖ PRIORIDADE 3: Fallback - stop padr√£o 0.45% do entry (ajustado para equilibrar prote√ß√£o e espa√ßo)
    if (!stopPrice || stopPrice <= 0) {
      stopPrice = normalizedSignalType === 'BUY' ? entryPrice * 0.9955 : entryPrice * 1.0045; // ‚úÖ AJUSTE: 0.45% do entry
      console.log(`‚ö†Ô∏è [Stop Fallback] Usando stop padr√£o: ${stopPrice.toFixed(2)} (0.45% do entry)`);
    }
    // ‚úÖ CORRE√á√ÉO CR√çTICA: Target deve respeitar m√≠nimo de 1.2% (n√£o 0.65%)
    // Calcular target inicial respeitando m√≠nimo do s√≠mbolo
    const symbolConfig = getSymbolConfig(norm.withSlash);
    const minTargetMultiplier = 1 + (symbolConfig.minTargetPct / 100);
    let targetPrice = targets?.tp1 || (normalizedSignalType === 'BUY'
      ? entryPrice * minTargetMultiplier  // BUY: entry * 1.012 (m√≠nimo 1.2%)
      : entryPrice * (2 - minTargetMultiplier)); // SELL: entry * 0.988 (m√≠nimo 1.2%)

    // üéØ VALIDA√á√ÉO: Se os valores parecem ser diferen√ßas (muito pequenos), converter para pre√ßo absoluto
    if (entryPrice > 0) {
      // Se stopPrice √© muito pequeno (< 1% do entry), pode ser diferen√ßa - converter
      if (stopPrice > 0 && stopPrice < entryPrice * 0.01) {
        stopPrice = normalizedSignalType === 'BUY'
          ? entryPrice - stopPrice  // BUY: entry - diferen√ßa
          : entryPrice + stopPrice; // SELL: entry + diferen√ßa
        log('debug', 'Stop price convertido de diferen√ßa para pre√ßo absoluto', {
          original: targets?.sl,
          converted: stopPrice,
          entryPrice,
          signalType: normalizedSignalType
        });
      }

      // Se targetPrice √© muito pequeno (< 1% do entry), pode ser diferen√ßa - converter
      if (targetPrice > 0 && targetPrice < entryPrice * 0.01) {
        targetPrice = normalizedSignalType === 'BUY'
          ? entryPrice + targetPrice  // BUY: entry + diferen√ßa
          : entryPrice - targetPrice; // SELL: entry - diferen√ßa
        log('debug', 'Target price convertido de diferen√ßa para pre√ßo absoluto', {
          original: targets?.tp1,
          converted: targetPrice,
          entryPrice,
          signalType: normalizedSignalType
        });
      }

      // üéØ Garantir que valores s√£o razo√°veis (dentro de 50% do entry)
      if (stopPrice > 0 && Math.abs(stopPrice - entryPrice) > entryPrice * 0.5) {
        // Recalcular com fallback seguro (0.8% - aumentado de 0.2%)
        stopPrice = normalizedSignalType === 'BUY' ? entryPrice * 0.992 : entryPrice * 1.008;
        log('warn', 'Stop price inv√°lido, usando fallback', { original: targets?.sl, fallback: stopPrice });
      }

      // ‚úÖ VALIDA√á√ÉO: Garantir stop m√≠nimo de 0.5% (prote√ß√£o contra stops muito curtos)
      const stopDistancePct = Math.abs(stopPrice - entryPrice) / entryPrice;
      if (stopDistancePct < 0.005) { // Menos de 0.5%
        stopPrice = normalizedSignalType === 'BUY' ? entryPrice * 0.995 : entryPrice * 1.005; // 0.5% m√≠nimo
        log('warn', 'Stop muito curto, ajustando para m√≠nimo 0.5%', {
          originalDistance: (stopDistancePct * 100).toFixed(2) + '%',
          newStop: stopPrice.toFixed(2)
        });
      }

      if (targetPrice > 0 && Math.abs(targetPrice - entryPrice) > entryPrice * 0.5) {
        // Recalcular com fallback seguro
        // ‚úÖ AJUSTE: Take profit reduzido em 40% (de 1% para 0.6%)
        targetPrice = normalizedSignalType === 'BUY' ? entryPrice * 1.006 : entryPrice * 0.994;
        log('warn', 'Target price inv√°lido, usando fallback', { original: targets?.tp1, fallback: targetPrice });
      }
    }

    const directionValue = normalizedSignalType === 'BUY' ? 'BUY' : normalizedSignalType === 'SELL' ? 'SELL' : null;

    // üéØ Log para debug
    log('debug', 'Valores de pre√ßo calculados para sinal', {
      entryPrice: entryPrice.toFixed(2),
      stopPrice: stopPrice.toFixed(2),
      targetPrice: targetPrice.toFixed(2),
      symbol: norm.withSlash,
      signalType: normalizedSignalType,
      hasTargets: !!targets
    });

    // ‚úÖ CORRE√á√ÉO CR√çTICA: Definir confidenceScore ANTES de criar signalData (usado em metadata.technicalScore)
    // ============================================================================
    // ‚úÖ UNIFICA√á√ÉO DE SCORES - DOCUMENTA√á√ÉO
    // ============================================================================
    // realScore: Score REAL ap√≥s todos os filtros e penalidades
    // consolidatedScore: Score consolidado interno (baseline bruto, usado apenas para valida√ß√£o)
    // uiScore: Score que SEMPRE aparece no frontend (sempre realScore)
    // validationScore: Score usado para valida√ß√£o de trades (pode ser consolidatedScore se houver discrep√¢ncia grande)
    // 
    // REGRA CR√çTICA:
    // - uiScore: SEMPRE = realScore (para exibi√ß√£o no frontend)
    // - validationScore: Usado para decidir se pode criar trade (pode ser consolidatedScore apenas em casos espec√≠ficos)
    // ============================================================================
    const realScore = analysis.confidenceScore || 0; // ‚úÖ Score REAL ap√≥s filtros e penalidades

    // ‚úÖ REAL SCORE ‚Üí √â O QUE APARECE NO FRONT SEMPRE
    const uiScore = realScore;

    // ‚úÖ VALIDATION SCORE ‚Üí APENAS PARA ELEGIBILIDADE DE TRADE
    let validationScore = realScore;

    // ‚úÖ CORRE√á√ÉO: Salvar originalConfidenceScore para uso posterior (compatibilidade com c√≥digo existente)
    const originalConfidenceScore = realScore; // Score original antes de qualquer ajuste

    // ‚úÖ CORRE√á√ÉO CR√çTICA: Sistema de penaliza√ß√£o proporcional ao inv√©s de reset bin√°rio
    // ANTES: Resetava para realScore quando discrep√¢ncia > 25 e consolidatedScore < 55
    // AGORA: Aplica penaliza√ß√£o proporcional, preservando scores intermedi√°rios
    const scoreDiff = Math.abs(consolidatedScore - realScore);
    const isRealScoreTooLow = realScore < 40 && consolidatedScore >= 55; // Se realScore < 40 mas consolidatedScore >= 55

    // ‚úÖ CORRE√á√ÉO PRINCIPAL: Penaliza√ß√£o proporcional ao inv√©s de reset total
    if (scoreDiff > 25) {
      // ‚úÖ NOVO: Se realScore √© muito baixo (< 20) ou TradeVision IA retornou AVOID, SEMPRE usar realScore
      const shouldUseRealScore = realScore < 20 ||
        tradeVisionValidation.recommendation === 'AVOID' ||
        tradeVisionValidation.recommendation === 'STRONG_AVOID';

      if (!shouldUseRealScore && (consolidatedScore >= 55 || isRealScoreTooLow)) {
        // Caso 1: consolidatedScore alto OU realScore muito baixo ‚Üí usar consolidatedScore
        // MAS: N√£o usar se realScore < 20 ou TradeVision IA = AVOID
        // ‚úÖ CORRE√á√ÉO CR√çTICA: N√£o usar consolidatedScore se realScore < 30 (aumentado de 20)
        // Isso evita criar trades com score muito baixo mesmo que consolidatedScore seja alto
        if (realScore >= 30) {
          validationScore = consolidatedScore;
        } else {
          // Se realScore < 30, usar realScore mesmo que consolidatedScore seja alto
          validationScore = realScore;
          logError('warn', 'Score discrepancy - usando realScore (muito baixo para usar consolidatedScore)', {
            realScore: uiScore,
            consolidatedScore,
            validationScore,
            difference: scoreDiff,
            note: 'realScore < 30 - usando realScore para evitar trades com score muito baixo'
          });
        }

        if (validationScore === consolidatedScore) {
          logError('warn', 'Score discrepancy detected - consolidatedScore used (high score or realScore too low)', {
            realScore: uiScore,
            consolidatedScore,
            validationScore,
            difference: scoreDiff,
            isTooLow: isRealScoreTooLow,
            tradeVisionRecommendation: tradeVisionValidation.recommendation,
            note: 'UI uses realScore; validation uses consolidatedScore (only if realScore >= 30 and TradeVision != AVOID).'
          });
        }
      } else if (shouldUseRealScore) {
        // ‚úÖ NOVO: Se realScore < 20 ou TradeVision IA = AVOID, SEMPRE usar realScore
        validationScore = realScore;
        logError('warn', 'Score discrepancy detected - using realScore (too low or TradeVision IA = AVOID)', {
          realScore: uiScore,
          consolidatedScore,
          validationScore,
          difference: scoreDiff,
          tradeVisionRecommendation: tradeVisionValidation.recommendation,
          note: 'realScore < 20 or TradeVision IA = AVOID/STRONG_AVOID - using realScore for validation to prevent bad trades.'
        });

        // ‚úÖ CORRE√á√ÉO CR√çTICA: Se consolidatedScore √© alto (>= 55) e padr√£o tinha dire√ß√£o, restaurar signalType
        // ‚ö†Ô∏è MAS: N√£o restaurar se realScore √© muito baixo (< 20) ou TradeVision IA retornou AVOID/STRONG_AVOID
        const shouldRestoreSignalType = consolidatedScore >= 55 &&
          analysis.signalType === 'NEUTRAL' &&
          realScore >= 20 && // ‚úÖ NOVO: N√£o restaurar se realScore muito baixo
          tradeVisionValidation.recommendation !== 'AVOID' &&
          tradeVisionValidation.recommendation !== 'STRONG_AVOID';

        if (shouldRestoreSignalType) {
          const patternType = typeof safePattern === 'object' && safePattern?.type ? String(safePattern.type) : pattern?.type ? String(pattern.type) : '';
          const isBullishPattern = patternType.toLowerCase().includes('bullish') || patternType.toLowerCase().includes('buy') ||
            patternType.toLowerCase().includes('spring') || patternType.toLowerCase().includes('hammer') ||
            patternType.toLowerCase().includes('alta') || patternType.toLowerCase().includes('bull') ||
            patternType.toLowerCase().includes('bos bullish') || patternType.toLowerCase().includes('choch bullish');
          const isBearishPattern = patternType.toLowerCase().includes('bearish') || patternType.toLowerCase().includes('sell') ||
            patternType.toLowerCase().includes('upthrust') || patternType.toLowerCase().includes('shooting') ||
            patternType.toLowerCase().includes('baixa') || patternType.toLowerCase().includes('bear') ||
            patternType.toLowerCase().includes('bos bearish') || patternType.toLowerCase().includes('choch bearish');

          if (isBullishPattern) {
            analysis.signalType = 'BUY';
            logError('info', 'Restaurando signalType para BUY baseado no padr√£o e score de valida√ß√£o alto', {
              patternType,
              realScore,
              validationScore,
              consolidatedScore,
              originalSignalType: 'NEUTRAL'
            });
          } else if (isBearishPattern) {
            analysis.signalType = 'SELL';
            logError('info', 'Restaurando signalType para SELL baseado no padr√£o e score de valida√ß√£o alto', {
              patternType,
              realScore,
              validationScore,
              consolidatedScore,
              originalSignalType: 'NEUTRAL'
            });
          }
        } else if (consolidatedScore >= 55 && analysis.signalType === 'NEUTRAL' && realScore < 20) {
          // ‚úÖ NOVO: Log quando n√£o restaura por realScore muito baixo
          logError('warn', 'N√£o restaurando signalType - realScore muito baixo ou TradeVision IA retornou AVOID', {
            patternType: typeof safePattern === 'object' && safePattern?.type ? String(safePattern.type) : pattern?.type ? String(pattern.type) : '',
            realScore,
            consolidatedScore,
            tradeVisionRecommendation: tradeVisionValidation.recommendation,
            note: 'realScore < 20 ou TradeVision IA = AVOID/STRONG_AVOID - n√£o restaurar signalType'
          });
        }
      } else {
        // ‚úÖ CORRE√á√ÉO PRINCIPAL: Caso 2: Discrep√¢ncia grande mas consolidatedScore < 55
        // Ao inv√©s de resetar para realScore baixo, aplicar penaliza√ß√£o proporcional
        // Penalidade: 25% da diferen√ßa (m√°ximo 15 pontos)
        const penalty = Math.min(15, Math.round(scoreDiff * 0.25));
        const adjustedConsolidatedScore = Math.max(realScore, consolidatedScore - penalty);

        // Usar o maior entre realScore e consolidatedScore ajustado (preserva sinal quando justific√°vel)
        validationScore = Math.max(realScore, adjustedConsolidatedScore);

        logError('warn', 'Score discrepancy detected - applying proportional penalty', {
          realScore: uiScore,
          consolidatedScore,
          adjustedConsolidatedScore,
          validationScore,
          difference: scoreDiff,
          penalty,
          note: `Penalidade proporcional aplicada (${penalty} pontos). Preservando score intermedi√°rio ao inv√©s de resetar.`
        });
      }
    } else if (scoreDiff > 5) {
      // Discrep√¢ncia moderada: apenas logar (n√£o altera validationScore)
      logError('warn', 'Score discrepancy detected (moderate)', {
        consolidatedScore,
        realScore: uiScore,
        validationScore,
        difference: scoreDiff,
        note: 'Using realScore for both UI and validation (discrepancy too small to adjust)'
      });
    }

    // ‚úÖ CR√çTICO: Usar uiScore (sempre = realScore) para exibi√ß√£o no frontend
    // validationScore √© usado apenas para valida√ß√£o de trades internamente
    // ‚úÖ CORRE√á√ÉO: confidenceScore j√° foi declarado antes (linha ~7196), ent√£o apenas atribuir valor
    confidenceScore = uiScore; // ‚úÖ SEMPRE usa realScore para exibi√ß√£o

    // ‚úÖ CORRE√á√ÉO CR√çTICA: Recalcular normalizedSignalType se analysis.signalType foi restaurado
    // Criar uma vari√°vel mut√°vel para substituir normalizedSignalType quando necess√°rio
    let effectiveSignalType = normalizedSignalType;
    if (analysis.signalType !== 'NEUTRAL' && normalizedSignalType === 'NEUTRAL') {
      const raw = String(analysis.signalType || '').trim().toUpperCase();
      if (raw === 'BUY' || raw === 'SELL') {
        effectiveSignalType = raw;
        logError('info', 'signalType restaurado ap√≥s corre√ß√£o de discrep√¢ncia', {
          original: normalizedSignalType,
          corrected: effectiveSignalType,
          analysisSignalType: analysis.signalType,
          consolidatedScore
        });
      }
    }

    const signalData = {
      user_id: userId,
      symbol: norm.withSlash,
      timeframe: safeTimeframe,
      signal_type: effectiveSignalType,
      direction: directionValue, // BUY/SELL para compatibilidade com schema
      entry_price: entryPrice > 0 ? Number(entryPrice.toFixed(2)) : null,
      stop_price: stopPrice > 0 ? Number(stopPrice.toFixed(2)) : null,
      target_price: targetPrice > 0 ? Number(targetPrice.toFixed(2)) : null,
      probability: safeProbability,
      pattern: safePatternName, // String para compatibilidade com Pattern Memory Engine trigger
      figure: safeFigure,
      risk_note: tradeVisionValidation.enhancedRiskNote || analysis.riskNote || null,
      price: priceStr,
      news: marketData.news || null,
      market_status: tradeVisionValidation.contextualInsight || analysis.marketContext || null,
      // Campos adicionais para compatibilidade com Pattern Memory Engine
      trend: trendValue,
      confidence: analysis.technicalScore || confidenceScore, // ‚úÖ CORRE√á√ÉO FINAL: Usar technicalScore primeiro para sincronizar com metadata.technicalScore (reduz discrep√¢ncia)
      narrative: null, // ‚úÖ OTIMIZA√á√ÉO: N√£o salvar narrative (pode ser gerado sob demanda)
      // Frontend usa metadata.summary ou metadata.analystComment como fallback
      rsi: rsiValue,
      macd_histogram: macdHistogram,
      bb_position: bbPosition,
      metadata: {
        analysis: analysis.summary || '',
        summary: analysis.summary || '',
        // üÜï Coment√°rio do Analista TradeVision IA
        analystComment: analysis.narration?.analystComment || analysis.summary || 'An√°lise t√©cnica em andamento',
        // üõ°Ô∏è GARANTIR que arrays nunca sejam undefined - PRIORIDADE: confluences sempre presente
        confluences: Array.isArray(activeConfluences) && activeConfluences.length > 0 ? activeConfluences : [],
        activeConfluences: Array.isArray(activeConfluences) && activeConfluences.length > 0 ? activeConfluences : [],
        validated_confluences: Array.isArray(activeConfluences) && activeConfluences.length > 0 ? activeConfluences : [],
        technicalScore: analysis.technicalScore || validationScore, // ‚úÖ CORRE√á√ÉO: Usar analysis.technicalScore (finalScore real: 45%, 50%, 0%, 30%) ao inv√©s de validationScore para sincronizar com frontend
        volumeAnalysis: analysis.volumeAnalysis,
        ai_generated: true,
        ai_validated: true,
        multi_timeframe_validated: true,
        // üÜï ADD pairData para o feed mostrar volume/change corretos
        pairData: (() => {
          const vol = Number(marketData?.volume || safeMarketData?.volume || 0);
          let volFormatted = '0.0M';
          if (vol >= 1000000000) {
            volFormatted = `${(vol / 1000000000).toFixed(2)}B`;
          } else if (vol >= 1000000) {
            volFormatted = `${(vol / 1000000).toFixed(1)}M`;
          } else if (vol >= 1000) {
            volFormatted = `${(vol / 1000).toFixed(1)}K`;
          } else if (vol > 0) {
            volFormatted = vol.toFixed(0);
          }
          return {
            change24h: marketData?.change || safeMarketData?.change24h || '0%',
            vol: volFormatted,
            dominance: 'N/A'
          };
        })(),
        timeframe_context: {
          m1_insight: multiTimeframeContext.m1?.micro_insight,
          m5_insight: multiTimeframeContext.m5?.tactical_insight,
          m15_insight: multiTimeframeContext.m15?.contextual_insight,
          m30_insight: multiTimeframeContext.m30?.strategic_insight,
          macro_trend: multiTimeframeContext.m30?.macro_trend,
          market_phase: multiTimeframeContext.m30?.market_phase,
          timeframe_confirmation: multiTimeframeContext.confirmation || 'neutral'
        },
        multi_timeframe_context: {
          m1: {
            trend: multiTimeframeContext.m1?.trend || 'neutral'
          },
          m5: {
            trend: multiTimeframeContext.m5?.trend || 'neutral'
          },
          m15: {
            trend: multiTimeframeContext.m15?.trend || 'neutral'
          },
          m30: {
            trend: multiTimeframeContext.m30?.trend || 'neutral'
          }
        },
        tradevision_validation: {
          recommendation: tradeVisionValidation.recommendation,
          reasoning: tradeVisionValidation.reasoning,
          confidence: tradeVisionValidation.aiConfidence,
          keyPoints: tradeVisionValidation.keyPoints,
          shouldEnter: tradeVisionValidation.shouldEnter
        },
        pattern_details: pattern,
        // üéØ Targets TP/SL (j√° calculados, agora salvos no metadata)
        targets: analysis.targets || null,
        timing: {
          detected_at: detectionTime.toISOString(),
          analysis_duration_ms: analysisTime,
          action_window_seconds: actionWindow,
          expires_at: new Date(Date.now() + actionWindow * 1000).toISOString(),
          urgency_level: tradeVisionValidation.urgencyLevel
        },
        // üß† [RL] Sinais detectados para ajuste de pesos
        detected_signals: Array.isArray(analysis.detectedSignals) ? analysis.detectedSignals : [],
        // üõ°Ô∏è CONTROLE DE RISCO PARA ALTA LEVERAGE
        risk_management: riskManagement || null,
        // ‚úÖ NOVO: Salvar RASP e forecast no metadata para entrada antecipada
        rasp: rasp || null,
        forecast: forecast || null
      }
    };
    // üîç DEBUG: Validar metadata ANTES de salvar
    // ‚úÖ Log compacto: Metadata antes de salvar (debug apenas)
    logIntelligence('debug', 'Metadata preparado para salvar', {
      confluencesCount: signalData.metadata.confluences?.length || 0,
      metadataKeys: Object.keys(signalData.metadata)
    });
    // 7. PROCESSAR M1
    // ‚ÑπÔ∏è IMPORTANTE: M1 √© processado pelo useTemporalProcessor no FRONTEND
    // e SALVO em market_m1 pela edge function temporal-processor-m1
    // 
    // O M1 salvo √© CRUCIAL porque:
    // - intelligent-narrator L√ä market_m1 (linha 1219) para contexto multi-timeframe
    // - trade-chat L√ä market_m1 (linha 124) para an√°lise
    // - temporal-processor-m5 L√ä market_m1 (linha 25) para consolidar M5
    // - evaluate_pending_signals L√ä market_m1 (linha 92) para pre√ßo atual
    // - signal-validator L√ä market_m1 (linha 50) para valida√ß√£o
    //
    // Frontend processa M1 a cada 60s (throttled) e salva em market_m1 ‚úÖ
    // Evita duplica√ß√£o: se backend tamb√©m processasse, haveria 2x salvamento
    // üîµ CONTINUITY SUITE: Break Detector + Context Refresher + Duplicate Signal Guard
    try {
      const activeTradeCheck = await getActiveTradeState(supabase, userId, norm.withSlash, safeTimeframe);
      if (activeTradeCheck?.data) {
        const activeTrade = activeTradeCheck.data;
        // üêõ FIX: Usar currentPrice validado (j√° buscado da Binance se necess√°rio)
        const currentPriceForCheck = (currentPrice && currentPrice > 0 && Number.isFinite(currentPrice))
          ? currentPrice
          : (Number.isFinite(priceNum) && priceNum > 0 ? priceNum : parseFloat(priceStr) || 0);
        const currentPattern = safePattern || (pattern?.type ? String(pattern.type) : 'unknown');
        // ‚úÖ DIAGN√ìSTICO: Log inicial do trade ativo
        logTrade('debug', 'Active trade check iniciado', {
          tradeId: activeTrade.id,
          status: activeTrade.status,
          direction: activeTrade.direction,
          entryPrice: activeTrade.entry_price,
          stopPrice: activeTrade.stop_price,
          targetPrice: activeTrade.target_price,
          currentPrice: currentPriceForCheck,
          pattern: activeTrade.pattern
        });

        // 1. BREAK DETECTOR: Verificar se pre√ßo quebrou o stop
        if (currentPriceForCheck > 0 && activeTrade.stop_price && activeTrade.status === 'active') {
          const brokeBuy = activeTrade.direction === 'BUY' && currentPriceForCheck <= activeTrade.stop_price;
          const brokeSell = activeTrade.direction === 'SELL' && currentPriceForCheck >= activeTrade.stop_price;

          // ‚úÖ DIAGN√ìSTICO: Log detalhado do stop check
          if (activeTrade.stop_price > 0) {
            const buyStopDistance = activeTrade.direction === 'BUY'
              ? ((currentPriceForCheck - activeTrade.stop_price) / activeTrade.stop_price * 100).toFixed(4)
              : 'N/A';
            const sellStopDistance = activeTrade.direction === 'SELL'
              ? ((activeTrade.stop_price - currentPriceForCheck) / activeTrade.stop_price * 100).toFixed(4)
              : 'N/A';
            logTrade('debug', 'Stop check', {
              tradeId: activeTrade.id,
              direction: activeTrade.direction,
              currentPrice: currentPriceForCheck.toFixed(2),
              stopPrice: activeTrade.stop_price.toFixed(2),
              buyStopDistancePct: buyStopDistance,
              sellStopDistancePct: sellStopDistance,
              brokeBuy,
              brokeSell
            });
          }

          if (brokeBuy || brokeSell) {
            // ‚úÖ CORRE√á√ÉO #6: Calcular P&L ao invalidar trade (stop loss)
            await invalidateTradeState(supabase, activeTrade.id, 'Estrutura rompida', {
              price_at_break: currentPriceForCheck,
              stop_price: activeTrade.stop_price,
              direction: activeTrade.direction,
              pattern: activeTrade.pattern
            }, currentPriceForCheck);
            // üß† Aprendizado autom√°tico: registrar falha no ai_pattern_memory e pattern_occurrences
            try {
              const patternType = activeTrade.pattern || 'unknown';
              const symbol = norm.withSlash.replace('/', '');

              // 1. Buscar ou criar pattern memory em ai_pattern_memory (TABELA CORRETA)
              let patternMemoryId = null;
              const { data: existingMemory } = await supabase.from('ai_pattern_memory')
                .select('id, total_occurrences, losses')
                .eq('pattern_name', patternType)
                .eq('timeframe', safeTimeframe)
                .eq('symbol', symbol)
                .maybeSingle();

              if (existingMemory) {
                patternMemoryId = existingMemory.id;
                // Atualizar: incrementar losses e total_occurrences, recalcular win_rate
                const newLosses = (existingMemory.losses || 0) + 1;
                const newTotal = (existingMemory.total_occurrences || 0) + 1;
                const newWins = (existingMemory.wins || 0);
                const newWinRate = newTotal > 0 ? (newWins / newTotal) : 0;

                await supabase.from('ai_pattern_memory').update({
                  losses: newLosses,
                  total_occurrences: newTotal,
                  win_rate: newWinRate,
                  last_seen: new Date().toISOString(),
                  updated_at: new Date().toISOString()
                }).eq('id', patternMemoryId);

                // üß† PROMO√á√ÉO AUTOM√ÅTICA: Verificar se padr√£o deve ser promovido/rebaixado
                await updatePatternStatus(supabase, patternMemoryId, newWinRate, newTotal);
              } else {
                // üÜï Criar novo pattern memory usando upsert para evitar erro de chave duplicada
                const { data: newMemory } = await supabase.from('ai_pattern_memory').upsert({
                  pattern_name: patternType,
                  timeframe: safeTimeframe,
                  symbol: symbol,
                  total_occurrences: 1,
                  wins: 0,
                  losses: 1,
                  win_rate: 0.0,
                  confidence_level: 'low',
                  adaptive_weight: 1.0,
                  last_seen: new Date().toISOString(),
                  updated_at: new Date().toISOString()
                }, {
                  onConflict: 'pattern_name,timeframe,symbol',
                  ignoreDuplicates: false
                }).select('id').single();

                if (newMemory) {
                  patternMemoryId = newMemory.id;
                }
              }

              // 2. Salvar ocorr√™ncia em pattern_occurrences (se patternMemoryId existe)
              if (patternMemoryId) {
                await supabase.from('pattern_occurrences').insert({
                  pattern_memory_id: patternMemoryId, // ‚úÖ Campo existe no banco!
                  signal_id: activeTrade.id, // ID do trade_state
                  timeframe: safeTimeframe,
                  symbol: symbol, // ‚úÖ Campo obrigat√≥rio
                  pattern_name: patternType, // ‚úÖ Campo obrigat√≥rio
                  direction: activeTrade.direction || null, // ‚úÖ Campo existe no banco!
                  result: 'LOSS', // Stop foi atingido = loss
                  timestamp: new Date().toISOString(), // ‚úÖ Campo existe no banco!
                  created_at: new Date().toISOString()
                });
              }

              // 3. Salvar em trade_history (se tabela existir)
              try {
                await supabase.from('trade_history').insert({
                  signal_id: activeTrade.id,
                  pattern: patternType,
                  symbol: symbol,
                  timeframe: safeTimeframe,
                  entry_price: activeTrade.entry_price,
                  exit_price: currentPriceForCheck,
                  pnl: activeTrade.direction === 'BUY'
                    ? currentPriceForCheck - activeTrade.entry_price
                    : activeTrade.entry_price - currentPriceForCheck,
                  result: 'LOSS',
                  created_at: new Date().toISOString()
                });
              } catch (tradeHistoryError) {
                // Tabela pode n√£o existir ainda - ignorar silenciosamente
                if (!tradeHistoryError?.message?.includes('Could not find the table')) {
                  logTrade('warn', 'Erro ao salvar trade_history', { error: tradeHistoryError?.message });
                }
              }
            } catch (learnError) {
              logTrade('warn', 'Erro ao registrar aprendizado', { error: learnError?.message || learnError });
            }
            logTrade('info', 'BreakDetector: Estrutura rompida', {
              price: currentPriceForCheck,
              stop: activeTrade.stop_price,
              tradeId: activeTrade.id
            });
          } else {
            // 1.5. TARGET DETECTOR: Verificar se pre√ßo atingiu o target (WIN)
            if (activeTrade.target_price && activeTrade.status === 'active') {
              const hitBuyTarget = activeTrade.direction === 'BUY' && currentPriceForCheck >= activeTrade.target_price;
              const hitSellTarget = activeTrade.direction === 'SELL' && currentPriceForCheck <= activeTrade.target_price;

              // ‚úÖ DIAGN√ìSTICO: Log detalhado para investigar trades n√£o completados
              if (currentPriceForCheck > 0 && activeTrade.target_price > 0) {
                const buyDistance = activeTrade.direction === 'BUY'
                  ? ((currentPriceForCheck - activeTrade.target_price) / activeTrade.target_price * 100).toFixed(4)
                  : 'N/A';
                const sellDistance = activeTrade.direction === 'SELL'
                  ? ((activeTrade.target_price - currentPriceForCheck) / activeTrade.target_price * 100).toFixed(4)
                  : 'N/A';
                logTrade('debug', 'Target check', {
                  tradeId: activeTrade.id,
                  direction: activeTrade.direction,
                  currentPrice: currentPriceForCheck.toFixed(2),
                  targetPrice: activeTrade.target_price.toFixed(2),
                  buyDistancePct: buyDistance,
                  sellDistancePct: sellDistance,
                  hitBuyTarget,
                  hitSellTarget
                });
              }

              if (hitBuyTarget || hitSellTarget) {
                // Marcar trade como conclu√≠do (WIN)
                await supabase.from(TRADE_STATE_TABLE).update({
                  status: 'completed',
                  exit_price: currentPriceForCheck,
                  completed_at: new Date().toISOString(),
                  updated_at: new Date().toISOString()
                }).eq('id', activeTrade.id);

                // üß† Aprendizado autom√°tico: registrar WIN no ai_pattern_memory e pattern_occurrences
                try {
                  const patternType = activeTrade.pattern || 'unknown';
                  const symbol = norm.withSlash.replace('/', '');

                  // 1. Buscar ou criar pattern memory em ai_pattern_memory
                  let patternMemoryId = null;
                  const { data: existingMemory } = await supabase.from('ai_pattern_memory')
                    .select('id, total_occurrences, wins')
                    .eq('pattern_name', patternType)
                    .eq('timeframe', safeTimeframe)
                    .eq('symbol', symbol)
                    .maybeSingle();

                  if (existingMemory) {
                    patternMemoryId = existingMemory.id;
                    // Atualizar: incrementar wins e total_occurrences, recalcular win_rate
                    const newWins = (existingMemory.wins || 0) + 1;
                    const newTotal = (existingMemory.total_occurrences || 0) + 1;
                    const newLosses = (existingMemory.losses || 0);
                    const newWinRate = newTotal > 0 ? (newWins / newTotal) : 0;

                    await supabase.from('ai_pattern_memory').update({
                      wins: newWins,
                      total_occurrences: newTotal,
                      win_rate: newWinRate,
                      last_seen: new Date().toISOString(),
                      updated_at: new Date().toISOString()
                    }).eq('id', patternMemoryId);

                    // üß† PROMO√á√ÉO AUTOM√ÅTICA: Verificar se padr√£o deve ser promovido
                    await updatePatternStatus(supabase, patternMemoryId, newWinRate, newTotal);
                  } else {
                    // üÜï Criar novo pattern memory usando upsert para evitar erro de chave duplicada
                    const { data: newMemory } = await supabase.from('ai_pattern_memory').upsert({
                      pattern_name: patternType,
                      timeframe: safeTimeframe,
                      symbol: symbol,
                      total_occurrences: 1,
                      wins: 1,
                      losses: 0,
                      win_rate: 1.0,
                      confidence_level: 'high',
                      adaptive_weight: 1.2, // Boost inicial para padr√£o vencedor
                      last_seen: new Date().toISOString(),
                      updated_at: new Date().toISOString()
                    }, {
                      onConflict: 'pattern_name,timeframe,symbol',
                      ignoreDuplicates: false
                    }).select('id').single();

                    if (newMemory) {
                      patternMemoryId = newMemory.id;
                    }
                  }

                  // 2. Salvar ocorr√™ncia em pattern_occurrences
                  if (patternMemoryId) {
                    await supabase.from('pattern_occurrences').insert({
                      pattern_memory_id: patternMemoryId, // ‚úÖ Campo existe no banco!
                      signal_id: activeTrade.id,
                      timeframe: safeTimeframe,
                      symbol: symbol, // ‚úÖ Campo obrigat√≥rio
                      pattern_name: patternType, // ‚úÖ Campo obrigat√≥rio
                      direction: activeTrade.direction || null, // ‚úÖ Campo existe no banco!
                      result: 'WIN',
                      timestamp: new Date().toISOString(), // ‚úÖ Campo existe no banco!
                      created_at: new Date().toISOString()
                    });
                  }

                  // 3. Salvar em trade_history
                  try {
                    const pnl = activeTrade.direction === 'BUY'
                      ? currentPriceForCheck - activeTrade.entry_price
                      : activeTrade.entry_price - currentPriceForCheck;

                    await supabase.from('trade_history').insert({
                      signal_id: activeTrade.id,
                      pattern: patternType,
                      symbol: symbol,
                      timeframe: safeTimeframe,
                      entry_price: activeTrade.entry_price,
                      exit_price: currentPriceForCheck,
                      pnl: pnl,
                      result: 'WIN',
                      created_at: new Date().toISOString()
                    });
                  } catch (tradeHistoryError) {
                    if (!tradeHistoryError?.message?.includes('Could not find the table')) {
                      logTrade('warn', 'Erro ao salvar trade_history (WIN)', { error: tradeHistoryError?.message });
                    }
                  }
                } catch (learnError) {
                  logTrade('warn', 'Erro ao registrar aprendizado WIN', { error: learnError?.message || learnError });
                }

                logTrade('info', 'TargetDetector: Target atingido', {
                  price: currentPriceForCheck,
                  target: activeTrade.target_price,
                  tradeId: activeTrade.id
                });
              } else {
                // üÜï APLICAR FEATURES AVAN√áADAS (s√≥ se n√£o quebrou e n√£o atingiu target)
                // Trailing Stop
                await applyTrailingStop(supabase, activeTrade, currentPriceForCheck);
                // Time Decay
                await applyTimeDecay(supabase, activeTrade, currentPriceForCheck, safeTimeframe);
              }
            } else {
              // üÜï APLICAR FEATURES AVAN√áADAS (s√≥ se n√£o quebrou)
              // Trailing Stop
              await applyTrailingStop(supabase, activeTrade, currentPriceForCheck);
              // Time Decay
              await applyTimeDecay(supabase, activeTrade, currentPriceForCheck, safeTimeframe);
            }
          }
        }
        // 2. CONTEXT REFRESHER: Verificar se padr√£o mudou E dire√ß√£o oposta
        // ‚úÖ AJUSTE: S√≥ invalidar se padr√£o mudou E nova dire√ß√£o √© oposta (menos fechamentos prematuros)
        const isOppositeDirection = (normalizedSignalType === 'BUY' && activeTrade.direction === 'SELL') ||
          (normalizedSignalType === 'SELL' && activeTrade.direction === 'BUY');

        if (normalizedSignalType !== 'NEUTRAL' && currentPattern !== activeTrade.pattern && isOppositeDirection) {
          // ‚úÖ CORRE√á√ÉO #6: Calcular P&L ao invalidar trade
          await invalidateTradeState(supabase, activeTrade.id, 'Padr√£o desconfigurado', {
            old_pattern: activeTrade.pattern,
            new_pattern: currentPattern,
            direction: activeTrade.direction,
            new_direction: normalizedSignalType
          }, currentPriceForCheck);
          logTrade('info', 'ContextRefresher: Padr√£o desconfigurado (dire√ß√£o oposta)', {
            oldPattern: activeTrade.pattern,
            newPattern: currentPattern,
            tradeId: activeTrade.id,
            oldDirection: activeTrade.direction,
            newDirection: normalizedSignalType
          });
        }
        // 3. DUPLICATE SIGNAL GUARD: Se mesmo padr√£o, verificar idade antes de bloquear
        if (normalizedSignalType !== 'NEUTRAL' && currentPattern === activeTrade.pattern) {
          // ‚úÖ AJUSTE: Aumentado de 2 para 8 minutos (trades precisam de mais tempo para desenvolver)
          const tradeAgeMs = Date.now() - new Date(activeTrade.created_at).getTime();
          const tradeAgeMinutes = tradeAgeMs / (60 * 1000);
          const maxAgeMinutes = 8; // ‚úÖ AJUSTE: Aumentado de 2 para 8 minutos

          // ‚úÖ MELHORIA: Permitir reentrada mais cedo se novo sinal tem score muito melhor
          // Usar consolidatedScore que est√° no escopo (definido antes)
          const newSignalScore = consolidatedScore || (analysis?.confidenceScore) || 0;
          const scoreDifference = newSignalScore - (activeTrade.confidence_initial || 50);
          const isMuchBetterSignal = scoreDifference >= 15; // Novo sinal tem +15 pontos ou mais

          if (tradeAgeMinutes < maxAgeMinutes && !isMuchBetterSignal) {
            // Trade ainda √© recente (< 2 min) e novo sinal n√£o √© muito melhor, bloquear duplicata
            logTrade('debug', 'Sinal ignorado: trade ativo recente', {
              tradeAgeMinutes: tradeAgeMinutes.toFixed(1),
              pattern: currentPattern,
              tradeId: activeTrade.id,
              scoreDifference: scoreDifference.toFixed(1)
            });
            return new Response(JSON.stringify({
              success: true,
              signal: null,
              analysis: {
                score: consolidatedScore,
                summary: analysis.summary,
                confluences: analysis.confluences,
                narration: analysis.narration
              },
              message: `Sinal ignorado ‚Äî trade ativo recente (${tradeAgeMinutes.toFixed(1)}min) j√° existe para este padr√£o`,
              continuity: {
                active: true,
                reason: 'duplicate_pattern_recent'
              }
            }), {
              status: 200,
              headers: {
                ...corsHeaders,
                'Content-Type': 'application/json'
              }
            });
          } else if (isMuchBetterSignal) {
            // ‚úÖ NOVO: Sinal muito melhor (+15 pontos), invalidar trade antigo e permitir novo
            logTrade('info', 'Trade invalidado: novo sinal muito melhor', {
              tradeAgeMinutes: tradeAgeMinutes.toFixed(1),
              pattern: currentPattern,
              tradeId: activeTrade.id,
              oldScore: (activeTrade.confidence_initial || 50).toFixed(1),
              newScore: newSignalScore.toFixed(1),
              scoreDifference: scoreDifference.toFixed(1)
            });
            // ‚úÖ CORRE√á√ÉO #6: Calcular P&L ao invalidar trade
            const exitPriceForRenewal = (currentPrice && currentPrice > 0 && Number.isFinite(currentPrice))
              ? currentPrice
              : (Number.isFinite(priceNum) && priceNum > 0 ? priceNum : parseFloat(priceStr) || activeTrade.entry_price);

            await invalidateTradeState(supabase, activeTrade.id, 'Renova√ß√£o - Novo sinal muito melhor', {
              tradeAgeMinutes: tradeAgeMinutes.toFixed(1),
              pattern: currentPattern,
              scoreDifference: scoreDifference.toFixed(1)
            }, exitPriceForRenewal);
            // Continua o fluxo para criar novo sinal
          } else {
            // Trade √© antigo (> 2 min), invalidar e permitir novo sinal
            logTrade('info', 'Trade antigo invalidado para permitir renova√ß√£o', {
              tradeAgeMinutes: tradeAgeMinutes.toFixed(1),
              pattern: currentPattern,
              tradeId: activeTrade.id
            });
            // ‚úÖ CORRE√á√ÉO #6: Calcular P&L ao invalidar trade
            const exitPriceForRenewal = (currentPrice && currentPrice > 0 && Number.isFinite(currentPrice))
              ? currentPrice
              : (Number.isFinite(priceNum) && priceNum > 0 ? priceNum : parseFloat(priceStr) || activeTrade.entry_price);

            await invalidateTradeState(supabase, activeTrade.id, 'Renova√ß√£o - Trade antigo com mesmo padr√£o', {
              tradeAgeMinutes: tradeAgeMinutes.toFixed(1),
              pattern: currentPattern
            }, exitPriceForRenewal);
            // Continua o fluxo para criar novo sinal
          }
        }
      }
    } catch (continuityCheckError) {
      logTrade('warn', 'Erro ao verificar continuidade', { error: continuityCheckError?.message || continuityCheckError });
      // N√£o quebra o fluxo - continua normalmente
    }
    // 8. Salvar sinal validado
    const { data: savedSignal, error: signalError } = await supabase.from('narrator_signals').insert(signalData).select().single();
    if (signalError) {
      console.error('‚ùå Erro ao salvar sinal:', signalError);
      throw signalError;
    }
    // ‚úÖ Log compacto: Sinal salvo (sem repetir dados grandes)
    logIntelligence('info', 'Sinal salvo no banco', {
      signalId: savedSignal?.id,
      hasMetadata: !!savedSignal?.metadata,
      confluencesCount: savedSignal?.metadata?.confluences?.length || 0
    });
    logIntelligence('info', 'Sinal validado por TradeVision IA e salvo', { signalId: savedSignal?.id });
    // üîµ CONTINUITY SUITE: Criar TradeState ao gerar sinal v√°lido + Trend Follower
    let tradeStateCreated = false;

    // ‚úÖ Log compacto: Crit√©rios para criar trade (debug apenas)
    logEngine('debug', 'Verificando crit√©rios para criar trade_state', {
      hasSignal: !!savedSignal,
      signalType: normalizedSignalType,
      confidence: safeProbability
    });

    try {
      // ‚úÖ CORRE√á√ÉO CR√çTICA: Definir candles ANTES de qualquer uso
      // ‚úÖ ESTRAT√âGIA PERFEITA 75x: Validar momentum real antes de criar trade
      // ‚úÖ CORRE√á√ÉO: Usar candlesForAnalysis (definido anteriormente) em vez de candles
      const candles = candlesForAnalysis || []; // Usar candlesForAnalysis que est√° no escopo

      // ‚úÖ MELHORIA: Score m√≠nimo adaptativo baseado em conflu√™ncias
      // Para consolida√ß√£o: 40 com conflu√™ncias obrigat√≥rias
      // Para explosivo: 45 (padr√£o mais sens√≠vel)
      const analysisMetadata = analysis?.metadata || {};
      const tradeType = analysisMetadata.tradeType || 'N/A';
      const hasMicrostructure = (analysisMetadata.microstructureScore || 0) >= 55;
      const hasMTF = analysisMetadata.mtfConfirmation !== 'divergent';
      const hasVolume = (analysisMetadata.volumeZScore || 0) > -0.5;
      const isMomentumTrade = tradeType === 'Explosivo';

      // Obter leverage do body ou usar default
      const currentLeverage = body?.leverage || 75;
      const isHighLeverageCheck = currentLeverage >= 75;

      // Determinar score m√≠nimo baseado no tipo de trade
      // ‚úÖ v286: Scores mais baixos para permitir mais trades
      let minScore = 35; // ‚úÖ v286: De 40 para 35 (mais trades)
      if (isHighLeverageCheck && isMomentumTrade) {
        minScore = 40; // ‚úÖ v286: De 45 para 40 (momentum precisa um pouco mais)
      } else if (isHighLeverageCheck && !isMomentumTrade) {
        // Consolida√ß√£o: Score m√≠nimo flex√≠vel
        if (hasMicrostructure && hasMTF && hasVolume) {
          minScore = 35; // ‚úÖ v286: De 40 para 35 (com conflu√™ncias)
        } else {
          minScore = 40; // ‚úÖ v286: De 45 para 40 (sem todas conflu√™ncias)
        }
      }

      // ‚úÖ NOTA: confidenceScore j√° foi definido ANTES da cria√ß√£o de signalData (linha ~6947)
      // A corre√ß√£o de discrep√¢ncia j√° foi aplicada, ent√£o aqui apenas usamos o valor j√° corrigido

      // üéØ CORRE√á√ÉO CR√çTICA: Recalcular safeProbability DEPOIS da corre√ß√£o de discrep√¢ncia
      // ‚úÖ SOLU√á√ÉO 1: Usar score ORIGINAL da IA ao inv√©s de m√©dia que sempre converge para 60-70
      // ‚úÖ SOLU√á√ÉO 2: Aumentar threshold de corre√ß√£o de 5 para 20 pontos para evitar substitui√ß√£o prematura
      const wasScoreCorrected = Math.abs(validationScore - originalConfidenceScore) > 20; // ‚úÖ Aumentado de 5 para 20
      const technicalScore = typeof analysis?.technicalScore === 'number' ? analysis.technicalScore : null;
      const ac = typeof tradeVisionValidation?.aiConfidence === 'number' ? tradeVisionValidation.aiConfidence : 0;

      // ‚úÖ CORRE√á√ÉO CR√çTICA: Usar score ORIGINAL da IA (originalConfidenceScore) ao inv√©s de m√©dia
      // O problema era que validationScore e ac sempre ficavam entre 60-70, fazendo m√©dia sempre ‚âà65
      // Agora usamos o score REAL fornecido pela IA, que reflete melhor a qualidade do sinal
      let prob: number;
      if (technicalScore !== null && technicalScore > 0) {
        prob = technicalScore; // Priorizar technicalScore se dispon√≠vel
      } else {
        // ‚úÖ SOLU√á√ÉO 1 IMPLEMENTADA: Usar score ORIGINAL da IA ao inv√©s da m√©dia
        // S√≥ usar consolidatedScore quando h√° discrep√¢ncia MUITO grande (>20) E padr√£o √© fallback
        const patternName = typeof safePattern === 'object' && safePattern?.type ? String(safePattern.type) : pattern?.type ? String(pattern.type) : 'unknown';
        const isFallbackPattern = patternName === 'Estrutura t√©cnica' || patternName === 'unknown';
        const candlesInconsistent = !candles || candles.length < 10;

        // ‚úÖ CORRE√á√ÉO CR√çTICA: Quando h√° discrep√¢ncia grande, usar validationScore (score corrigido)
        // Se originalConfidenceScore est√° muito baixo (1) mas validationScore est√° alto (65), usar o corrigido
        const scoreDiscrepancy = Math.abs(validationScore - originalConfidenceScore);
        if (scoreDiscrepancy > 20 && validationScore > originalConfidenceScore) {
          // Se h√° discrep√¢ncia grande E validationScore √© maior, usar o corrigido
          prob = validationScore;
        } else if (wasScoreCorrected && (isFallbackPattern || candlesInconsistent)) {
          prob = validationScore; // Usar consolidatedScore apenas em casos muito espec√≠ficos
        } else {
          // ‚úÖ Usar o maior entre original e validation para garantir que n√£o perca score bom
          prob = Math.max(originalConfidenceScore, validationScore);
        }
      }

      safeProbability = Number.isFinite(prob) ? Math.max(0, Math.min(100, prob)) : 0;

      // ‚úÖ LOG DETALHADO: Verificar c√°lculo de confidence para debug (SOLU√á√ÉO 3)
      console.log({
        originalConfidenceScore,
        technicalScore,
        aiConfidence: ac,
        consolidatedScore,
        validationScore,
        safeProbability: prob,
        wasScoreCorrected,
        note: wasScoreCorrected
          ? 'Score foi corrigido usando consolidatedScore'
          : 'Usando score original da IA'
      });

      if (wasScoreCorrected) {
        console.log(`üìä [CONFIDENCE] Score CORRIGIDO: original=${originalConfidenceScore}, validation=${validationScore}, consolidated=${consolidatedScore} ‚Üí safeProbability: ${safeProbability}`);
      } else if (technicalScore !== null) {
        console.log(`üìä [CONFIDENCE] Usando technicalScore: ${technicalScore} ‚Üí safeProbability: ${safeProbability}`);
      } else {
        console.log(`üìä [CONFIDENCE] Usando score ORIGINAL da IA: ${originalConfidenceScore} ‚Üí safeProbability: ${safeProbability}`);
      }

      // ‚úÖ AJUSTE DIN√ÇMICO: Reduzir score m√≠nimo quando ATR est√° ideal ser√° aplicado abaixo
      // Por enquanto, usar minScore padr√£o (ser√° ajustado antes da valida√ß√£o)

      // ‚úÖ VALIDA√á√ÉO: Padr√£o fallback ("Estrutura t√©cnica" ou "unknown") - permitido se score ‚â•50
      const patternName = typeof safePattern === 'object' && safePattern?.type ? String(safePattern.type) : pattern?.type ? String(pattern.type) : 'unknown';
      const isFallbackPattern = patternName === 'Estrutura t√©cnica' || patternName === 'unknown';

      // ‚úÖ LOG INFORMATIVO: Mostrar quando padr√£o fallback √© detectado (ser√° permitido se score ‚â•50)
      if (isFallbackPattern) {
        console.log(`‚ö†Ô∏è [DEBUG] Padr√£o fallback detectado: ${patternName} - ${validationScore >= 50 ? 'PERMITIDO (score ‚â•50)' : 'BLOQUEADO (score <50)'}`);
      }

      // ‚úÖ REFATORA√á√ÉO: Valida√ß√£o consolidada de momentum (unifica todas as checagens)
      const momentumValidation = validateMomentumConsolidated(
        candles,
        marketData,
        technicalIndicators,
        patternName,
        normalizedSignalType,
        confidenceScore
      );

      // ‚úÖ CORRE√á√ÉO CR√çTICA #4: Verificar trade ativo antes de criar novo
      const activeTradeCheck = await getActiveTradeState(supabase, 'system-ai', norm.withSlash, safeTimeframe);

      // ‚úÖ CORRE√á√ÉO CR√çTICA #5: Se existe trade ativo e dire√ß√£o REALMENTE inverteu (BUY‚ÜîSELL)
      // IMPORTANTE: N√ÉO fechar trade se novo sinal √© NEUTRAL - deixar trade continuar!
      if (activeTradeCheck?.data && activeTradeCheck.data.status === 'active') {
        const existingTrade = activeTradeCheck.data;
        const oldDir = existingTrade.direction;
        const newDir = normalizedSignalType;

        // ‚úÖ CORRE√á√ÉO: S√≥ fechar se inverter REALMENTE (BUY‚ÜíSELL ou SELL‚ÜíBUY)
        // N√ÉO fechar se novo sinal √© NEUTRAL - deixar trade ativo!
        const isRealFlip = (oldDir === 'BUY' && newDir === 'SELL') || (oldDir === 'SELL' && newDir === 'BUY');

        if (isRealFlip) {
          // Dire√ß√£o REALMENTE inverteu ‚Üí fechar trade anterior com P&L antes de criar novo
          logTrade('info', 'Dire√ß√£o inverteu (flip real), fechando trade anterior', {
            oldDirection: oldDir,
            newDirection: newDir,
            tradeId: existingTrade.id
          });

          // Usar pre√ßo atual para calcular P&L
          const exitPrice = (currentPrice && currentPrice > 0 && Number.isFinite(currentPrice))
            ? currentPrice
            : (Number.isFinite(priceNum) && priceNum > 0 ? priceNum : parseFloat(priceStr) || existingTrade.entry_price);

          await closeTradeWithPnL(supabase, existingTrade, exitPrice, 'Dire√ß√£o inverteu - Flip real BUY‚ÜîSELL', {
            oldDirection: oldDir,
            newDirection: newDir,
            oldPattern: existingTrade.pattern,
            newPattern: patternName
          });
        } else if (newDir === 'NEUTRAL') {
          // ‚úÖ NOVO: Sinal NEUTRAL n√£o fecha trade - deixar correr at√© TP/SL/TIME
          logTrade('debug', 'Sinal NEUTRAL detectado - trade mantido ativo', {
            tradeId: existingTrade.id,
            pattern: existingTrade.pattern,
            note: 'Trade s√≥ fecha por TP/SL ou tempo m√°ximo'
          });
        } else if (existingTrade.pattern === patternName) {
          // Mesmo padr√£o e dire√ß√£o ‚Üí verificar se deve renovar (j√° feito acima no continuity check)
          logTrade('debug', 'Trade ativo com mesmo padr√£o e dire√ß√£o', {
            tradeId: existingTrade.id,
            pattern: patternName
          });
        }
      }

      // ‚úÖ REFATORA√á√ÉO: Valida√ß√£o consolidada de ATR (unifica todas as checagens)
      // ‚úÖ FASE 1: Passar timeframe para thresholds espec√≠ficos
      const atrValidation = validateATRConsolidated(
        technicalIndicators,
        currentPrice,
        momentumValidation.hasDirectionalMovement,
        momentumValidation.movementDirection,
        normalizedSignalType,
        safeTimeframe // ‚úÖ FASE 1: Passar timeframe para c√°lculo correto
      );

      // ‚úÖ CORRE√á√ÉO CR√çTICA: Calcular effectiveSignalType ANTES da valida√ß√£o
      // Isso garante que se o signalType foi restaurado ap√≥s corre√ß√£o de discrep√¢ncia, 
      // a valida√ß√£o use o signalType correto
      const effectiveSignalTypeForTrade = analysis.signalType !== 'NEUTRAL' && normalizedSignalType === 'NEUTRAL'
        ? (String(analysis.signalType || '').trim().toUpperCase() === 'BUY' || String(analysis.signalType || '').trim().toUpperCase() === 'SELL'
          ? String(analysis.signalType || '').trim().toUpperCase()
          : normalizedSignalType)
        : normalizedSignalType;

      // ‚úÖ REFATORA√á√ÉO: Valida√ß√£o final consolidada (unifica todas as condi√ß√µes)
      // Usar effectiveSignalTypeForTrade ao inv√©s de normalizedSignalType para valida√ß√£o
      const tradeValidation = validateTradeCreation(
        !!savedSignal,
        effectiveSignalTypeForTrade, // ‚úÖ CORRE√á√ÉO: Usar effectiveSignalType
        validationScore,
        minScore,
        atrValidation,
        momentumValidation,
        isFallbackPattern
      );

      // ‚úÖ LOG DETALHADO: Identificar exatamente qual condi√ß√£o est√° bloqueando (especialmente para score ‚â•65)
      // Nota: allConditionsMet j√° verifica signalType !== 'NEUTRAL' (usando effectiveSignalTypeForTrade)
      const shouldCreateTrade = tradeValidation.allConditionsMet;

      // Log detalhado quando score ‚â•65 mas trade n√£o √© criado
      if (validationScore >= 65 && !shouldCreateTrade) {
        console.log('üö® [DEBUG SCORE 65+] Trade n√£o criado apesar de score ‚â•65:', {
          validationScore,
          effectiveSignalType: effectiveSignalTypeForTrade,
          normalizedSignalType,
          allConditionsMet: tradeValidation.allConditionsMet,
          validationDetails: tradeValidation.validationDetails,
          blockedBy: {
            noSignal: !savedSignal,
            signalTypeNeutral: effectiveSignalTypeForTrade === 'NEUTRAL',
            scoreTooLow: !tradeValidation.meetsScoreRequirement,
            scoreRequired: tradeValidation.adjustedMinScore,
            isFallbackPattern,
            noMomentum: !tradeValidation.canCreateTrade,
            atrInvalid: !atrValidation.atrValid,
            atrPercent: atrValidation.atrPercent.toFixed(3),
            atrRange: `${atrValidation.atrMinThreshold}-${atrValidation.atrMaxThreshold}%`
          }
        });
      }

      // ‚úÖ Log compacto: Crit√©rios de valida√ß√£o (consolidado)
      logEngine('debug', 'Crit√©rios de valida√ß√£o para trade', {
        signalType: normalizedSignalType,
        effectiveSignalType: effectiveSignalTypeForTrade,
        realScore: uiScore,
        validationScore,
        consolidatedScore,
        minScoreBase: minScore,
        adjustedMinScore: tradeValidation.adjustedMinScore,
        atrScoreReduction: atrValidation.atrScoreReduction,
        hasMomentum: momentumValidation.hasRealMomentum,
        hasDirectionalMovement: momentumValidation.hasDirectionalMovement,
        movementDirection: momentumValidation.movementDirection,
        atrPercent: atrValidation.atrPercent.toFixed(3),
        atrMinThreshold: atrValidation.atrMinThreshold,
        atrMaxThreshold: atrValidation.atrMaxThreshold,
        atrType: 'Multi-Timeframe (M1+M5+M15+M30)',
        momentumReason: momentumValidation.momentumCheck.hasMomentum ? 'OK' : momentumValidation.momentumCheck.reason,
        patternType: momentumValidation.momentumCheck.patternType || 'UNKNOWN',
        isFallback: isFallbackPattern,
        canCreateTrade: tradeValidation.canCreateTrade,
        atrValid: atrValidation.atrValid,
        meetsScore: tradeValidation.meetsScoreRequirement,
        isHighScoreOverride: tradeValidation.isHighScoreOverride,
        allConditionsMet: tradeValidation.allConditionsMet,
        shouldCreateTrade,
        validationDetails: tradeValidation.validationDetails
      });

      if (shouldCreateTrade) {
        // Extrair dados do sinal salvo
        // üêõ FIX: Usar currentPrice validado (j√° buscado da Binance se necess√°rio)
        let baseEntryPrice = (currentPrice && currentPrice > 0 && Number.isFinite(currentPrice))
          ? currentPrice
          : (Number.isFinite(priceNum) && priceNum > 0 ? priceNum : parseFloat(priceStr) || 0);

        // ‚úÖ NOVA L√ìGICA: Calcular entry_price com in√≠cio do padr√£o para score >= 55 (mais preciso)
        let entryPrice = baseEntryPrice;
        // candles j√° definido acima (linha 7397)

        // üéØ ESTRAT√âGIA MAIS PRECISA: Score >= 55 usa in√≠cio do padr√£o APENAS se pre√ßo atual est√° pr√≥ximo
        // ‚úÖ CORRE√á√ÉO: Usar validationScore para esta verifica√ß√£o (pode ser consolidatedScore)
        if (patternName && candles.length >= 5 && validationScore >= 55) {
          const patternStartPrice = calculatePatternStartEntryPrice(patternName, candles, normalizedSignalType, baseEntryPrice);

          // ‚úÖ CORRE√á√ÉO CR√çTICA: Verificar se pre√ßo atual est√° PR√ìXIMO do hist√≥rico (dentro de 0.5%)
          // S√≥ usar pre√ßo hist√≥rico se pre√ßo voltou para aquela zona (reteste)
          if (patternStartPrice && patternStartPrice > 0 && isPriceNearRetestZone(patternStartPrice, baseEntryPrice, 0.5)) {
            // Pre√ßo atual est√° pr√≥ximo da zona hist√≥rica ‚Üí pode usar hist√≥rico (reteste confirmado)
            entryPrice = patternStartPrice;
            console.log(`‚úÖ [In√≠cio Padr√£o] ${patternName} (score ${confidenceScore}) - Entry ajustado para in√≠cio: ${entryPrice.toFixed(2)} (atual: ${baseEntryPrice.toFixed(2)}) - Pre√ßo voltou para zona hist√≥rica`);
          } else {
            // Pre√ßo atual est√° DISTANTE do hist√≥rico ‚Üí usar pre√ßo atual (tempo real)
            entryPrice = baseEntryPrice;
            if (patternStartPrice && patternStartPrice > 0) {
              console.log(`‚è≥ [Tempo Real] ${patternName} (score ${confidenceScore}) - Entry em pre√ßo atual: ${baseEntryPrice.toFixed(2)} (hist√≥rico distante: ${patternStartPrice.toFixed(2)})`);
            }
            // Fallback: usar l√≥gica de reteste se padr√£o requer reteste
            if (patternRequiresRetest(patternName)) {
              const retestPrice = calculateRetestEntryPrice(patternName, candles, baseEntryPrice, normalizedSignalType);

              // Verificar se o pre√ßo atual est√° pr√≥ximo da zona de reteste (dentro de 0.5%)
              if (isPriceNearRetestZone(retestPrice, baseEntryPrice, 0.5)) {
                entryPrice = retestPrice;
                console.log(`‚úÖ [Reteste] Padr√£o ${patternName} - Entry ajustado para reteste: ${entryPrice.toFixed(2)} (original: ${baseEntryPrice.toFixed(2)})`);
              } else {
                entryPrice = baseEntryPrice;
                console.log(`‚è≥ [Reteste] Padr√£o ${patternName} - Aguardando reteste. Pre√ßo atual: ${baseEntryPrice.toFixed(2)}, Zona de reteste: ${retestPrice.toFixed(2)}`);
              }
            } else {
              entryPrice = baseEntryPrice;
            }
          }
        } else if (patternName && candles.length >= 5 && patternRequiresRetest(patternName)) {
          // Score < 55: usar l√≥gica de reteste tradicional
          const retestPrice = calculateRetestEntryPrice(patternName, candles, baseEntryPrice, normalizedSignalType);

          // Verificar se o pre√ßo atual est√° pr√≥ximo da zona de reteste (dentro de 0.5%)
          if (isPriceNearRetestZone(retestPrice, baseEntryPrice, 0.5)) {
            // Pre√ßo est√° na zona de reteste - usar pre√ßo de reteste
            entryPrice = retestPrice;
            console.log(`‚úÖ [Reteste] Padr√£o ${patternName} - Entry ajustado para reteste: ${entryPrice.toFixed(2)} (original: ${baseEntryPrice.toFixed(2)})`);
          } else {
            // Pre√ßo ainda n√£o chegou na zona de reteste - usar pre√ßo atual mas adicionar nota
            entryPrice = baseEntryPrice;
            console.log(`‚è≥ [Reteste] Padr√£o ${patternName} - Aguardando reteste. Pre√ßo atual: ${baseEntryPrice.toFixed(2)}, Zona de reteste: ${retestPrice.toFixed(2)}`);
          }
        }

        const targets = analysis.targets || null;
        const symbolConfig = getSymbolConfig(norm.withSlash);
        // ‚úÖ CORRE√á√ÉO: Stop ajustado para 0.45% para equilibrar prote√ß√£o e espa√ßo
        const stopPrice = targets?.sl || (normalizedSignalType === 'BUY' ? entryPrice * 0.9955 : entryPrice * 1.0045);
        // ‚úÖ CORRE√á√ÉO CR√çTICA: Target deve respeitar m√≠nimo de 1.2% (n√£o 0.65%)
        // Calcular target inicial respeitando m√≠nimo do s√≠mbolo
        const minTargetMultiplier = 1 + (symbolConfig.minTargetPct / 100);
        const targetPrice = targets?.tp1 || (normalizedSignalType === 'BUY'
          ? entryPrice * minTargetMultiplier  // BUY: entry * 1.012 (m√≠nimo 1.2%)
          : entryPrice * (2 - minTargetMultiplier)); // SELL: entry * 0.988 (m√≠nimo 1.2%)
        const confluencesArray = Array.isArray(activeConfluences) ? activeConfluences : [];

        // ‚úÖ MELHORIA 3: Adicionar aviso se trade foi criado com score alto mas Directional Confidence baixo
        if (tradeValidation.isHighScoreOverride && !momentumValidation.hasRealMomentum) {
          confluencesArray.push(`‚ö†Ô∏è Trade criado com score alto (${validationScore}) mesmo sem momentum perfeito - outras conflu√™ncias compensam`);
          console.log(`‚úÖ [HIGH SCORE OVERRIDE] Trade criado com score ${validationScore} mesmo sem momentum perfeito`);
        }

        // ‚úÖ Log compacto: Dados para criar trade (debug apenas)
        logEngine('debug', 'Preparando cria√ß√£o de trade_state', {
          entryPrice: entryPrice.toFixed(2),
          stopPrice: stopPrice.toFixed(2),
          targetPrice: targetPrice.toFixed(2),
          pattern: patternName,
          isHighScoreOverride: tradeValidation.isHighScoreOverride,
          hasMomentum: momentumValidation.hasRealMomentum
        });

        if (entryPrice > 0) {
          // üéØ Usar sempre 'system-ai' para trades simulados da IA (conta global de estudo)
          // ‚úÖ CORRE√á√ÉO CR√çTICA: Garantir que direction seja 'BUY' ou 'SELL' (nunca 'NEUTRAL')
          // O banco de dados s√≥ aceita 'BUY' ou 'SELL' na constraint
          const tradeDirection = normalizedSignalType === 'BUY' ? 'BUY' : normalizedSignalType === 'SELL' ? 'SELL' : null;
          if (!tradeDirection) {
            logEngine('warn', 'Trade n√£o criado: signalType √© NEUTRAL', {
              pattern: patternName,
              signalType: normalizedSignalType,
              validationScore
            });
            return;
          }
          // ‚úÖ Usar confidenceScore unificado (mesmo da UI) para criar trade
          // ‚úÖ FASE 1: Passar orderBookAnalysis para calcular spread real
          // ‚úÖ FIX: Passar marketRegime para salvar no trade (an√°lise estat√≠stica)
          const tradeStateResult = await createTradeState(supabase, 'system-ai', norm.withSlash, safeTimeframe, tradeDirection, entryPrice, stopPrice, targetPrice, patternName, confluencesArray, confidenceScore, orderBookAnalysis, marketRegime?.regime);

          // ‚úÖ Log compacto: Resultado da cria√ß√£o (info para sucesso, error para falha)
          if (tradeStateResult?.data) {
            const tradeId = tradeStateResult.data.id;
            const createdAt = tradeStateResult.data.created_at || new Date().toISOString();
            console.log(`üÜï [TRADE NOVO CRIADO] ID: ${tradeId} | ${patternName} ${normalizedSignalType} | Entry: ${entryPrice.toFixed(2)} | Stop: ${stopPrice.toFixed(2)} | Target: ${targetPrice.toFixed(2)} | Score: ${validationScore} | Criado em: ${createdAt}`);
            logEngine('info', 'Trade_state criado com sucesso', {
              tradeId: tradeId,
              pattern: patternName,
              direction: normalizedSignalType,
              entryPrice: entryPrice,
              stopPrice: stopPrice,
              targetPrice: targetPrice,
              validationScore: validationScore,
              createdAt: createdAt
            });
          } else if (tradeStateResult?.error) {
            logError('error', 'Erro ao criar trade_state', {
              error: tradeStateResult.error.message,
              pattern: patternName
            });
          }

          if (tradeStateResult?.data) {
            tradeStateCreated = true;
            logTrade('info', 'Sinal registrado e acompanhado pela IA', {
              pattern: patternName,
              direction: normalizedSignalType,
              entry: entryPrice,
              stop: stopPrice,
              tradeId: tradeStateResult.data.id
            });
            // üîµ TREND FOLLOWER: Calcular score de continuidade inicial
            try {
              const rsi = technicalIndicators?.rsi_14 || 50;
              const ema9 = technicalIndicators?.ema_9 || entryPrice;
              const ema50 = technicalIndicators?.ema_50 || entryPrice;
              const volume = marketData?.volume || 0;
              // Calcular scores individuais
              let rsiScore = 50;
              if (normalizedSignalType === 'BUY' && rsi < 40) rsiScore = 75;
              else if (normalizedSignalType === 'BUY' && rsi < 50) rsiScore = 60;
              else if (normalizedSignalType === 'SELL' && rsi > 60) rsiScore = 75;
              else if (normalizedSignalType === 'SELL' && rsi > 50) rsiScore = 60;
              let emaScore = 50;
              if (normalizedSignalType === 'BUY' && ema9 > ema50) emaScore = 70;
              else if (normalizedSignalType === 'SELL' && ema9 < ema50) emaScore = 70;
              let mtfScore = 50;
              const mtfConfirmation = multiTimeframeContext?.confirmation || 'neutral';
              if (mtfConfirmation === 'bullish' && normalizedSignalType === 'BUY') mtfScore = 70;
              else if (mtfConfirmation === 'bearish' && normalizedSignalType === 'SELL') mtfScore = 70;
              let volumeScore = 50;
              if (volume > 0) volumeScore = 60; // Volume presente √© positivo
              // Score din√¢mico da continuidade (m√©dia ponderada)
              const strengthScore = Math.round(rsiScore * 0.25 + emaScore * 0.25 + mtfScore * 0.25 + volumeScore * 0.25);
              let health = 'neutral';
              let message = 'Acompanhamento em andamento ‚Äî aguardando confirma√ß√£o.';
              if (strengthScore >= 75) {
                health = 'strong';
                message = 'üìà Estrutura forte ‚Äî movimento coerente com o padr√£o detectado.';
              } else if (strengthScore <= 40) {
                health = 'weak';
                message = '‚ö†Ô∏è Sinais de enfraquecimento ‚Äî momentum e conflu√™ncias reduzidos.';
              }
              await updateTrendFollow(supabase, tradeStateResult.data.id, strengthScore, health, message);
              logTrade('debug', 'TrendFollower atualizado', {
                score: strengthScore,
                health,
                tradeId: tradeStateResult.data.id
              });
              // üÜï HEALTH DECAY: Aplicar penalidade por idade
              await updateHealthDecay(supabase, tradeStateResult.data, strengthScore);
            } catch (trendError) {
              logTrade('warn', 'Erro ao atualizar TrendFollower', { error: trendError?.message || trendError });
            }
          } else {
            // ‚úÖ Log compacto: Entry price inv√°lido
            logEngine('warn', 'Trade n√£o criado: entry price inv√°lido', { entryPrice });
          }
        } else {
          // ‚úÖ Log compacto: Crit√©rios n√£o atendidos (consolidado)
          logEngine('debug', 'Trade n√£o criado: crit√©rios n√£o atendidos', {
            signalType: normalizedSignalType,
            isNeutral: normalizedSignalType === 'NEUTRAL',
            confidenceScore,
            validationScore,
            minScoreBase: minScore,
            adjustedMinScore: tradeValidation.adjustedMinScore,
            meetsScore: tradeValidation.meetsScoreRequirement,
            isFallback: isFallbackPattern,
            hasMomentum: momentumValidation.hasRealMomentum,
            hasDirectionalMovement: momentumValidation.hasDirectionalMovement,
            movementDirection: momentumValidation.movementDirection,
            atrPercent: atrValidation.atrPercent.toFixed(3),
            atrValid: atrValidation.atrValid,
            atrMinThreshold: atrValidation.atrMinThreshold,
            canCreateTrade: tradeValidation.canCreateTrade,
            isHighScoreOverride: tradeValidation.isHighScoreOverride,
            allConditionsMet: tradeValidation.allConditionsMet,
            validationDetails: tradeValidation.validationDetails,
            pattern: patternName
          });
        }
      } else if (isFallbackPattern) {
        // ‚úÖ DEBUG: Log quando padr√£o √© fallback
        console.log('‚ö†Ô∏è [DEBUG] Trade n√£o criado - padr√£o √© fallback (bloqueado):', {
          patternName,
          normalizedSignalType,
          consolidatedScore
        });
      }
    } catch (continuityError) {
      logError('error', 'ERRO ao criar trade_state', {
        message: continuityError?.message,
        stack: continuityError?.stack,
        error: continuityError
      });
      // N√£o quebra o fluxo - continua normalmente
    }
    // üîµ TREND FOLLOWER: Atualizar trade_state existente se N√ÉO criamos um novo
    if (!tradeStateCreated && normalizedSignalType !== 'NEUTRAL') {
      try {
        const activeTradeUpdate = await getActiveTradeState(supabase, userId, norm.withSlash, safeTimeframe);
        if (activeTradeUpdate?.data) {
          const rsi = technicalIndicators?.rsi_14 || 50;
          const ema9 = technicalIndicators?.ema_9 || priceNum;
          const ema50 = technicalIndicators?.ema_50 || priceNum;
          const volume = marketData?.volume || 0;
          // Calcular scores individuais
          let rsiScore = 50;
          if (normalizedSignalType === 'BUY' && rsi < 40) rsiScore = 75;
          else if (normalizedSignalType === 'BUY' && rsi < 50) rsiScore = 60;
          else if (normalizedSignalType === 'SELL' && rsi > 60) rsiScore = 75;
          else if (normalizedSignalType === 'SELL' && rsi > 50) rsiScore = 60;
          let emaScore = 50;
          if (normalizedSignalType === 'BUY' && ema9 > ema50) emaScore = 70;
          else if (normalizedSignalType === 'SELL' && ema9 < ema50) emaScore = 70;
          let mtfScore = 50;
          const mtfConfirmation = multiTimeframeContext?.confirmation || 'neutral';
          if (mtfConfirmation === 'bullish' && normalizedSignalType === 'BUY') mtfScore = 70;
          else if (mtfConfirmation === 'bearish' && normalizedSignalType === 'SELL') mtfScore = 70;
          let volumeScore = 50;
          if (volume > 0) volumeScore = 60;
          const strengthScore = Math.round(rsiScore * 0.25 + emaScore * 0.25 + mtfScore * 0.25 + volumeScore * 0.25);
          let health = 'neutral';
          let message = 'Acompanhamento em andamento ‚Äî aguardando confirma√ß√£o.';
          if (strengthScore >= 75) {
            health = 'strong';
            message = 'üìà Estrutura forte ‚Äî movimento coerente com o padr√£o detectado.';
          } else if (strengthScore <= 40) {
            health = 'weak';
            message = '‚ö†Ô∏è Sinais de enfraquecimento ‚Äî momentum e conflu√™ncias reduzidos.';
          }
          await updateTrendFollow(supabase, activeTradeUpdate.data.id, strengthScore, health, message);
          logTrade('debug', 'TrendFollower atualizado para trade existente', {
            score: strengthScore,
            health,
            tradeId: activeTradeUpdate.data.id
          });
          // üÜï HEALTH DECAY: Aplicar penalidade por idade
          await updateHealthDecay(supabase, activeTradeUpdate.data, strengthScore);
        }
      } catch (trendUpdateError) {
        logTrade('warn', 'Erro ao atualizar TrendFollower', { error: trendUpdateError?.message || trendUpdateError });
      }
    }
    // 8.1. Alimentar pipeline de feeds compartilhados (narrator_output)
    // ‚úÖ CORRE√á√ÉO: Separar em blocos try-catch independentes para n√£o bloquear aprendizado
    try {
      await supabase.from('narrator_output').insert({
        timestamp: new Date().toISOString(),
        symbol: norm.withSlash,
        timeframe: safeTimeframe,
        pattern_detected: safePattern,
        pattern_type: analysis.signalType || 'ANALYSIS',
        indicators: technicalIndicators || {},
        market_data: {
          price: Number.isFinite(priceNum) ? priceNum : 0,
          change24h: Number(marketData?.change24h) || 0,
          volume: Number(marketData?.volume) || 0,
          timeframe_context: multiTimeframeContext?.confirmation || 'neutral'
        },
        narrator_text: analysis.narration?.full || analysis.narration?.summary || 'An√°lise t√©cnica gerada',
        confidence_score: Number.isFinite(confidenceScore) ? Math.round(confidenceScore) : 0,
        processed_flag: false
      });
      console.log('üì° narrator_output atualizado para pipeline 3 IAs');
    } catch (narratorOutputError) {
      console.warn('‚ö†Ô∏è Erro ao salvar narrator_output (continuando):', narratorOutputError);
      // N√£o bloquear aprendizado se narrator_output falhar
    }

    // üÜï Salvar feedback do narrador (BLOCO INDEPENDENTE)
    // ‚úÖ CORRE√á√ÉO: Bloco separado para garantir que sempre execute
    try {
      const { data: feedbackData, error: feedbackError } = await supabase.from('narrator_feedback').insert({
        user_id: userId || 'system-ai',
        symbol: norm.withSlash,
        timeframe: safeTimeframe,
        pattern_detected: safePattern?.type || safePattern,
        narrator_text: analysis.narration?.full || analysis.narration?.summary || 'An√°lise t√©cnica gerada',
        confidence_score: Number.isFinite(confidenceScore) ? Math.round(confidenceScore) : 0,
        metadata: {
          pattern: safePattern,
          indicators: technicalIndicators,
          confluences: analysis.confluences,
          signalType: analysis.signalType,
          consolidatedScore: consolidatedScore
        },
        created_at: new Date().toISOString()
      }).select();

      if (feedbackError) {
        console.error('‚ùå Erro ao salvar feedback do narrador:', feedbackError);
        log('error', 'Erro ao salvar narrator_feedback', {
          error: feedbackError.message,
          code: feedbackError.code,
          details: feedbackError.details
        });
      } else {
        console.log('üí¨ ‚úÖ Feedback do narrador salvo com sucesso');
        log('debug', 'Feedback do narrador salvo', { id: feedbackData?.[0]?.id });
      }
    } catch (feedbackError) {
      console.error('‚ùå Erro inesperado ao salvar feedback do narrador:', feedbackError);
      log('error', 'Erro inesperado ao salvar narrator_feedback', {
        error: feedbackError?.message || feedbackError
      });
    }

    // üÜï Salvar learning progress (BLOCO INDEPENDENTE)
    // ‚úÖ CORRE√á√ÉO: Bloco separado para garantir que sempre execute
    try {
      const { data: learningData, error: learningError } = await supabase.from('learning_progress').insert({
        user_id: userId || 'system-ai',
        symbol: norm.withSlash,
        timeframe: safeTimeframe,
        pattern_type: safePattern?.type || safePattern,
        action: 'pattern_detected',
        metadata: {
          pattern: safePattern,
          score: consolidatedScore,
          signalType: analysis.signalType,
          confluences_count: analysis.confluences?.length || 0
        },
        created_at: new Date().toISOString()
      }).select();

      if (learningError) {
        console.error('‚ùå Erro ao salvar learning progress:', learningError);
        log('error', 'Erro ao salvar learning_progress', {
          error: learningError.message,
          code: learningError.code,
          details: learningError.details
        });
      } else {
        console.log('üß† ‚úÖ Learning progress salvo com sucesso');
        log('debug', 'Learning progress salvo', { id: learningData?.[0]?.id });
      }
    } catch (learningError) {
      console.error('‚ùå Erro inesperado ao salvar learning progress:', learningError);
      log('error', 'Erro inesperado ao salvar learning_progress', {
        error: learningError?.message || learningError
      });
    }

    // üöÄ CONVERSA AUTOM√ÅTICA: Chamar TradeVision IA para analisar este sinal (OPCIONAL)
    // ‚ö†Ô∏è Se trade-chat n√£o estiver deployado, ignora silenciosamente (n√£o √© cr√≠tico)
    try {
      console.log('üí¨ [CONVERSA] Tentando chamar TradeVision IA (opcional)...');
      const analysisMessage = `Analise este sinal que acabei de detectar: Padr√£o ${safePattern?.type || 'Desconhecido'} em ${norm.withSlash} ${safeTimeframe}. Confian√ßa: ${consolidatedScore}%. Conflu√™ncias: ${analysis.confluences?.length || 0} t√©cnicas ativas. ${analysis.narration?.summary || 'An√°lise t√©cnica completa gerada.'}`;
      const { data: tradeVisionResponse, error: tvError } = await supabase.functions.invoke('trade-chat', {
        body: {
          message: analysisMessage,
          userId: userId,
          sessionId: `narrator-${Date.now()}`,
          realTimeContext: {
            symbol: norm.withSlash,
            timeframe: safeTimeframe,
            pattern: safePattern,
            indicators: technicalIndicators,
            confluences: analysis.confluences
          }
        }
      });

      // ‚úÖ Se fun√ß√£o n√£o existe (404), ignora silenciosamente
      if (tvError) {
        const errorMsg = tvError?.message || tvError?.toString() || '';
        const errorStatus = tvError?.context?.status || tvError?.status || null;
        const is404 = errorStatus === 404 ||
          errorMsg.includes('404') ||
          errorMsg.includes('not found') ||
          errorMsg.includes('Failed to send') ||
          errorMsg.includes('non-2xx status code');

        if (is404) {
          // Funcionalidade opcional - n√£o logar como warning
          console.log('‚ÑπÔ∏è [CONVERSA] trade-chat n√£o deployado (opcional - ignorando silenciosamente)');
          // N√£o interrompe o fluxo principal ‚Äî apenas ignora a conversa opcional
        } else {
          // Outros erros s√£o logados mas n√£o bloqueiam
          console.warn('‚ö†Ô∏è [CONVERSA] Erro ao chamar trade-chat:', tvError);
        }
      }

      if (tradeVisionResponse) {
        // Salvar resposta no chat_messages
        try {
          await supabase.from('chat_messages').insert({
            user_id: userId,
            session_id: `narrator-${Date.now()}`,
            role: 'assistant',
            content: tradeVisionResponse.response || tradeVisionResponse,
            context_type: 'narrator_signal_response',
            metadata: {
              narrator_signal_id: savedSignal?.id,
              analysis: analysis,
              validation: tradeVisionValidation
            }
          });
          // Marcar como processado
          await supabase.from('narrator_output').update({
            processed_flag: true
          }).eq('id', savedSignal?.id);
          console.log('‚úÖ [CONVERSA] TradeVision IA respondeu ao sinal');
        } catch (saveError) {
          console.warn('‚ö†Ô∏è Erro ao salvar resposta da conversa:', saveError);
        }
      }
    } catch (conversationError) {
      // ‚úÖ Tratamento silencioso - funcionalidade opcional
      const errorMsg = conversationError?.message || conversationError?.toString() || '';
      const errorStatus = conversationError?.context?.status || conversationError?.status || null;
      const is404 = errorStatus === 404 ||
        errorMsg.includes('404') ||
        errorMsg.includes('not found') ||
        errorMsg.includes('non-2xx status code');

      if (is404) {
        // Funcionalidade opcional - n√£o logar como warning
        console.log('‚ÑπÔ∏è [CONVERSA] trade-chat n√£o dispon√≠vel (opcional - continuando normalmente)');
      } else {
        console.warn('‚ö†Ô∏è Erro na conversa autom√°tica (sinal seguindo sem resposta):', conversationError);
      }
    }
    // üß† BLOCO 4: Salvar no hist√≥rico temporal para aprendizado longitudinal
    await saveTemporalLearningHistory(supabase, {
      ...marketData,
      userId,
      pattern: safePattern
    }, multiTimeframeContext, consolidatedScore, tradeVisionValidation, {
      ...analysis,
      signalId: savedSignal?.id,
      technicalIndicators: safeTechnicalIndicators
    });
    console.log('üìö Hist√≥rico de aprendizado salvo');
    // üß† BLOCO 4.1: SALVAR CONHECIMENTO NA BASE DE CONHECIMENTO (OTIMIZADO)
    try {
      // ‚úÖ CORRE√á√ÉO: Usar formato normalizado (com barra) no topic para consist√™ncia
      const normalizedSymbol = norm.withSlash; // Garantir formato "BTC/USDT"
      const knowledgeTopic = `Narrador - ${safePattern?.type || 'An√°lise'} - ${normalizedSymbol}`;

      // ‚úÖ OTIMIZA√á√ÉO: Verificar se conhecimento similar j√° existe
      const { data: existingKnowledge } = await supabase.rpc('find_similar_knowledge', {
        p_topic: knowledgeTopic,
        p_symbol: normalizedSymbol,
        p_pattern: safePattern?.type || null
      });

      if (existingKnowledge) {
        // ‚úÖ Se existe similar, incrementar usage_count ao inv√©s de criar novo
        const { error: incrementError } = await supabase.rpc('increment_knowledge_usage', {
          knowledge_id: existingKnowledge
        });
        if (incrementError) {
          console.error('‚ùå Erro ao incrementar uso do conhecimento:', incrementError);
        } else {
          console.log('üß† Uso do conhecimento existente incrementado!');
        }
      } else {
        // ‚úÖ Criar novo registro apenas se n√£o existir similar
        const knowledgeContent = `An√°lise do Narrador: ${analysis.narration?.full || analysis.narration?.summary || 'An√°lise t√©cnica gerada'}\n\nPadr√£o: ${safePattern?.type || 'Desconhecido'}\nS√≠mbolo: ${safeSymbol}\nTimeframe: ${safeTimeframe}\nConfian√ßa: ${consolidatedScore}%\nConflu√™ncias: ${analysis.confluences?.join(', ') || 'Nenhuma'}\nValida√ß√£o IA: ${tradeVisionValidation.recommendation}`;

        // ‚úÖ Melhorar categoriza√ß√£o baseado no conte√∫do
        const category = safePattern?.type
          ? `Padr√£o: ${safePattern.type}`
          : analysis.confluences?.length > 0
            ? 'An√°lise com Conflu√™ncias'
            : 'Sinais do Narrador';

        const { error: knowledgeError } = await supabase.from('bot_knowledge').insert({
          topic: knowledgeTopic,
          content: knowledgeContent,
          category: category,
          metadata: {
            source: 'intelligent-narrator',
            symbol: norm.withSlash,
            timeframe: safeTimeframe,
            pattern: safePattern?.type,
            confidence: consolidatedScore,
            confluences: analysis.confluences?.length || 0,
            ai_validation: tradeVisionValidation.recommendation
          }
        });
        if (knowledgeError) {
          console.error('‚ùå Erro ao salvar conhecimento do narrador:', knowledgeError);
        } else {
          console.log('üß† Novo conhecimento do narrador salvo na base!');
        }
      }
    } catch (error) {
      console.error('‚ùå Erro na extra√ß√£o de conhecimento do narrador:', error);
    }
    // üß† BLOCO 5: Atualizar estado neural da sess√£o (n√£o cr√≠tico - n√£o bloquear resposta)
    try {
      await updateNeuralState(supabase, marketData.symbol, analysis, tradeVisionValidation, multiTimeframeContext, temporalAwareness);
      console.log('üß† Estado neural atualizado');
    } catch (neuralError) {
      console.warn('‚ö†Ô∏è Erro ao atualizar estado neural (n√£o cr√≠tico):', neuralError?.message || neuralError);
    }

    // 9. Atualizar conhecimento usado (n√£o cr√≠tico - n√£o bloquear resposta)
    if (analysis.knowledgeUsed && analysis.knowledgeUsed.length > 0) {
      try {
        for (const knowledgeId of analysis.knowledgeUsed) {
          // üîß CORRIGIDO: Usar padr√£o { data, error } ao inv√©s de await sem tratamento
          const { error: knowledgeUsageError } = await supabase.rpc('increment_knowledge_usage', {
            knowledge_id: knowledgeId
          });
          if (knowledgeUsageError) {
            log('warn', 'Erro ao incrementar uso do knowledge', {
              error: knowledgeUsageError.message,
              knowledgeId
            });
          }
        }
      } catch (knowledgeUsageError) {
        console.warn('‚ö†Ô∏è Erro ao incrementar uso do knowledge (n√£o cr√≠tico):', knowledgeUsageError?.message || knowledgeUsageError);
      }
    }

    // ‚úÖ GARANTIR: Sempre retornar Response v√°lida
    // ‚úÖ OTIMIZA√á√ÉO DE EGRESS: Limitar tamanho dos campos para reduzir tr√°fego
    const MAX_NARRATION_LENGTH = 1750;  // Limite de caracteres para narrativa
    const MAX_SUMMARY_LENGTH = 500;    // Limite de caracteres para summary
    const MAX_CONFLUENCES = 5;         // M√°ximo de confluences a retornar

    // Aplicar limites
    const optimizedNarration = analysis.narration
      ? (analysis.narration.length > MAX_NARRATION_LENGTH
        ? analysis.narration.substring(0, MAX_NARRATION_LENGTH) + '...'
        : analysis.narration)
      : null;

    const optimizedSummary = analysis.summary
      ? (analysis.summary.length > MAX_SUMMARY_LENGTH
        ? analysis.summary.substring(0, MAX_SUMMARY_LENGTH) + '...'
        : analysis.summary)
      : null;

    const optimizedConfluences = analysis.confluences || [];

    let responseBody;
    try {
      responseBody = JSON.stringify({
        success: true,
        signal: savedSignal,
        analysis: {
          score: analysis.confidenceScore,
          summary: optimizedSummary,
          confluences: optimizedConfluences,
          narration: optimizedNarration,
          confluencesTotal: Array.isArray(analysis.confluences) ? analysis.confluences.length : 0 // ‚úÖ Mant√©m contagem total
        },
        aiValidation: {
          recommendation: tradeVisionValidation.recommendation,
          reasoning: tradeVisionValidation.reasoning,
          shouldEnter: tradeVisionValidation.shouldEnter,
          keyInsights: tradeVisionValidation.keyPoints
        },
        timeframeContext: {
          m1: multiTimeframeContext.m1?.micro_insight,
          m5: multiTimeframeContext.m5?.tactical_insight,
          m15: multiTimeframeContext.m15?.contextual_insight,
          m30: multiTimeframeContext.m30?.strategic_insight,
          confirmation: multiTimeframeContext.confirmation
        },
        id: typeof crypto !== 'undefined' && crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random().toString(36).slice(2)}`,
        created_at: new Date().toISOString(),
        nonce: Date.now()
      });
    } catch (jsonError) {
      console.error('‚ùå Erro ao serializar resposta JSON:', jsonError);
      // Fallback: resposta m√≠nima v√°lida
      responseBody = JSON.stringify({
        success: true,
        signal: savedSignal,
        analysis: {
          score: analysis.confidenceScore || 0,
          summary: 'An√°lise conclu√≠da',
          confluences: [],
          narration: null
        },
        error: 'Erro ao serializar resposta completa'
      });
    }

    return new Response(responseBody, {
      status: 200,
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      }
    });
  } catch (error) {
    // ‚úÖ PROTE√á√ÉO EVENT LOOP: Limpar timeout em caso de erro
    clearTimeout(executionTimeout);
    console.error('‚ùå [NARRADOR] Erro detalhado:', error);
    console.error('‚ùå [NARRADOR] Stack trace:', error?.stack);
    console.error('‚ùå [NARRADOR] Error message:', error?.message);
    // ‚úÖ Garantir que sempre temos headers CORS, mesmo em caso de erro
    let safeCorsHeaders = defaultCorsHeaders;
    try {
      safeCorsHeaders = getSafeCorsHeaders();
    } catch (e) {
      // Se getSafeCorsHeaders falhar, usar headers padr√£o
      safeCorsHeaders = defaultCorsHeaders;
    }
    return new Response(JSON.stringify({
      success: false,
      error: error?.message || 'Unknown error',
      stack: error?.stack || '',
      type: error?.constructor?.name || 'Error'
    }), {
      status: 500,
      headers: {
        ...safeCorsHeaders,
        'Content-Type': 'application/json'
      }
    });
  } finally {
    // ‚úÖ PROTE√á√ÉO EVENT LOOP: Sempre limpar timeout ao final
    clearTimeout(executionTimeout);
  }
});

// ========== FUN√á√ïES AUXILIARES (FORA DO SERVE) ==========
async function getHistoricalContext(supabase, symbol, patternType, knowledge) {
  logIntelligence('debug', 'Buscando contexto hist√≥rico', { pattern: patternType, symbol });
  // 1. Buscar padr√µes similares nos √∫ltimos 30 dias (EXPANDIDO)
  let similarPatterns = [];
  try {
    const { data } = await supabase.from('narrator_signals').select('*').eq('symbol', symbol).ilike('pattern', `%${patternType}%`).gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()).order('created_at', {
      ascending: false
    }).limit(100); // Aumentado de 20 para 100
    similarPatterns = data || [];
  } catch (error) {
    console.warn('‚ö†Ô∏è Erro ao buscar padr√µes similares:', error);
    similarPatterns = [];
  }
  // 2. Calcular taxa de sucesso baseada em feedback (EXPANDIDO)
  let recentFeedback = [];
  try {
    const { data } = await supabase.from('narrator_feedback').select('*').eq('symbol', symbol).gte('created_at', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()).order('created_at', {
      ascending: false
    }).limit(50); // Aumentado de 10 para 50
    recentFeedback = data || [];
  } catch (error) {
    console.warn('‚ö†Ô∏è Erro ao buscar feedback recente:', error);
    recentFeedback = [];
  }

  // ‚úÖ CORRE√á√ÉO: Declarar safeRecentFeedback ANTES de usar
  const safeRecentFeedback = recentFeedback || [];

  // 3. Buscar conhecimento espec√≠fico do padr√£o
  const knowledgeMatches = knowledge.filter((k) => k.topic?.toLowerCase().includes(patternType?.toLowerCase()) || k.content?.toLowerCase().includes(patternType?.toLowerCase()) || k.topic?.toLowerCase().includes('tri√¢ngulo') || k.topic?.toLowerCase().includes('symmetric'));
  // 4. Calcular m√©tricas de sucesso
  let successRate = 0.5; // Default neutro
  if (safeRecentFeedback && safeRecentFeedback.length > 0) {
    const avgRating = safeRecentFeedback.reduce((sum, f) => sum + (f.rating || 0), 0) / safeRecentFeedback.length;
    successRate = avgRating / 5; // Normalizar para 0-1
  }
  // 5. Detectar sinais repetitivos (√∫ltimos 10 minutos)
  const safeSimilarPatterns = similarPatterns || [];
  const recentSignals = safeSimilarPatterns.filter((s) => s?.created_at && new Date(s.created_at) > new Date(Date.now() - 10 * 60 * 1000));
  // 6. An√°lise de padr√µes recorrentes
  const patternFrequency = safeSimilarPatterns.length;
  const isOverSignaled = recentSignals.length > 200; // ‚úÖ AJUSTE: Aumentado para 200 (menos restritivo)
  // Sistema anti-spam mais inteligente - apenas bloquear spam real
  const signalsLast10min = safeSimilarPatterns.filter((s) => s?.created_at && new Date(s.created_at) > new Date(Date.now() - 10 * 60 * 1000));
  // BLOQUEIO INTELIGENTE - Apenas se h√° MUITOS sinais similares (spam real)
  if (signalsLast10min.length > 150) {
    console.log('üö® SPAM REAL DETECTADO - Bloqueando temporariamente');
    return {
      confidenceScore: 0,
      signalType: 'NEUTRAL',
      confluences: [
        `üö® SPAM DETECTADO: ${signalsLast10min.length} sinais similares nos √∫ltimos 10min`
      ],
      knowledgeUsed: [],
      summary: 'Sistema anti-spam: spam real detectado',
      narration: {
        full: 'üö® SPAM DETECTADO: Muitos sinais similares nos √∫ltimos 10 minutos. Aguardando intervalo adequado.',
        summary: 'Sistema anti-spam: spam real detectado',
        analystComment: 'üö® SPAM DETECTADO: Muitos sinais similares nos √∫ltimos 10 minutos. Aguardando intervalo adequado.'
      },
      riskNote: 'Sistema anti-spam ativado',
      marketContext: 'Aguardando intervalo entre sinais',
      technicalScore: 0,
      volumeAnalysis: 'Sistema anti-spam ativo',
      patternDescription: 'Spam detectado'
    };
  }
  // BLOQUEIO MAIS PERMISSIVO - Apenas se h√° MUITOS sinais do mesmo padr√£o
  const samePatternLastHour = safeSimilarPatterns.filter((s) => s?.created_at && new Date(s.created_at) > new Date(Date.now() - 60 * 60 * 1000) && s.pattern === patternType);
  if (samePatternLastHour.length > 20) {
    console.log('üö® PADR√ÉO REPETIDO: Muitos sinais do mesmo padr√£o na √∫ltima hora');
    return {
      confidenceScore: 0,
      signalType: 'NEUTRAL',
      confluences: [
        `üö® PADR√ÉO REPETIDO: ${samePatternLastHour.length} ocorr√™ncias de "${patternType}" na √∫ltima hora`
      ],
      knowledgeUsed: [],
      summary: 'Sistema anti-spam: padr√£o repetido excessivo',
      narration: {
        full: 'üö® PADR√ÉO REPETIDO: Muitos sinais do mesmo padr√£o detectados. Aguardando intervalo adequado.',
        summary: 'Sistema anti-spam: padr√£o repetido excessivo',
        analystComment: 'üö® PADR√ÉO REPETIDO: Muitos sinais do mesmo padr√£o detectados. Aguardando intervalo adequado.'
      },
      riskNote: 'Sistema anti-spam bloqueando padr√£o repetido',
      marketContext: 'Aguardando intervalo entre padr√µes similares',
      technicalScore: 0,
      volumeAnalysis: 'Sistema anti-spam ativo - padr√£o repetido',
      patternDescription: 'Padr√£o repetido excessivo'
    };
  }
  const safeKnowledgeMatches = knowledgeMatches || [];
  // Se n√£o encontrou dados, retornar fallback
  if (patternFrequency === 0 && safeRecentFeedback.length === 0 && safeKnowledgeMatches.length === 0) {
    console.log('‚ÑπÔ∏è [BOS] Nenhum contexto hist√≥rico encontrado - usando fallback padr√£o');
    return {
      similarPatterns: [],
      recentSignals: [],
      successRate: 0.5, // Default neutro
      count: 0,
      averageMove: 0,
      knowledgeMatches: []
    };
  }

  console.log('üìä An√°lise hist√≥rica:', {
    similarPatterns: patternFrequency,
    recentSignals: recentSignals.length,
    successRate: (successRate * 100).toFixed(1) + '%',
    isOverSignaled,
    knowledgeMatches: safeKnowledgeMatches.length
  });
  // ‚úÖ CORRE√á√ÉO: safeRecentFeedback j√° foi declarado acima, n√£o precisa redeclarar
  const safeRecentSignals = safeSimilarPatterns.filter((s) => s?.created_at && new Date(s.created_at) > new Date(Date.now() - 10 * 60 * 1000));
  return {
    similarPatterns: safeSimilarPatterns,
    recentSignals: safeRecentSignals,
    successRate: successRate || 0.5,
    count: patternFrequency || 0,
    averageMove: 0, // Ser√° calculado quando houver dados suficientes
    recentFeedback: safeRecentFeedback,
    knowledgeMatches: safeKnowledgeMatches,
    patternFrequency: safeSimilarPatterns.length,
    isOverSignaled: isOverSignaled || false,
    avgConfidence: safeSimilarPatterns.length > 0 ? safeSimilarPatterns.reduce((sum, s) => sum + (s.probability || 0), 0) / safeSimilarPatterns.length : 50
  };
}
// ========== FUN√á√ÉO DE CONSULTA MULTI-TIMEFRAME DIRETA (BINANCE) ==========
async function getMultiTimeframeContextDirect(binanceSymbol) {
  // Log removido - j√° logado no ponto de chamada
  try {
    // ‚úÖ FRACTAL: Buscar dados de TODOS os timeframes simultaneamente (incluindo H1 e D1)
    const [m1Result, m5Result, m15Result, m30Result, h1Result, d1Result] = await Promise.allSettled([
      fetch(`https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=1m&limit=50`, {
        signal: AbortSignal.timeout(5000)
      }),
      fetch(`https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=5m&limit=50`, {
        signal: AbortSignal.timeout(5000)
      }),
      fetch(`https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=15m&limit=50`, {
        signal: AbortSignal.timeout(5000)
      }),
      fetch(`https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=30m&limit=50`, {
        signal: AbortSignal.timeout(5000)
      }),
      fetch(`https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=1h&limit=50`, {
        signal: AbortSignal.timeout(5000)
      }),
      fetch(`https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=1d&limit=50`, {
        signal: AbortSignal.timeout(5000)
      })
    ]);
    // ‚úÖ FRACTAL: Processar TODAS as velas (n√£o apenas a √∫ltima) para detec√ß√£o de padr√µes
    const processTimeframeData = (result, timeframe) => {
      if (result.status === 'fulfilled') {
        try {
          const data = result.value.json();
          return data.then((klines) => {
            if (Array.isArray(klines) && klines.length > 0) {
              const latest = klines[klines.length - 1];
              // ‚úÖ FRACTAL: Converter todas as velas para formato padronizado
              const candles = klines.map(k => ({
                open: parseFloat(k[1]),
                high: parseFloat(k[2]),
                low: parseFloat(k[3]),
                close: parseFloat(k[4]),
                volume: parseFloat(k[5]),
                timestamp: k[6],
                time: k[0]
              }));

              return {
                symbol: binanceSymbol,
                timeframe,
                price: parseFloat(latest[4]),
                volume: parseFloat(latest[5]),
                timestamp: latest[6],
                high: parseFloat(latest[2]),
                low: parseFloat(latest[3]),
                open: parseFloat(latest[1]),
                // ‚úÖ FRACTAL: Incluir todas as velas para detec√ß√£o de padr√µes
                candles: candles
              };
            }
            return null;
          });
        } catch (error) {
          logError('warn', `Erro ao processar dados ${timeframe}`, { error: error?.message || error });
          return null;
        }
      }
      return null;
    };
    const m1 = await processTimeframeData(m1Result, '1m');
    const m5 = await processTimeframeData(m5Result, '5m');
    const m15 = await processTimeframeData(m15Result, '15m');
    const m30 = await processTimeframeData(m30Result, '30m');
    const h1 = await processTimeframeData(h1Result, '1h');
    const d1 = await processTimeframeData(d1Result, '1d');
    // An√°lise de confirma√ß√£o entre timeframes
    let confirmation = 'neutral';
    let shouldReject = false;
    let rejectionReason = '';
    // Log compacto apenas em debug
    if (LOG_LEVEL === 'debug') {
      const availableTimeframes = [m1 && 'M1', m5 && 'M5', m15 && 'M15', m30 && 'M30', h1 && 'H1', d1 && 'D1'].filter(Boolean).join(', ');
      logData('debug', `Timeframes dispon√≠veis: ${availableTimeframes || 'nenhum'}`, {
        m1: !!m1, m5: !!m5, m15: !!m15, m30: !!m30, h1: !!h1, d1: !!d1
      });
    }
    // Se temos contexto M15 e M30, validar alinhamento
    if (m15 && m30) {
      const m15Trend = m15.price > m15.open ? 'bullish' : 'bearish';
      const m30Trend = m30.price > m30.open ? 'bullish' : 'bearish';
      if (m15Trend === m30Trend) {
        confirmation = 'aligned';
        logIntelligence('info', 'Tend√™ncias alinhadas', { m15: m15Trend, m30: m30Trend });
      } else {
        confirmation = 'divergent';
        shouldReject = true;
        rejectionReason = `Diverg√™ncia temporal: M15 ${m15Trend} vs M30 ${m30Trend}`;
        logIntelligence('warn', 'Diverg√™ncia temporal detectada', { m15: m15Trend, m30: m30Trend });
      }
    }
    return {
      m1,
      m5,
      m15,
      m30,
      h1, // ‚úÖ FRACTAL: Adicionar H1
      d1, // ‚úÖ FRACTAL: Adicionar D1
      confirmation,
      shouldReject,
      rejectionReason
    };
  } catch (error) {
    logError('error', 'Erro ao buscar contexto multi-timeframe', { error: error?.message || error });
    return {
      m1: null,
      m5: null,
      m15: null,
      m30: null,
      h1: null, // ‚úÖ FRACTAL: Adicionar H1 no fallback
      d1: null, // ‚úÖ FRACTAL: Adicionar D1 no fallback
      confirmation: 'neutral',
      shouldReject: false,
      rejectionReason: ''
    };
  }
}

// ‚úÖ FRACTAL: Nova fun√ß√£o para detectar padr√µes em m√∫ltiplos timeframes
async function detectPatternsMultiTimeframe(multiTimeframeContext) {
  try {
    const patterns = {};

    // Detectar padr√µes em cada timeframe (se tiver velas dispon√≠veis)
    if (multiTimeframeContext?.m1?.candles && multiTimeframeContext.m1.candles.length >= 3) {
      try {
        patterns.m1 = await detectRealPattern(multiTimeframeContext.m1.candles, {});
      } catch (error) {
        logError('warn', 'Erro ao detectar padr√£o M1', { error: error?.message || error });
      }
    }

    if (multiTimeframeContext?.m5?.candles && multiTimeframeContext.m5.candles.length >= 3) {
      try {
        patterns.m5 = await detectRealPattern(multiTimeframeContext.m5.candles, {});
      } catch (error) {
        logError('warn', 'Erro ao detectar padr√£o M5', { error: error?.message || error });
      }
    }

    if (multiTimeframeContext?.m15?.candles && multiTimeframeContext.m15.candles.length >= 3) {
      try {
        patterns.m15 = await detectRealPattern(multiTimeframeContext.m15.candles, {});
      } catch (error) {
        logError('warn', 'Erro ao detectar padr√£o M15', { error: error?.message || error });
      }
    }

    if (multiTimeframeContext?.m30?.candles && multiTimeframeContext.m30.candles.length >= 10) {
      try {
        patterns.m30 = await detectRealPattern(multiTimeframeContext.m30.candles, {});
      } catch (error) {
        logError('warn', 'Erro ao detectar padr√£o M30', { error: error?.message || error });
      }
    }

    if (multiTimeframeContext?.h1?.candles && multiTimeframeContext.h1.candles.length >= 10) {
      try {
        patterns.h1 = await detectRealPattern(multiTimeframeContext.h1.candles, {});
      } catch (error) {
        logError('warn', 'Erro ao detectar padr√£o H1', { error: error?.message || error });
      }
    }

    if (multiTimeframeContext?.d1?.candles && multiTimeframeContext.d1.candles.length >= 10) {
      try {
        patterns.d1 = await detectRealPattern(multiTimeframeContext.d1.candles, {});
      } catch (error) {
        logError('warn', 'Erro ao detectar padr√£o D1', { error: error?.message || error });
      }
    }

    return patterns;
  } catch (error) {
    logError('warn', 'Erro ao detectar padr√µes multi-timeframe', { error: error?.message || error });
    return {};
  }
}
// ========== FUN√á√ÉO DE CONSULTA MULTI-TIMEFRAME (LEGACY - TABELAS) ==========
async function getMultiTimeframeContext(supabase, symbol) {
  // Log removido - j√° logado no ponto de chamada
  try {
    // Buscar √∫ltimo registro de cada timeframe com timeout
    const [m1Result, m5Result, m15Result, m30Result] = await Promise.allSettled([
      supabase.from('market_m1').select('*').eq('symbol', symbol).order('timestamp', {
        ascending: false
      }).limit(1).maybeSingle(),
      supabase.from('market_m5').select('*').eq('symbol', symbol).order('timestamp', {
        ascending: false
      }).limit(1).maybeSingle(),
      supabase.from('market_m15').select('*').eq('symbol', symbol).order('timestamp', {
        ascending: false
      }).limit(1).maybeSingle(),
      supabase.from('market_m30').select('*').eq('symbol', symbol).order('timestamp', {
        ascending: false
      }).limit(1).maybeSingle()
    ]);
    const m1 = m1Result.status === 'fulfilled' ? m1Result.value.data : null;
    const m5 = m5Result.status === 'fulfilled' ? m5Result.value.data : null;
    const m15 = m15Result.status === 'fulfilled' ? m15Result.value.data : null;
    const m30 = m30Result.status === 'fulfilled' ? m30Result.value.data : null;
    // An√°lise de confirma√ß√£o entre timeframes
    let confirmation = 'neutral';
    let shouldReject = false;
    let rejectionReason = '';
    // Log compacto apenas em debug
    if (LOG_LEVEL === 'debug') {
      const availableTimeframes = [m1 && 'M1', m5 && 'M5', m15 && 'M15', m30 && 'M30'].filter(Boolean).join(', ');
      logData('debug', `Timeframes dispon√≠veis: ${availableTimeframes || 'nenhum'}`, {
        m1: !!m1, m5: !!m5, m15: !!m15, m30: !!m30
      });
    }
    // Se temos contexto M15 e M30, validar alinhamento
    if (m15 && m30) {
      const m15Direction = m15.trend_direction;
      const m30MacroTrend = m30.macro_trend;
      logIntelligence('debug', 'An√°lise M15/M30', { m15Direction, m30MacroTrend });
      // Confirma√ß√£o positiva - aceitar TODAS as diverg√™ncias para teste
      confirmation = 'aligned';
    } else if (m15) {
      // Se s√≥ temos M15, usar como refer√™ncia
      confirmation = 'partial';
      logData('debug', 'Apenas M15 dispon√≠vel', { trend: m15.trend_direction });
    } else if (m30) {
      // Se s√≥ temos M30, usar como refer√™ncia
      confirmation = 'partial';
      logData('debug', 'Apenas M30 dispon√≠vel', { trend: m30.macro_trend });
    } else {
      // Sem dados multi-timeframe, usar neutral
      confirmation = 'neutral';
      logData('warn', 'Nenhum dado multi-timeframe dispon√≠vel');
    }
    return {
      m1,
      m5,
      m15,
      m30,
      confirmation,
      shouldReject,
      rejectionReason
    };
  } catch (error) {
    logError('error', 'Erro ao buscar contexto multi-timeframe', { error: error?.message || error });
    // Retornar contexto neutro em caso de erro
    return {
      m1: null,
      m5: null,
      m15: null,
      m30: null,
      confirmation: 'neutral',
      shouldReject: false,
      rejectionReason: 'Erro ao carregar contexto multi-timeframe'
    };
  }
}
// ========== MOTOR DE VALIDA√á√ÉO TRADEVISION IA ==========
async function validateWithTradeVisionAI(analysis, pattern, marketData, indicators, knowledge, multiTimeframeContext, additionalData = {}) {
  logIntelligence('info', 'TradeVision IA analisando contexto profundo', {
    pattern: pattern?.type || 'unknown',
    symbol: marketData?.symbol
  });
  // Aplicar contexto hist√≥rico antes de retornar
  if (additionalData.historicalContext) {
    const { historicalContext } = additionalData;
    // ‚úÖ AJUSTE: Over-signaled apenas penaliza -15 pontos (n√£o bloqueia mais)
    if (historicalContext?.isOverSignaled) {
      analysis.confidenceScore -= 15; // ‚úÖ AJUSTE: Reduzido de 50 para 15
      analysis.confluences.push(`‚ö†Ô∏è Padr√£o super-sinalizado: ${historicalContext?.recentSignals?.length || 0} sinais nos √∫ltimos 10min - PENALIDADE APLICADA`);
    }
    if (historicalContext?.recentFeedback?.length > 0) {
      const avgRating = historicalContext.recentFeedback.reduce((sum, f) => sum + f.rating, 0) / historicalContext.recentFeedback.length;
      if (avgRating <= 2.5) {
        analysis.confidenceScore -= 25;
        analysis.confluences.push(`üëé Feedback muito negativo: ${avgRating.toFixed(1)}/5 estrelas - PENALIDADE FORTE`);
      }
    }
    console.log('üìö Contexto hist√≥rico aplicado. Score final:', analysis.confidenceScore);
  }
  // ============================================================================
  // üéØ SISTEMA DE AUTORIDADE: Score N√ÉO decide sozinho - Autoridade decide
  // ============================================================================
  // ‚úÖ CORRE√á√ÉO: Verificar se houve hard block antes de permitir entrada
  const hasHardBlock = analysis.signalType === 'NEUTRAL' && analysis.confidenceScore === 0;
  const hasPatternMemoryBlock = analysis.confluences?.some(c => c.includes('PATTERN MEMORY HARD BLOCK'));
  const hasSpamBlock = analysis.confluences?.some(c => c.includes('SPAM DETECTADO'));
  const isBlocked = hasHardBlock || hasPatternMemoryBlock || hasSpamBlock;

  // üü¢ GREEN LIGHT: Autoriza√ß√£o formal vem da an√°lise inteligente
  const greenLight = analysis.metadata?.greenLight || false;
  const greenLightPath = analysis.metadata?.greenLightPath || null;

  // ‚úÖ CORRE√á√ÉO: Recommendation respeita autoridade PRIMEIRO
  let recommendation = 'WAIT';
  if (isBlocked) {
    recommendation = 'AVOID'; // Hard block = AVOID sempre
  } else if (greenLight && analysis.confidenceScore >= 60) {
    recommendation = 'STRONG_BUY'; // üü¢ GREEN LIGHT + score alto
  } else if (greenLight) {
    recommendation = 'BUY'; // üü¢ GREEN LIGHT ativo
  } else if (analysis.confidenceScore >= 50) {
    recommendation = 'PROCEED'; // Score ok mas sem GREEN LIGHT
  } else {
    recommendation = 'WAIT'; // Score baixo = WAIT
  }

  // ‚úÖ CORRE√á√ÉO FINAL: shouldEnter = greenLight (autoridade decide, n√£o score)
  // üéØ MODE: OBSERVE nunca permite entrada
  const modePermissions = getModePermissions();
  const greenLightAllowed = greenLight && !isBlocked;
  const shouldEnter = modePermissions.allowShouldEnter ? greenLightAllowed : false;

  // Log do modo para debug
  if (greenLightAllowed && !shouldEnter) {
    console.log(`üîç [MODE] shouldEnter bloqueado por modo ${TRADING_MODE}`, {
      greenLight,
      modeAllows: modePermissions.allowShouldEnter
    });
  }

  return {
    shouldDiscard: analysis.confidenceScore < 0.01 || isBlocked,
    recommendation: modePermissions.allowShouldEnter ? recommendation : 'OBSERVE',
    reasoning: `An√°lise t√©cnica: ${analysis.confluences.length} conflu√™ncias, score ${analysis.confidenceScore}%${greenLight ? ' üü¢ GREEN LIGHT' : ''}${isBlocked ? ' [BLOCKED]' : ''} [${TRADING_MODE}]`,
    aiConfidence: analysis.confidenceScore,
    shouldEnter, // üü¢ GREEN LIGHT + MODE √© a autoridade
    keyPoints: analysis.confluences.slice(0, 3),
    enhancedRiskNote: analysis.riskNote,
    contextualInsight: analysis.marketContext,
    suggestedActionWindow: 300,
    urgencyLevel: greenLight ? 'high' : analysis.confidenceScore >= 40 ? 'medium' : 'low',
    aiValidationSource: 'technical_analysis',
    isBlocked, // Flag de bloqueio
    greenLight, // üü¢ Flag de autoriza√ß√£o FINAL
    greenLightPath, // Qual caminho autorizou (MOMENTUM, RANGE, TREND)
    signalFlipped: analysis.metadata?.signalFlipped || false, // üö® Flip tardio detectado
    tradingMode: TRADING_MODE, // üéØ Modo atual
    modeAllowsExecution: modePermissions.allowExecution // üéØ Se modo permite execu√ß√£o real
  };
}
// ========== AN√ÅLISE INTELIGENTE DE PADR√ïES ==========
// ========== AN√ÅLISE INTELIGENTE DE PADR√ïES ==========
// ‚úÖ UnifiedBrain j√° est√° definido no n√≠vel superior (linha ~716)

async function analyzePatternIntelligently(pattern, marketData, technicalIndicators, knowledge, multiTimeframeContext, additionalData = {}) {
  logIntelligence('info', 'Iniciando an√°lise inteligente', { hasHistoricalContext: !!additionalData.historicalContext });
  let confidenceScore = 35; // ‚úÖ CORRE√á√ÉO: Base neutra - sistema nasce sem permiss√£o de trade, conflu√™ncias levam para cima
  const confluences = [];
  const knowledgeUsed = [];
  let signalType = 'NEUTRAL'; // ‚úÖ PATCH 6: Default NEUTRAL ao inv√©s de BUY

  // ‚úÖ CORRE√á√ÉO: Declarar currentPrice no escopo da fun√ß√£o para uso em m√∫ltiplos blocos
  const currentPrice = Number(marketData?.close) || Number(marketData?.price) || additionalData?.currentPrice || 0;

  // üß† BLOCO 0: APLICAR CONTEXTO HIST√ìRICO ANTES DE TUDO
  const { historicalContext = {}, patternMemory = [], supabase: supabaseClient } = additionalData || {};
  // üß† BLOCO 0.3: BUSCAR PESOS DIN√ÇMICOS (REINFORCEMENT LEARNING)
  let dynamicWeights = {};
  const detectedSignals = []; // Rastrear quais sinais foram detectados
  if (supabaseClient) {
    try {
      const { data: weightsData, error: weightsError } = await supabaseClient.from('signal_weights').select('signal_name, current_weight, win_rate').limit(100);
      if (!weightsError && weightsData) {
        dynamicWeights = weightsData.reduce((acc, w) => {
          acc[w.signal_name] = w;
          return acc;
        }, {});
        const weightsCount = Object.keys(dynamicWeights).length;
        if (weightsCount === 0) {
          console.log('‚ö†Ô∏è [RL] Carregados 0 pesos din√¢micos - inicializando pesos padr√£o');
          // Inicializar pesos padr√£o se tabela estiver vazia
          dynamicWeights = {
            'trend': { signal_name: 'trend', current_weight: 1.0, win_rate: 0.5 },
            'rsi': { signal_name: 'rsi', current_weight: 1.0, win_rate: 0.5 },
            'orderbook': { signal_name: 'orderbook', current_weight: 1.0, win_rate: 0.5 },
            'pattern': { signal_name: 'pattern', current_weight: 1.0, win_rate: 0.5 },
            'volume': { signal_name: 'volume', current_weight: 1.0, win_rate: 0.5 }
          };
          console.log('‚úÖ [RL] Pesos padr√£o inicializados');
        } else {
          console.log(`üîß [RL] Carregados ${weightsCount} pesos din√¢micos`);
        }
      } else if (weightsError) {
        // Ignorar silenciosamente se a tabela n√£o existe (funcionalidade opcional)
        const errorCode = weightsError?.code || '';
        const errorMessage = weightsError?.message || '';
        if (errorCode === 'PGRST205' || errorMessage.includes('Could not find the table') || errorMessage.includes('signal_weights')) {
          // Tabela n√£o existe - funcionalidade opcional, continuar normalmente
          console.log('‚ÑπÔ∏è [RL] Tabela signal_weights n√£o encontrada (opcional - usando pesos fixos)');
        } else {
          // Outros erros s√£o logados
          console.warn('‚ö†Ô∏è Erro ao carregar pesos din√¢micos:', weightsError);
        }
      }
    } catch (rlError) {
      // Ignorar silenciosamente se a tabela n√£o existe
      const errorMsg = rlError?.message || rlError?.toString() || '';
      if (errorMsg.includes('signal_weights') || errorMsg.includes('Could not find the table')) {
        console.log('‚ÑπÔ∏è [RL] Sistema de Reinforcement Learning n√£o dispon√≠vel (opcional - usando pesos fixos)');
      } else {
        console.warn('‚ö†Ô∏è Erro no sistema de Reinforcement Learning:', rlError);
      }
      // N√ÉO quebra o fluxo - continua com pesos fixos
    }
  }
  // üìä BLOCO 0.45: DETECTAR CONTEXTO DE RANGE E APLICAR BOOST
  // ‚úÖ NOVO: Boost de +15/+20 quando pre√ßo est√° nos extremos de um range v√°lido
  let rangeContext = { isRange: false, atExtreme: false, boost: 0, direction: 'NEUTRAL', details: {} };
  try {
    // ‚úÖ CORRE√á√ÉO: currentPrice j√° foi declarado no escopo da fun√ß√£o (linha 11019)
    const candles = additionalData?.candles || additionalData?.historicalContext?.recentCandles || [];

    if (candles.length >= 15 && currentPrice > 0) {
      rangeContext = detectRangeContext(candles, currentPrice, technicalIndicators);

      if (rangeContext.isRange && rangeContext.atExtreme && rangeContext.boost > 0) {
        // üéØ RANGE BOOST ADAPTATIVO POR MODO
        const modeRangeBoost = getModePermissions().rangeBoost || 10;
        const extraBoost = modeRangeBoost - 10; // PAPER: +5 extra, LIVE: +0
        const totalBoost = rangeContext.boost + extraBoost;

        confidenceScore += totalBoost;
        confluences.push(`üìä RANGE CONTEXT: Pre√ßo no ${rangeContext.direction === 'SELL' ? 'TOPO' : 'FUNDO'} do range ‚Üí +${totalBoost} pontos [${TRADING_MODE}]`);

        // Alinhar dire√ß√£o do sinal com posi√ß√£o no range (se ainda NEUTRAL)
        if (signalType === 'NEUTRAL' || signalType === rangeContext.direction) {
          signalType = rangeContext.direction;
          confluences.push(`üìä Dire√ß√£o alinhada com range: ${rangeContext.direction}`);
        }

        console.log(`üìä [RANGE CONTEXT] Boost aplicado`, {
          baseBoost: rangeContext.boost,
          modeBoost: extraBoost,
          totalBoost,
          mode: TRADING_MODE,
          direction: rangeContext.direction,
          isRange: rangeContext.isRange,
          atExtreme: rangeContext.atExtreme,
          details: rangeContext.details,
          newScore: confidenceScore
        });
      } else if (rangeContext.isRange) {
        console.log(`üìä [RANGE CONTEXT] Range detectado mas pre√ßo N√ÉO est√° nos extremos`, {
          distanceToHigh: rangeContext.details.distanceToHigh,
          distanceToLow: rangeContext.details.distanceToLow
        });
      }
    }
  } catch (rangeError) {
    console.warn('‚ö†Ô∏è Erro ao detectar contexto de range:', rangeError);
    // N√£o quebra o fluxo - continua sem boost de range
  }

  // ============================================================================
  // ‚ö° BLOCO 0.35: DETECTAR EXAUST√ÉO DE RUN (Fim de Alta/Queda)
  // ============================================================================
  const exhaustionCandles = additionalData?.candles || additionalData?.historicalContext?.recentCandles || [];
  let runExhaustion = { isExhausted: false, runDirection: null, reversalDirection: null, confidence: 0, details: {} };

  if (exhaustionCandles.length >= 20) { // ‚úÖ v284: Aumentado de 8 para 20
    runExhaustion = detectRunExhaustion(exhaustionCandles, technicalIndicators);

    if (runExhaustion.isExhausted) {
      // ‚úÖ BOOST: Se a dire√ß√£o do sinal coincide com a revers√£o esperada
      if ((runExhaustion.reversalDirection === 'BUY' && signalType === 'BUY') ||
        (runExhaustion.reversalDirection === 'SELL' && signalType === 'SELL')) {
        const exhaustionBoost = Math.round(runExhaustion.confidence / 10); // +6 a +10 pts
        confidenceScore += exhaustionBoost;
        confluences.push(`‚ö° RUN EXHAUSTION: Exaust√£o ap√≥s ${runExhaustion.runDirection} run ‚Üí +${exhaustionBoost} pts (Revers√£o ${runExhaustion.reversalDirection})`);
      }
      // ‚ùå PENALTY v284: Se o sinal vai CONTRA a revers√£o esperada (comprando topo / vendendo fundo)
      else if ((runExhaustion.reversalDirection === 'SELL' && signalType === 'BUY') ||
        (runExhaustion.reversalDirection === 'BUY' && signalType === 'SELL')) {
        const exhaustionPenalty = -15; // ‚úÖ v288: Reduzido de -25 para -15 (menos restritivo)
        confidenceScore += exhaustionPenalty;
        confluences.push(`üö´ RUN EXHAUSTION CONTRA: ${signalType} ap√≥s ${runExhaustion.runDirection} run exausto ‚Üí ${exhaustionPenalty} pts (Deveria ${runExhaustion.reversalDirection})`);
        console.log(`üö´ [RUN EXHAUSTION] CONTRA-SINAL: ${signalType} quando deveria ${runExhaustion.reversalDirection}`, {
          runDirection: runExhaustion.runDirection,
          signalType,
          confidence: runExhaustion.confidence,
          penalty: exhaustionPenalty
        });
      }
    }
  }

  // ============================================================================
  // üèÜ BLOCO 0.4: APLICAR PATTERN TRUST COM CONTEXTO (v289)
  // ‚úÖ Usa fun√ß√£o async que consulta banco + valida contexto de mercado
  // ============================================================================
  let patternTrust = { adjustment: 0, action: 'NONE', winRate: 0.5, shouldBlock: false };
  try {
    // Preparar contexto de mercado para Pattern Trust
    const candles = additionalData?.candles || additionalData?.historicalContext?.recentCandles || [];

    // Detectar Trap/Sweep (violinada)
    let hasSweep = false;
    if (candles.length >= 5 && rangeContext.isRange) {
      const zone = {
        top: parseFloat(rangeContext.details?.rangeHigh || '0'),
        bottom: parseFloat(rangeContext.details?.rangeLow || '0')
      };
      if (zone.top > 0 && zone.bottom > 0) {
        const trapResult = detectTrap(candles, zone);
        hasSweep = trapResult.isTrap;
        if (hasSweep) {
          console.log(`ü™§ [PATTERN TRUST] Sweep/Trap detectado: ${trapResult.trapType}`);
        }
      }
    }

    // Detectar Volume Spike
    const avgVolume = candles.slice(-10, -1).reduce((sum, c) => sum + (Number(c?.volume) || 0), 0) / 9;
    const currentVolume = Number(candles[candles.length - 1]?.volume) || 0;
    const hasVolumeSpike = currentVolume > avgVolume * 1.3;

    // Detectar Wyckoff Phase
    let isWyckoff = false;
    try {
      const volumes = candles.map(c => c.volume);
      const cycle = detectMarketCycle(candles, volumes, additionalData?.orderBookAnalysis);
      isWyckoff = cycle && cycle.phase !== 'CONSOLIDATION';
    } catch (cycleErr) {
      // Ignore
    }

    // Chamar Pattern Trust COM CONTEXTO
    const patternName = typeof pattern === 'object' ? pattern?.type || pattern?.name : pattern;
    const symbol = additionalData?.symbol || additionalData?.marketData?.symbol || 'BTCUSDT';

    patternTrust = await getPatternTrustFromDB(supabaseClient, patternName, symbol, {
      hasLiquiditySweep: hasSweep,
      atRangeExtreme: rangeContext.atExtreme,
      hasVolumeSpike: hasVolumeSpike,
      isWyckoffPattern: isWyckoff
    });

    // Aplicar adjustment
    if (patternTrust.action !== 'NONE') {
      confidenceScore += patternTrust.adjustment;
      const emoji = patternTrust.action === 'BOOST' ? 'üèÜ' : patternTrust.action === 'BLOCK' ? 'üö´' : patternTrust.action === 'PROCEED' ? '‚úÖ' : '‚è≥';
      confluences.push(`${emoji} Pattern Trust: ${patternName} ‚Üí ${patternTrust.adjustment > 0 ? '+' : ''}${patternTrust.adjustment} pts (WR: ${(patternTrust.winRate * 100).toFixed(1)}%, ctx: ${patternTrust.contextCount || 0})`);

      // Se BLOCK ou WAIT_CONTEXT sem contexto, penalizar fortemente
      if (patternTrust.shouldBlock || patternTrust.action === 'WAIT_CONTEXT') {
        signalType = 'NEUTRAL';
        confidenceScore = Math.min(confidenceScore, 20);
        console.log(`üö´ [PATTERN TRUST] Padr√£o bloqueado/aguardando contexto: ${patternName}`);
      }
    }
  } catch (patternTrustError) {
    console.warn('‚ö†Ô∏è Erro ao aplicar Pattern Trust:', patternTrustError);
    // Fallback para vers√£o sync
    const fallbackTrust = getPatternTrust(pattern);
    if (fallbackTrust.action !== 'NONE') {
      confidenceScore += fallbackTrust.adjustment;
      confluences.push(`‚ö†Ô∏è Pattern Trust (fallback): ${pattern} ‚Üí ${fallbackTrust.adjustment > 0 ? '+' : ''}${fallbackTrust.adjustment} pts`);
    }
  }


  // üéØ BLOCO 0.5: APLICAR PATTERN MEMORY
  let patternWinRate = null; // ‚úÖ CORRE√á√ÉO #10: Armazenar win rate para aplicar cap
  let patternMemoryHardBlock = false; // ‚úÖ NOVO: Flag para hard block
  if (patternMemory && patternMemory.length > 0) {
    console.log('üéØ Aplicando Pattern Memory...');
    const bestPattern = patternMemory[0]; // Melhor padr√£o por win_rate
    patternWinRate = bestPattern.win_rate; // ‚úÖ Armazenar para aplicar cap depois
    const totalOccurrences = bestPattern.total_occurrences ?? bestPattern.total_trades ?? 0;

    // ============================================================================
    // üî• HARD BLOCK: Pattern Memory com win rate MUITO ruim (< 25%) E muitas tentativas (50+)
    // üéØ CALIBRA√á√ÉO: Relaxado de 35%+30 para 25%+50 para permitir padr√µes renascerem
    // Tamb√©m verifica se h√° momentum para dar chance ao padr√£o
    // ============================================================================
    const hasFreshMomentum = technicalIndicators?.rsi_14 < 30 || technicalIndicators?.rsi_14 > 70;
    const shouldHardBlock = bestPattern.win_rate < 0.25 && totalOccurrences >= 50 && !hasFreshMomentum;

    if (shouldHardBlock) {
      confidenceScore = 0;
      signalType = 'NEUTRAL';
      patternMemoryHardBlock = true;
      confluences.push(`üö´ PATTERN MEMORY HARD BLOCK: ${(bestPattern.win_rate * 100).toFixed(1)}% win rate com ${totalOccurrences} trades - VETO ABSOLUTO`);
      console.log(`üö´ [PATTERN MEMORY] HARD BLOCK - Score: 0, Signal: NEUTRAL`, {
        winRate: (bestPattern.win_rate * 100).toFixed(1) + '%',
        occurrences: totalOccurrences,
        patternName: bestPattern.pattern_name,
        hasFreshMomentum
      });
    } else if (bestPattern.win_rate > 0.6) {
      confidenceScore += 18; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 15 para 18 (+20%)
      confluences.push(`üéØ Pattern Memory: ${(bestPattern.win_rate * 100).toFixed(1)}% win rate com ${totalOccurrences} trades - BOOST`);
    } else if (bestPattern.win_rate > 0.5) {
      confidenceScore += 5;
      confluences.push(`üìä Pattern Memory: ${(bestPattern.win_rate * 100).toFixed(1)}% win rate moderado`);
    } else if (bestPattern.win_rate < 0.3) {
      // Penalidade proporcional e limitada
      const scoreBeforePatternMemory = confidenceScore;
      const basePenalty = 20;
      const occurrenceFactor = Math.min(1.0, totalOccurrences / 100);
      let adjustedPenalty = Math.round(basePenalty * (1 - occurrenceFactor * 0.4));
      const maxPenalty = Math.max(10, scoreBeforePatternMemory * 0.3);
      adjustedPenalty = Math.min(adjustedPenalty, maxPenalty);
      confidenceScore -= adjustedPenalty;
      confluences.push(`‚ö†Ô∏è Pattern Memory: ${(bestPattern.win_rate * 100).toFixed(1)}% win rate baixo (${totalOccurrences} tentativas) - PENALIDADE ${adjustedPenalty} (limitada a ${maxPenalty.toFixed(0)} pts)`);
    }
  }
  if (historicalContext) {
    console.log('üìö Aplicando contexto hist√≥rico...');
    // ‚úÖ NOVO: Armazenar score antes das penalidades hist√≥ricas para limitar impacto total
    const scoreBeforeHistorical = confidenceScore;
    let totalHistoricalPenalty = 0;

    // 1. Evitar sinais repetitivos (PENALIDADE MASSIVA)
    if (historicalContext?.isOverSignaled) {
      console.log('üö® SPAM DETECTADO - REJEITANDO SINAL');
      confidenceScore = 0; // ZERAR score para spam
      confluences.push(`üö® SPAM DETECTADO: ${historicalContext?.recentSignals?.length || 0} sinais nos √∫ltimos 10min - SINAL REJEITADO`);
      // RETORNAR IMEDIATAMENTE para evitar spam
      return {
        confidenceScore: 0,
        signalType: 'NEUTRAL',
        confluences,
        knowledgeUsed: [],
        summary: 'Sinal rejeitado por spam excessivo',
        narration: {
          full: 'üö® SPAM DETECTADO: Muitos sinais similares nos √∫ltimos 10 minutos. Aguardando intervalo adequado.',
          summary: 'Sinal rejeitado por spam'
        },
        riskNote: 'Sistema anti-spam ativado',
        marketContext: 'Aguardando intervalo entre sinais',
        technicalScore: 0,
        volumeAnalysis: 'Sinal rejeitado',
        patternDescription: 'Spam detectado'
      };
    }
    // ‚úÖ PATCH 4: SUAVIZAR CONTEXTO HIST√ìRICO - Reduzir penalidades e limitar impacto total
    // 2. Aplicar taxa de sucesso hist√≥rica (PENALIDADE SUAVIZADA E LIMITADA)
    if (historicalContext.successRate > 0.7) {
      confidenceScore += 18; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 15 para 18 (+20%)
      confluences.push(`üìà Taxa de sucesso hist√≥rica: ${(historicalContext.successRate * 100).toFixed(1)}%`);
    } else if (historicalContext.successRate < 0.3) {
      const penalty = 12; // ‚úÖ CALIBRA√á√ÉO: Reduzido de 15 para 12 (-20%)
      totalHistoricalPenalty += penalty;
      confidenceScore -= penalty;
      confluences.push(`üìâ Taxa de sucesso baixa: ${(historicalContext.successRate * 100).toFixed(1)}% - PENALIDADE APLICADA`);
    } else if (historicalContext.successRate < 0.5) {
      const penalty = 8; // ‚úÖ CALIBRA√á√ÉO: Reduzido de 10 para 8 (-20%)
      totalHistoricalPenalty += penalty;
      confidenceScore -= penalty;
      confluences.push(`‚ö†Ô∏è Taxa de sucesso m√©dia-baixa: ${(historicalContext.successRate * 100).toFixed(1)}% - cautela`);
    }
    // 3. Usar conhecimento espec√≠fico do padr√£o
    if (historicalContext?.knowledgeMatches?.length > 0) {
      confidenceScore += 10;
      confluences.push(`üéì Conhecimento espec√≠fico: ${historicalContext.knowledgeMatches.length} entradas encontradas`);
      knowledgeUsed.push(...historicalContext.knowledgeMatches.map((k) => k.id));
    }
    // 4. Ajustar baseado na frequ√™ncia do padr√£o
    if (historicalContext.patternFrequency > 10) {
      confidenceScore += 5;
      confluences.push(`üîÑ Padr√£o recorrente: ${historicalContext.patternFrequency} ocorr√™ncias nos √∫ltimos 30 dias`);
    }
    // 5. Aplicar confian√ßa m√©dia hist√≥rica (SUAVIZADA E LIMITADA)
    if (historicalContext.avgConfidence > 70) {
      confidenceScore += 10; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 8 para 10 (+25%)
      confluences.push(`üìä Confian√ßa hist√≥rica alta: ${historicalContext.avgConfidence.toFixed(1)}%`);
    } else if (historicalContext.avgConfidence < 40) {
      const penalty = 8; // ‚úÖ CALIBRA√á√ÉO: Reduzido de 10 para 8 (-20%)
      totalHistoricalPenalty += penalty;
      confidenceScore -= penalty;
      confluences.push(`üìä Confian√ßa hist√≥rica baixa: ${historicalContext.avgConfidence.toFixed(1)}% - PENALIDADE`);
    }
    // 6. AN√ÅLISE INTELIGENTE DE FEEDBACK (COM VALIDA√á√ÉO E LIMITA√á√ÉO)
    if (historicalContext?.recentFeedback?.length > 0) {
      const avgRating = historicalContext.recentFeedback.reduce((sum, f) => sum + f.rating, 0) / historicalContext.recentFeedback.length;
      const feedbackCount = historicalContext.recentFeedback.length;

      // ‚úÖ NOVO: Validar se feedback 0.0 √© v√°lido (pode ser erro de dados)
      const isValidFeedback = avgRating > 0 || feedbackCount < 5; // Se 0.0 mas poucos feedbacks, pode ser erro

      if (avgRating >= 4.5) {
        confidenceScore += 12; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 10 para 12 (+20%)
        confluences.push(`üåü Feedback excelente: ${avgRating.toFixed(1)}/5 estrelas (${feedbackCount} avalia√ß√µes) - BOOST`);
      } else if (avgRating >= 4.0) {
        confidenceScore += 5; // Boost moderado para feedback bom
        confluences.push(`üëç Feedback bom: ${avgRating.toFixed(1)}/5 estrelas (${feedbackCount} avalia√ß√µes) - BOOST MODERADO`);
      } else if (avgRating >= 3.5) {
        // Neutro, sem penalidade
        confluences.push(`üòê Feedback neutro: ${avgRating.toFixed(1)}/5 estrelas (${feedbackCount} avalia√ß√µes)`);
      } else if (avgRating >= 3.0) {
        const penalty = 5; // Penalidade leve para feedback abaixo da m√©dia
        totalHistoricalPenalty += penalty;
        confidenceScore -= penalty;
        confluences.push(`‚ö†Ô∏è Feedback abaixo da m√©dia: ${avgRating.toFixed(1)}/5 estrelas (${feedbackCount} avalia√ß√µes) - PENALIDADE LEVE`);
      } else if (avgRating >= 2.5) {
        const penalty = 8; // ‚úÖ CALIBRA√á√ÉO: Reduzido de 10 para 8 (-20%)
        totalHistoricalPenalty += penalty;
        confidenceScore -= penalty;
        confluences.push(`üëé Feedback ruim: ${avgRating.toFixed(1)}/5 estrelas (${feedbackCount} avalia√ß√µes) - PENALIDADE MODERADA`);
      } else if (isValidFeedback) {
        // ‚úÖ NOVO: Aplicar penalidade reduzida se feedback parece inv√°lido (0.0 com muitos feedbacks)
        const penalty = avgRating === 0 && feedbackCount >= 10 ? 8 : 12; // Reduzir se parece erro de dados
        totalHistoricalPenalty += penalty;
        confidenceScore -= penalty;
        confluences.push(`üö® Feedback muito ruim: ${avgRating.toFixed(1)}/5 estrelas (${feedbackCount} avalia√ß√µes) - PENALIDADE ${avgRating === 0 && feedbackCount >= 10 ? 'REDUZIDA (poss√≠vel erro)' : 'FORTE'}`);
      }
    }

    // ‚úÖ NOVO: LIMITAR IMPACTO TOTAL DAS PENALIDADES HIST√ìRICAS
    // N√£o permitir que penalidades hist√≥ricas reduzam mais de 40% do score t√©cnico inicial
    const maxHistoricalPenalty = Math.max(15, scoreBeforeHistorical * 0.4); // M√°ximo 40% do score inicial ou 15 pontos
    if (totalHistoricalPenalty > maxHistoricalPenalty) {
      const excessPenalty = totalHistoricalPenalty - maxHistoricalPenalty;
      confidenceScore += excessPenalty; // Reverter penalidade excessiva
      console.log(`‚ö†Ô∏è Penalidades hist√≥ricas limitadas: ${totalHistoricalPenalty.toFixed(1)} ‚Üí ${maxHistoricalPenalty.toFixed(1)} (m√°x 40% do score t√©cnico)`);
    }

    // ‚úÖ CALIBRA√á√ÉO: Cap m√≠nimo aumentado de 5 para 15 (+10 pontos)
    confidenceScore = Math.max(confidenceScore, 15); // Cap m√≠nimo de 15
    console.log('üìö Contexto hist√≥rico aplicado. Score ajustado:', confidenceScore, `(penalidade total: ${totalHistoricalPenalty.toFixed(1)}, limitada a ${maxHistoricalPenalty.toFixed(1)})`);
  }
  // ‚úÖ PATCH 2: USAR suggestedSignal do RSI
  // 1. AN√ÅLISE RSI (com verifica√ß√£o de dados e PESOS DIN√ÇMICOS)
  let rsiSuggestedSignal = 'NEUTRAL'; // ‚úÖ Armazenar suggestedSignal do RSI
  if (Number.isFinite(technicalIndicators?.rsi_14)) {
    const rsiAnalysis = analyzeRSI(technicalIndicators.rsi_14, signalType);
    rsiSuggestedSignal = rsiAnalysis.suggestedSignal || 'NEUTRAL'; // ‚úÖ Capturar suggestedSignal
    // üß† APLICAR PESO DIN√ÇMICO
    let rsiScore = rsiAnalysis.score;
    let rsiSignalName = '';
    if (technicalIndicators.rsi_14 < 30) {
      rsiSignalName = 'rsi_oversold';
      detectedSignals.push('rsi_oversold');
    } else if (technicalIndicators.rsi_14 > 70) {
      rsiSignalName = 'rsi_overbought';
      detectedSignals.push('rsi_overbought');
    }
    if (rsiSignalName && dynamicWeights[rsiSignalName]) {
      const weight = dynamicWeights[rsiSignalName].current_weight;
      rsiScore = rsiScore * weight; // Aplicar peso din√¢mico
      console.log(`üîß [RL] RSI ${rsiSignalName}: peso=${weight.toFixed(2)} ‚Üí score=${rsiScore.toFixed(1)}`);
    }
    confidenceScore += rsiScore;
    confluences.push(...rsiAnalysis.confluences);
  } else {
    console.warn('‚ö†Ô∏è RSI n√£o dispon√≠vel ou inv√°lido:', technicalIndicators?.rsi_14);
    // ‚úÖ CORRE√á√ÉO: Penalizar fortemente se RSI n√£o dispon√≠vel (n√£o usar fallback)
    log('warn', 'RSI n√£o dispon√≠vel, aplicando penalidade forte no score', {
      receivedRSI: technicalIndicators?.rsi_14
    });
    // Aplicar penalidade forte no score em vez de usar fallback
    // Isso ser√° tratado na an√°lise RSI (n√£o adiciona score positivo)
  }
  // 2. AN√ÅLISE DE TEND√äNCIA (EMAs) - com verifica√ß√£o
  if (Number.isFinite(technicalIndicators?.ema_9) && Number.isFinite(technicalIndicators?.ema_50)) {
    const trendAnalysis = analyzeTrend(technicalIndicators, signalType);
    confidenceScore += trendAnalysis.score;
    confluences.push(...trendAnalysis.confluences);
  } else {
    console.warn('‚ö†Ô∏è EMAs n√£o dispon√≠veis:', {
      ema_9: technicalIndicators?.ema_9,
      ema_50: technicalIndicators?.ema_50
    });
  }
  // 3. AN√ÅLISE DE VOLUME
  const volumeAnalysis = analyzeVolume(technicalIndicators, marketData);
  confidenceScore += volumeAnalysis.score;
  confluences.push(...volumeAnalysis.confluences);
  // 3.4. AN√ÅLISE DE ORDER BOOK (OTIMIZADA - usar a que vem de additionalData ou buscar se necess√°rio)
  // ‚úÖ CORRE√á√ÉO: Usar orderBookAnalysis de additionalData (j√° calculado antes de analyzePatternIntelligently)
  let orderBookAnalysisVar = additionalData?.orderBookAnalysis || null;
  const shouldAnalyzeOrderBook = !orderBookAnalysisVar && (confidenceScore > 50 ||
    (pattern?.type && pattern.type !== 'Estrutura t√©cnica' && pattern.type !== 'Auto-detect'));
  if (shouldAnalyzeOrderBook && marketData?.symbol && marketData?.price) {
    try {
      const symbolNoSlash = marketData.symbol.replace('/', '').replace('USDT', '') + 'USDT';
      const candles = additionalData?.candles || [];
      // üîß CORRE√á√ÉO: Usar currentPrice validado ao inv√©s de ler marketData.price
      const priceForOrderBook = additionalData?.currentPrice || currentPrice || parseFloat(String(marketData.price));
      orderBookAnalysisVar = await analyzeOrderBook(symbolNoSlash, priceForOrderBook, candles);

      if (orderBookAnalysisVar) {
        // Aplicar an√°lise de order book ao score
        const { imbalance, largeOrders, liquidationZones, orderFlow, signal } = orderBookAnalysisVar;

        // Order Book Imbalance boost/penalty
        if (imbalance > 0.3) {
          // Press√£o compradora forte
          if (signalType === 'BUY') {
            confidenceScore += 10; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 8 para 10 (+25%)
            confluences.push(`üìä Order Book: Desequil√≠brio comprador (${(imbalance * 100).toFixed(1)}%) - BOOST`);
          } else {
            confidenceScore -= 5;
            confluences.push(`‚ö†Ô∏è Order Book: Caracter√≠sticas t√©cnicas de press√£o compradora vs an√°lise SELL - CONTRADI√á√ÉO`);
          }
        } else if (imbalance < -0.3) {
          // Press√£o vendedora forte
          if (signalType === 'SELL') {
            confidenceScore += 10; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 8 para 10 (+25%)
            confluences.push(`üìä Order Book: Desequil√≠brio vendedor (${(Math.abs(imbalance) * 100).toFixed(1)}%) - BOOST`);
          } else {
            confidenceScore -= 5;
            confluences.push(`‚ö†Ô∏è Order Book: Caracter√≠sticas t√©cnicas de press√£o vendedora vs an√°lise BUY - CONTRADI√á√ÉO`);
          }
        }

        // Grandes ordens detectadas
        if (largeOrders.totalVolume > 0) {
          const largeBidsCount = largeOrders.bids.length;
          const largeAsksCount = largeOrders.asks.length;
          if (largeBidsCount > largeAsksCount && signalType === 'BUY') {
            confidenceScore += 6; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 5 para 6 (+20%)
            confluences.push(`üè¶ Order Book: ${largeBidsCount} grandes ordens no lado comprador detectadas`);
          } else if (largeAsksCount > largeBidsCount && signalType === 'SELL') {
            confidenceScore += 6; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 5 para 6 (+20%)
            confluences.push(`üè¶ Order Book: ${largeAsksCount} grandes ordens no lado vendedor detectadas`);
          }
        }

        // Zonas de liquida√ß√£o pr√≥ximas
        if (liquidationZones.length > 0) {
          const nearestZone = liquidationZones[0];
          // üîß CORRE√á√ÉO: Usar currentPrice validado
          const priceForDistance = additionalData?.currentPrice || currentPrice || parseFloat(String(marketData.price));
          const distancePct = Math.abs(nearestZone.price - priceForDistance) / priceForDistance * 100;
          if (distancePct < 1) { // Zona muito pr√≥xima (< 1%)
            confluences.push(`üéØ Order Book: Zona de liquida√ß√£o pr√≥xima em $${nearestZone.price.toFixed(2)} (${distancePct.toFixed(2)}% de dist√¢ncia)`);
            // Boost se sinal alinhado com zona
            if ((nearestZone.type === 'recent_high' && signalType === 'SELL') ||
              (nearestZone.type === 'recent_low' && signalType === 'BUY')) {
              confidenceScore += 3;
            }
          }
        }

        // Order Flow Analysis
        if (orderFlow.buyPressure > 0.5) {
          confluences.push(`üíπ Order Flow: Caracter√≠sticas t√©cnicas de press√£o compradora alta (${(orderFlow.buyPressure * 100).toFixed(1)}%)`);
        } else if (orderFlow.sellPressure > 0.5) {
          confluences.push(`üíπ Order Flow: Caracter√≠sticas t√©cnicas de press√£o vendedora alta (${(orderFlow.sellPressure * 100).toFixed(1)}%)`);
        }
      }
    } catch (obError) {
      log('warn', 'Erro ao analisar order book (continuando)', { error: obError.message });
      // N√£o quebra an√°lise se order book falhar
    }
  }
  // 3.5. MACHINE LEARNING ANALYSIS (NOVO)
  const mlAnalysis = analyzeMLPatterns(technicalIndicators, marketData);
  confidenceScore += mlAnalysis.score;
  confluences.push(...mlAnalysis.confluences);
  // 3.6. AN√ÅLISE CONTEXTUAL INTELIGENTE (IA M√ÅXIMA)
  const contextualAnalysis = generateContextualIntelligence(technicalIndicators, marketData, confluences);
  confidenceScore += contextualAnalysis.score;
  confluences.push(...contextualAnalysis.confluences);
  // 3.7. DETEC√á√ÉO DE REGIME DE MERCADO (NOVO - ALTA INTELIG√äNCIA)
  // ‚úÖ CORRE√á√ÉO: Usar marketRegime de additionalData se j√° foi calculado, sen√£o calcular
  let marketRegime = additionalData?.marketRegime || null;
  if (!marketRegime && additionalData?.candles && additionalData.candles.length >= 20) {
    try {
      marketRegime = detectMarketRegime(additionalData.candles, technicalIndicators);
    } catch (regimeError) {
      log('warn', 'Erro ao detectar regime de mercado', { error: regimeError.message });
    }
  }

  // Aplicar ajuste de score do regime (se houver)
  if (marketRegime) {
    confidenceScore += marketRegime.scoreAdjustment;
    confluences.push(`üìä Regime de Mercado: ${marketRegime.regime} (${(marketRegime.confidence * 100).toFixed(0)}% confian√ßa)`);
    if (marketRegime.recommendation) {
      confluences.push(`üí° ${marketRegime.recommendation}`);
    }
  }
  // 3.8. AN√ÅLISE DE CORRELA√á√ÉO COM BTC (NOVO - ALTA INTELIG√äNCIA)
  let correlationAnalysis = null;
  if (marketData?.symbol && !marketData.symbol.includes('BTC')) {
    try {
      const symbolNoSlash = marketData.symbol.replace('/', '').replace('USDT', '') + 'USDT';
      correlationAnalysis = await analyzeAssetCorrelation(symbolNoSlash, marketData.timeframe || '1m', additionalData?.candles || []);
      if (correlationAnalysis) {
        confidenceScore += correlationAnalysis.scoreBoost;
        confluences.push(`üîó Correla√ß√£o BTC: ${(correlationAnalysis.correlation * 100).toFixed(0)}% ${correlationAnalysis.btcLeads ? '(BTC lidera)' : '(Alinhado)'}`);
        if (correlationAnalysis.signal === 'ALIGNED') {
          confluences.push(`‚úÖ Movimento alinhado com BTC - Confirma√ß√£o forte`);
        } else if (correlationAnalysis.signal === 'DIVERGENT') {
          confluences.push(`‚ö†Ô∏è Diverg√™ncia com BTC - Cautela`);
        }
      }
    } catch (corrError) {
      log('warn', 'Erro ao analisar correla√ß√£o', { error: corrError.message });
    }
  }
  // 3.9. DETEC√á√ÉO DE CICLOS DE MERCADO (NOVO - ALTA INTELIG√äNCIA)
  let marketCycle = null;
  if (additionalData?.candles && additionalData.candles.length >= 30 && orderBookAnalysisVar) {
    try {
      const volumeData = additionalData.candles.map(c => c.volume);
      marketCycle = detectMarketCycle(additionalData.candles, volumeData, orderBookAnalysisVar);
      if (marketCycle) {
        confidenceScore += marketCycle.scoreBoost;
        confluences.push(`üîÑ Ciclo de Mercado: ${marketCycle.phase} (${(marketCycle.confidence * 100).toFixed(0)}% confian√ßa)`);
        if (marketCycle.entrySignal !== 'WAIT') {
          // ‚úÖ CVM: Usar linguagem descritiva ao inv√©s de prescritiva
          confluences.push(`üìä An√°lise t√©cnica: Caracter√≠sticas t√©cnicas de ${marketCycle.entrySignal} observadas na fase ${marketCycle.phase} do ciclo. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`);
        } else {
          confluences.push(`‚è≥ Ciclo de Mercado: Fase atual n√£o apresenta caracter√≠sticas t√©cnicas ideais para entrada`);
        }
      }
    } catch (cycleError) {
      log('warn', 'Erro ao detectar ciclo de mercado', { error: cycleError.message });
    }
  }
  // 4. AN√ÅLISE DE PADR√ÉO ESPEC√çFICO (com ajuste de regime)
  const patternAnalysis = analyzePattern(pattern, marketData, technicalIndicators, marketRegime);
  confidenceScore += patternAnalysis.score;
  confluences.push(...patternAnalysis.confluences);
  // ‚úÖ PATCH 5: LIMITAR SCORE MTF DIVERGENTE
  // 5. CONFIRMA√á√ÉO MULTI-TIMEFRAME
  if (multiTimeframeContext.confirmation === 'aligned') {
    confidenceScore += 18; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 15 para 18 (+20%)
    confluences.push('‚úÖ Confirma√ß√£o multi-timeframe ALINHADA');
  } else if (multiTimeframeContext.confirmation === 'divergent') {
    confidenceScore -= 20;
    confidenceScore = Math.min(confidenceScore, 20); // ‚úÖ Cap em 20 quando divergente
    // Adicionar detalhes da diverg√™ncia se dispon√≠vel
    const divergenceMsg = multiTimeframeContext.rejectionReason
      ? `‚ùå Diverg√™ncia multi-timeframe: ${multiTimeframeContext.rejectionReason}`
      : '‚ùå Diverg√™ncia multi-timeframe detectada';
    confluences.push(divergenceMsg);
    // ‚úÖ For√ßar NEUTRAL se score muito baixo ap√≥s diverg√™ncia
    if (confidenceScore < 30) {
      signalType = 'NEUTRAL';
    }
  } else if (multiTimeframeContext.confirmation === 'partial') {
    confidenceScore += 5;
    confluences.push('‚ö†Ô∏è Confirma√ß√£o multi-timeframe PARCIAL');
  } else {
    confluences.push('‚ÑπÔ∏è Contexto multi-timeframe NEUTRO');
  }
  // üß† 5. UNIFIED BRAIN - An√°lise Unificada e Resolu√ß√£o de Conflitos
  let unifiedState = null;
  let mtfUnified = null;
  let mtfApplied = false; // ‚úÖ FIX: Vari√°vel necess√°ria para logs
  let mtfResult = null; // ‚úÖ FIX: Vari√°vel necess√°ria para logs
  try {
    // 5.1. Obter MTF Unificado (substitui analyzeMTFContextual + calculateTrendState)
    const temporalAwareness = additionalData?.temporalAwareness || {};
    mtfUnified = await analyzeMTFUnified(multiTimeframeContext, pattern, {
      confidenceScore,
      signalType
    }, temporalAwareness);
    mtfApplied = true; // ‚úÖ FIX: Marcar como aplicado
    mtfResult = mtfUnified; // ‚úÖ FIX: Atribuir resultado para logs

    // 5.2. Preparar dados para Unified Brain
    const volumeAnalysis = analyzeVolume(technicalIndicators, marketData);
    const volatilityAnalysis = {
      atr: technicalIndicators?.atr || 0,
      compressed: technicalIndicators?.atr < 0.005
    };

    // 5.3. Processar com Unified Brain
    const unifiedBrain = new UnifiedBrain();
    unifiedState = await unifiedBrain.process({
      indicators: technicalIndicators,
      mtf: mtfUnified,
      patterns: {
        direction: pattern?.direction || (pattern?.isBullishPattern ? 'bullish' : pattern?.isBearishPattern ? 'bearish' : 'neutral'),
        confidence: pattern?.confidence || 50,
        isBullishPattern: pattern?.isBullishPattern || false,
        isBearishPattern: pattern?.isBearishPattern || false
      },
      ml: {
        direction: patternMemory?.[0]?.direction || 'neutral',
        confidence: patternMemory?.[0]?.win_rate ? patternMemory[0].win_rate * 100 : 50
      },
      volume: volumeAnalysis,
      volatility: volatilityAnalysis,
      patternMemory: patternMemory?.[0] || null
    });

    // 5.4. Aplicar resultado do Unified Brain
    // ‚úÖ AJUSTE: Aceitar neutral + bullish/bearish local (n√£o apenas aligned)
    // Ajustar score baseado no bias unificado
    if (unifiedState.bias === 'bullish' && signalType === 'BUY') {
      confidenceScore += 15;
    } else if (unifiedState.bias === 'bearish' && signalType === 'SELL') {
      confidenceScore += 15;
    } else if (unifiedState.bias === 'neutral' && signalType !== 'NEUTRAL') {
      // ‚úÖ NOVO: Aceitar neutral + bullish/bearish local (n√£o bloquear)
      // Apenas n√£o dar bonus, mas n√£o penalizar
      confidenceScore += 0;
    } else if (unifiedState.bias !== 'neutral' &&
      ((unifiedState.bias === 'bullish' && signalType === 'SELL') ||
        (unifiedState.bias === 'bearish' && signalType === 'BUY'))) {
      // ‚úÖ AJUSTE: MTF divergent apenas penaliza -10 pontos (n√£o bloqueia)
      if (mtfUnified?.alignment === 'divergent') {
        confidenceScore -= 10; // Divergent = penalidade moderada
      } else {
        confidenceScore -= 5; // Counter-trend mas n√£o divergent = penalidade menor
      }
    }

    // Aplicar penalidade por conflitos
    if (unifiedState.conflicts.length > 0) {
      confidenceScore -= unifiedState.conflicts.length * 5;
      unifiedState.conflicts.forEach(conflict => {
        confluences.push(`‚ö†Ô∏è Conflito resolvido: ${conflict.conflict} ‚Üí ${conflict.resolution}`);
      });
    }

    // Adicionar conflu√™ncias do Unified Brain
    confluences.push(...unifiedState.confluences);

    // Aplicar ajuste do MTF (se houver)
    if (mtfUnified.scoreAdjustment) {
      confidenceScore += mtfUnified.scoreAdjustment;
      if (mtfUnified.recommendation === 'PROCEED') {
        confluences.push(`üéØ MTF: ${mtfUnified.reasoning}`);
      } else if (mtfUnified.recommendation === 'WAIT') {
        confluences.push(`‚è≥ MTF: ${mtfUnified.reasoning}`);
      } else if (mtfUnified.recommendation === 'AVOID') {
        confluences.push(`‚ö†Ô∏è MTF: ${mtfUnified.reasoning}`);
      }
    }

    // ‚úÖ FRACTAL: Adicionar padr√µes fractais detectados nas conflu√™ncias (TODOS os timeframes)
    if (mtfUnified.fractalPatterns && Object.keys(mtfUnified.fractalPatterns).length > 0) {
      const fractalSummary: string[] = [];
      // Ordem hier√°rquica: D1 ‚Üí H1 ‚Üí M30 ‚Üí M15 ‚Üí M5 ‚Üí M1
      if (mtfUnified.fractalPatterns.d1) {
        fractalSummary.push(`D1: ${mtfUnified.fractalPatterns.d1}`);
      }
      if (mtfUnified.fractalPatterns.h1) {
        fractalSummary.push(`H1: ${mtfUnified.fractalPatterns.h1}`);
      }
      if (mtfUnified.fractalPatterns.m30) {
        fractalSummary.push(`M30: ${mtfUnified.fractalPatterns.m30}`);
      }
      if (mtfUnified.fractalPatterns.m15) {
        fractalSummary.push(`M15: ${mtfUnified.fractalPatterns.m15}`);
      }
      if (mtfUnified.fractalPatterns.m5) {
        fractalSummary.push(`M5: ${mtfUnified.fractalPatterns.m5}`);
      }
      if (mtfUnified.fractalPatterns.m1) {
        fractalSummary.push(`M1: ${mtfUnified.fractalPatterns.m1}`);
      }
      if (fractalSummary.length > 0) {
        confluences.push(`üîç Estrutura Fractal: ${fractalSummary.join(' | ')}`);
      }
    }

    // Detectar fases Wyckoff do MTF
    if (mtfUnified.phases?.accumulation) {
      confluences.push('üìä Fase Wyckoff: Acumula√ß√£o detectada');
    } else if (mtfUnified.phases?.markup) {
      confluences.push('üìà Fase Wyckoff: Markup ativo');
    } else if (mtfUnified.phases?.distribution) {
      confluences.push('üìâ Fase Wyckoff: Distribui√ß√£o detectada');
    } else if (mtfUnified.phases?.markdown) {
      confluences.push('üìâ Fase Wyckoff: Markdown ativo');
    }

    // Log do Unified Brain
    logIntelligence('info', 'Unified Brain processado', {
      bias: unifiedState.bias,
      confidenceScore: unifiedState.confidenceScore,
      conflicts: unifiedState.conflicts.length,
      signalType: unifiedState.signalType,
      reasoning: unifiedState.reasoning
    });

  } catch (unifiedError) {
    console.warn('‚ö†Ô∏è Erro no Unified Brain (continuando com fallback):', unifiedError);
    logIntelligence('warn', 'Unified Brain falhou, usando an√°lise fragmentada', {
      error: unifiedError?.message || String(unifiedError)
    });
    // Fallback: usar an√°lise MTF b√°sica
    try {
      const mtfAnalysis = await analyzeMTFContextual(multiTimeframeContext, pattern, {
        confidenceScore,
        signalType
      });
      if (mtfAnalysis.recommendation === 'PROCEED' && mtfAnalysis.alignment === 'aligned') {
        confidenceScore += mtfAnalysis.scoreAdjustment;
        confluences.push(`üéØ MTF Alinhado: ${mtfAnalysis.reasoning}`);
      }
    } catch (fallbackError) {
      // Ignorar erro de fallback
    }
  }
  // üÜï 5.3. FILTRO ESPECIAL PARA ALTA LEVERAGE (75x+) - PRECIS√ÉO M√ÅXIMA
  const leverage = additionalData?.leverage || 75;
  const isHighLeverage = leverage >= 75;
  if (isHighLeverage) {
    // Para 75x+, aplicar filtros rigorosos adicionais
    const highLeverageFilters = analyzeHighLeverageFilters(technicalIndicators, marketData, pattern, multiTimeframeContext, orderBookAnalysisVar, additionalData?.candles || []);

    if (highLeverageFilters.shouldReject) {
      confidenceScore -= highLeverageFilters.penalty;
      confluences.push(...highLeverageFilters.warnings);
      confluences.push(`üö® ALTA LEVERAGE (${leverage}x): ${highLeverageFilters.rejectionReason}`);
    } else {
      confidenceScore += highLeverageFilters.boost;
      confluences.push(...highLeverageFilters.confirmations);
      confluences.push(`‚úÖ ALTA LEVERAGE (${leverage}x): Filtros rigorosos passados`);
    }
  }

  // üÜï 5.3. META-PADR√ïES ENGINE - Combina√ß√µes Inteligentes
  try {
    // Coletar padr√µes ativos: padr√£o atual + padr√µes mencionados nas conflu√™ncias
    const activePatterns = [];
    // Adicionar padr√£o atual (normalizado)
    if (pattern.type) {
      const normalizedType = pattern.type.toLowerCase().replace(/[_-]/g, '');
      activePatterns.push(normalizedType);
    }
    // Extrair padr√µes das conflu√™ncias (buscar por nomes conhecidos)
    const knownPatterns = [
      'orderblock',
      'order_block',
      'fvg',
      'fairvaluegap',
      'spring',
      'upthrust',
      'bos',
      'breakofstructure',
      'choch',
      'changeofcharacter',
      'liquiditysweep',
      'triangle',
      'triangulo',
      'flag',
      'bandeira',
      'wedge',
      'cunha',
      'elliott',
      'elliottwave',
      'engulfing',
      'doji',
      'hammer',
      'shootingstar',
      'pinbar',
      'insidebar',
      'support',
      'resistance',
      'suporte',
      'resistencia'
    ];
    confluences.forEach((conf) => {
      const confLower = conf.toLowerCase();
      knownPatterns.forEach((kp) => {
        if (confLower.includes(kp) && !activePatterns.includes(kp)) {
          activePatterns.push(kp);
        }
      });
    });
    const metaPatterns = detectMetaPatterns(activePatterns, pattern, technicalIndicators, multiTimeframeContext);
    if (metaPatterns.length > 0) {
      // Aplicar score do meta-padr√£o com maior score
      const bestMetaPattern = metaPatterns.reduce((best, current) => current.score > best.score ? current : best);
      confidenceScore += bestMetaPattern.score;
      confluences.push(`üéØ Meta-Padr√£o: ${bestMetaPattern.metaPattern.name} (${bestMetaPattern.metaPattern.description}) - +${bestMetaPattern.score} pontos`);
      confluences.push(`üìä Win Rate estimado: ${(bestMetaPattern.metaPattern.winRate * 100).toFixed(1)}%`);
    }
  } catch (metaError) {
    console.warn('‚ö†Ô∏è Erro no Meta-Padr√µes Engine (continuando):', metaError);
    // N√£o quebra o fluxo - continua normalmente
  }
  // 6. APLICAR CONHECIMENTO T√âCNICO
  const knowledgeAnalysis = applyTechnicalKnowledge(knowledge, pattern, marketData);
  confidenceScore += knowledgeAnalysis.score;
  confluences.push(...knowledgeAnalysis.confluences);
  knowledgeUsed.push(...knowledgeAnalysis.used);
  // 7. AN√ÅLISE DE CONTEXTO DE MERCADO
  const marketContext = analyzeMarketContext(marketData, multiTimeframeContext);
  confidenceScore += marketContext.score;
  confluences.push(...marketContext.confluences);
  // 8. DETERMINAR TIPO DE SINAL (CORRIGIDO - CONSIDERA DIRE√á√ÉO DO MERCADO)
  // Contar sinais bullish vs bearish nas conflu√™ncias
  const bullishSignals = confluences.filter((c) => c.toLowerCase().includes('alta') || c.toLowerCase().includes('compra') || c.toLowerCase().includes('sobrevenda') || c.toLowerCase().includes('bullish')).length;
  const bearishSignals = confluences.filter((c) => c.toLowerCase().includes('baixa') || c.toLowerCase().includes('venda') || c.toLowerCase().includes('sobrecompra') || c.toLowerCase().includes('bearish')).length;
  // Se h√° RSI extremo, usar isso como prioridade
  const hasOverbought = confluences.some((c) => c.toLowerCase().includes('sobrecompra'));
  const hasOversold = confluences.some((c) => c.toLowerCase().includes('sobrevenda'));
  console.log('üîç Detec√ß√£o de sinal:', {
    bullishSignals,
    bearishSignals,
    hasOverbought,
    hasOversold,
    confidenceScore
  });
  // ‚úÖ ARQUITETURA GEN√âRICA: PRIORIDADE 1 - Nome do padr√£o (ANTES de indicadores)
  // Funciona para TODOS os padr√µes: Order Block, Engulfing, Hammer, BOS, ChoCh, etc.
  const patternDirection = detectPatternDirection(pattern);
  let isBullishPattern = patternDirection.isBullish;
  let isBearishPattern = patternDirection.isBearish;

  console.log('üîç [Pattern Direction] Detec√ß√£o arquitet√¥nica:', {
    patternType: pattern?.type || pattern?.name || 'unknown',
    isBullishPattern,
    isBearishPattern,
    direction: patternDirection.direction,
    normalizedName: patternDirection.patternName
  });

  // ‚úÖ PRIORIDADE 1: Nome do padr√£o (arquitetura gen√©rica)
  // ‚úÖ CORRE√á√ÉO: Valida√ß√£o expl√≠cita para padr√µes contradit√≥rios
  const patternNameStr = String(pattern?.type || pattern?.name || '').toLowerCase();
  const isShootingStarPattern = patternNameStr.includes('shooting star') || patternNameStr.includes('shootingstar') || patternNameStr.includes('estrela cadente');
  const isGenericPattern = patternNameStr === 'estrutura t√©cnica' || patternNameStr === 'unknown' || patternNameStr === '';

  // ============================================================================
  // üåô THRESHOLD DIN√ÇMICO POR HOR√ÅRIO (baseado em dados reais)
  // ============================================================================
  // Hor√°rio 0-6h UTC (21h-3h BR): win rate 7-9% ‚Üí exigir confidence >= 80
  // Hor√°rio 7-23h UTC (4h-20h BR): win rate normal ‚Üí threshold padr√£o
  // Isso reduz ~65% dos trades noturnos mas ainda pega movimentos fortes
  // ============================================================================
  const currentHourUTC = new Date().getUTCHours();
  const isNightHours = currentHourUTC >= 0 && currentHourUTC <= 6; // 0-6h UTC = 21h-3h BR
  const nightThreshold = 70; // Alto threshold para noite (70+ tem 61% win rate)
  const dayThreshold = 40; // Threshold normal para dia

  if (isNightHours && confidenceScore < nightThreshold) {
    // Noite com confidence baixa ‚Üí BLOQUEAR
    signalType = 'NEUTRAL';
    console.log(`üåô [Night Filter] BLOQUEADO: Hor√°rio noturno (${currentHourUTC}h UTC) + confidence ${confidenceScore}% < threshold ${nightThreshold}%`);
    confluences.push(`üåô Bloqueado: Hor√°rio noturno (${currentHourUTC}h UTC) exige confidence >= ${nightThreshold}% (atual: ${confidenceScore}%)`);
  } else if (isNightHours) {
    console.log(`üåô [Night Filter] PERMITIDO: Hor√°rio noturno mas confidence ${confidenceScore}% >= threshold ${nightThreshold}%`);
    confluences.push(`üåô Hor√°rio noturno permitido: confidence ${confidenceScore}% >= ${nightThreshold}%`);
  }

  // ‚úÖ CORRE√á√ÉO CR√çTICA #2: Simplificar verifica√ß√£o expl√≠cita - qualquer padr√£o com "bearish"/"bullish" √© expl√≠cito
  // Inclui BOS, Hammer, Engulfing, Order Block, FVG, ChoCh, etc.
  const isExplicitBullishPattern = patternNameStr.includes('bullish');
  const isExplicitBearishPattern = patternNameStr.includes('bearish');

  if (isExplicitBullishPattern) {
    // Padr√£o Bullish expl√≠cito (ex: "Change of Character Bullish") ‚Üí SEMPRE BUY, ignorar Shooting Star
    signalType = 'BUY';
    console.log(`‚úÖ [Pattern Direction] PRIORIDADE ABSOLUTA: Padr√£o Bullish expl√≠cito ‚Üí BUY: ${pattern?.type || pattern?.name}`);
  } else if (isExplicitBearishPattern) {
    // Padr√£o Bearish expl√≠cito ‚Üí SEMPRE SELL
    signalType = 'SELL';
    console.log(`‚úÖ [Pattern Direction] PRIORIDADE ABSOLUTA: Padr√£o Bearish expl√≠cito ‚Üí SELL: ${pattern?.type || pattern?.name}`);
  } else if (isGenericPattern) {
    // ‚úÖ NOVO: Bloquear padr√µes gen√©ricos (win rate 19%) - N√ÉO ENTRAR
    // Padr√µes como "Estrutura t√©cnica" n√£o t√™m dire√ß√£o clara do M1
    signalType = 'NEUTRAL';
    confidenceScore = Math.min(confidenceScore, 30); // Garantir que n√£o passa threshold
    console.log(`üö´ [Pattern Direction] BLOQUEADO: Padr√£o gen√©rico "${patternNameStr}" - M1 n√£o detectou padr√£o claro`);
    confluences.push(`üö´ Bloqueado: Padr√£o gen√©rico sem dire√ß√£o M1 clara (win rate hist√≥rico: 19%)`);
  } else if (isShootingStarPattern && isBullishPattern) {
    // Shooting Star nunca pode ser bullish - corrigir para bearish (apenas se n√£o houver padr√£o expl√≠cito)
    console.warn(`‚ö†Ô∏è [Pattern Direction] CORRE√á√ÉO: Shooting Star detectado como Bullish (contradi√ß√£o) ‚Üí for√ßando SELL`);
    signalType = 'SELL';
    isBearishPattern = true;
    isBullishPattern = false;
  } else if (isBullishPattern) {
    signalType = 'BUY'; // ‚úÖ For√ßar BUY se padr√£o √© Bullish (qualquer padr√£o)
    console.log(`‚úÖ [Pattern Direction] Padr√£o Bullish detectado ‚Üí for√ßando BUY: ${pattern?.type || pattern?.name}`);
  } else if (isBearishPattern) {
    signalType = 'SELL'; // ‚úÖ For√ßar SELL se padr√£o √© Bearish (qualquer padr√£o)
    console.log(`‚úÖ [Pattern Direction] Padr√£o Bearish detectado ‚Üí for√ßando SELL: ${pattern?.type || pattern?.name}`);
  }
  // ‚úÖ REMOVIDO: Bloco MTF que determinava dire√ß√£o de padr√µes gen√©ricos
  // Padr√µes gen√©ricos agora s√£o BLOQUEADOS (score ‚â§30, signalType = NEUTRAL)
  // Isso evita trades com win rate de 19%

  // ‚úÖ CORRE√á√ÉO CR√çTICA #3: Proteger sinal j√° determinado - usar if separado para n√£o permitir sobrescrita
  // Se padr√£o j√° foi determinado acima, N√ÉO permitir que indicadores sobrescrevam
  if (isBullishPattern || isBearishPattern) {
    // Padr√£o j√° foi determinado acima - N√ÉO sobrescrever com indicadores
    // Manter signalType j√° definido (BUY ou SELL)
    console.log(`‚úÖ [Pattern Priority] Mantendo dire√ß√£o do padr√£o: ${signalType} (n√£o sobrescrevendo com indicadores)`);
  } else {
    // ‚úÖ PRIORIDADE 2: Indicadores (s√≥ se padr√£o n√£o for claro)
    // S√≥ determinar sinal por indicadores se padr√£o n√£o foi determinado acima
    if (rsiSuggestedSignal === 'NEUTRAL' && technicalIndicators?.rsi_14 >= 40 && technicalIndicators?.rsi_14 <= 60 && confidenceScore < 50) {
      signalType = 'NEUTRAL';
    } else if (hasOverbought || bearishSignals > bullishSignals + 2) {
      signalType = 'SELL'; // ‚úÖ Sobrecarro = venda (s√≥ se padr√£o n√£o for claro)
    } else if (hasOversold || bullishSignals > bearishSignals + 2) {
      signalType = 'BUY'; // ‚úÖ Sobrevenda = compra (s√≥ se padr√£o n√£o for claro)
    } else if (rsiSuggestedSignal === 'BUY' && confidenceScore >= 50 && bullishSignals >= bearishSignals) {
      signalType = 'BUY'; // ‚úÖ RSI sugere BUY e h√° sinais bullish
    } else if (rsiSuggestedSignal === 'SELL' && confidenceScore >= 50 && bearishSignals >= bullishSignals) {
      signalType = 'SELL'; // ‚úÖ RSI sugere SELL e h√° sinais bearish
    } else if (confidenceScore >= 60 && bullishSignals > bearishSignals) {
      signalType = 'BUY';
    } else if (confidenceScore <= 20 || bearishSignals > bullishSignals) {
      signalType = 'SELL';
    } else {
      signalType = signalType || 'NEUTRAL';
    }
  }
  // ‚úÖ MELHORIA SEGURA: Log claro de score antes do QC Filter (ajuda debugging)
  const scoreBeforeQC = confidenceScore;
  const signalBeforeQC = signalType;

  // üö® FILTRO DE QUALIDADE AVAN√áADO: QC LAYER (QUALITY CONTROL)
  // Este filtro aplica m√∫ltiplas camadas de prote√ß√£o contra sinais contradit√≥rios
  // ‚úÖ CR√çTICO PARA 75x LEVERAGE: QC Filter √© essencial para evitar trades de baixa qualidade
  const filteredResult = await applyQualityControlFilter({
    originalScore: confidenceScore,
    originalSignal: signalType,
    rsi: technicalIndicators?.rsi_14,
    mlAnalysis: mlAnalysis,
    technicalIndicators: technicalIndicators,
    marketData: marketData,
    confluences: confluences,
    supabase: supabaseClient, // ‚úÖ Usar supabaseClient ao inv√©s de supabase
    pattern: pattern // ‚úÖ Passar padr√£o para verificar dire√ß√£o bearish/bullish
  });
  // Aplicar resultado do filtro
  confidenceScore = filteredResult.confidenceScore;
  signalType = filteredResult.finalSignalType;
  confluences.push(...filteredResult.penaltiesApplied);

  // ‚úÖ MELHORIA SEGURA: Log claro mostrando ajustes do QC Filter
  if (scoreBeforeQC !== confidenceScore || signalBeforeQC !== signalType) {
    console.log('üìä [SCORE BREAKDOWN] Ajustes aplicados:', {
      beforeQC: { score: scoreBeforeQC, signal: signalBeforeQC },
      afterQC: { score: confidenceScore, signal: signalType },
      adjustments: {
        scoreChange: confidenceScore - scoreBeforeQC,
        signalChanged: signalBeforeQC !== signalType
      },
      penalties: filteredResult.penaltiesApplied?.length || 0
    });
  }

  // ‚úÖ PATCH 7: NORMALIZA√á√ÉO FINAL ser√° aplicada DEPOIS das an√°lises avan√ßadas
  // (precisa do directionalConfidence que √© calculado mais abaixo)

  // üöÄ NOVO: AN√ÅLISES AVAN√áADAS INSTITUCIONAIS
  // ‚úÖ CORRE√á√ÉO: Usar orderBookAnalysisVar e marketRegime j√° calculados (n√£o redeclarar)
  // orderBookAnalysisVar j√° foi declarado acima (linha 4398)
  // marketRegime j√° foi calculado acima (linha 4481) ou vem de additionalData
  // Se marketRegime n√£o foi calculado acima, usar o de additionalData
  if (!marketRegime && additionalData?.marketRegime) {
    marketRegime = additionalData.marketRegime;
  }

  // Declarar candles para uso nas an√°lises avan√ßadas
  const candles = additionalData?.candles || [];

  // 1. üéØ RASP - Risk-Adjusted Signal Probability
  const mtfScore = multiTimeframeContext?.confirmation === 'bullish' || multiTimeframeContext?.confirmation === 'bearish' ? 70 : 50;
  const patternScore = confidenceScore;
  const volumeScore = technicalIndicators?.volume_z_score ? (technicalIndicators.volume_z_score * 10 + 50) : 50;
  const orderBookScore = orderBookAnalysisVar ? (Math.abs(orderBookAnalysisVar.imbalance || 0) * 50 + 50) : 50;
  const regimeScore = marketRegime?.scoreAdjustment ? (marketRegime.scoreAdjustment + 50) : 50;

  const rasp = calculateRASP(mtfScore, patternScore, volumeScore, orderBookScore, regimeScore);
  confluences.push(`üéØ RASP: ${(rasp.probability * 100).toFixed(1)}% probabilidade (${rasp.confidence})`);

  // ‚úÖ MELHORIA: B√îNUS BASE PARA MICROESTRUTURA FAVOR√ÅVEL
  // 2. üî¨ MICROESTRUTURA ANALYSIS
  const microstructure = analyzeMicrostructure(candles, orderBookAnalysisVar);
  if (microstructure) {
    // B√¥nus base para microestrutura favor√°vel (bullish/bearish claro)
    if (microstructure.signals.bullish || microstructure.signals.bearish) {
      confidenceScore += 5; // ‚úÖ B√¥nus base para padr√µes de qualidade
      confluences.push(`üî¨ Microestrutura favor√°vel: +5 pontos base`);

      // ‚úÖ CORRE√á√ÉO 75x: Micro tend√™ncias s√≥ quando contexto macro permite
      // Microestrutura confirma, n√£o decide. Exige contexto MTF favor√°vel.
      const mtfNotDivergent = multiTimeframeContext?.confirmation !== 'divergent';
      if (microstructure.score >= 60 && signalType === 'NEUTRAL' && confidenceScore >= 40 && mtfNotDivergent) {
        // Se microestrutura √© clara (‚â•60) e score √© suficiente e MTF n√£o diverge
        if (microstructure.signals.bullish) {
          signalType = 'BUY';
          confidenceScore += 3;
          confluences.push(`üìà Micro tend√™ncia BULLISH (microestrutura ${microstructure.score.toFixed(0)}/100, MTF ok)`);
        } else if (microstructure.signals.bearish) {
          signalType = 'SELL';
          confidenceScore += 3;
          confluences.push(`üìâ Micro tend√™ncia BEARISH (microestrutura ${microstructure.score.toFixed(0)}/100, MTF ok)`);
        }
      } else if (microstructure.score >= 55 && signalType === 'NEUTRAL' && !mtfNotDivergent) {
        confluences.push(`‚ö†Ô∏è Microestrutura bloqueada: MTF divergente impede micro-tend√™ncia`);
      }
    }
    // Ajuste adicional baseado no score (peso reduzido)
    confidenceScore += Math.round((microstructure.score - 50) * 0.1); // ‚úÖ Reduzido de 0.3 (30%) para 0.1 (10%)
    confluences.push(`üî¨ Microestrutura: ${microstructure.score.toFixed(0)}/100 (${microstructure.signals.bullish ? 'Bullish' : microstructure.signals.bearish ? 'Bearish' : 'Neutral'})`);
    if (microstructure.displacement) confluences.push(`‚ö° Displacement candle detectado`);
    if (microstructure.expansion) confluences.push(`üìà Expans√£o de volatilidade`);
    if (microstructure.compression) confluences.push(`üìâ Compress√£o - aguardando breakout`);
  }

  // ‚úÖ PATCH 8: VALIDAR PRE√áO ANTES DE FORECAST
  // 3. üìà NEXT-CANDLE FORECASTING
  const forecast = forecastNextCandle(candles, technicalIndicators);
  if (forecast) {
    // ‚úÖ Validar amplitude antes de usar
    // üîß CORRE√á√ÉO: Usar currentPrice validado
    const priceForForecast = additionalData?.currentPrice || currentPrice || parseFloat(String(marketData.price)) || 1;
    const amplitudePercent = (forecast.amplitude / priceForForecast) * 100;
    if (amplitudePercent > 100 || !Number.isFinite(amplitudePercent) || amplitudePercent < 0) {
      console.warn('‚ö†Ô∏è Amplitude inv√°lida no forecast:', amplitudePercent);
      confluences.push(`üìà Previs√£o pr√≥ximo candle: ${(forecast.probabilityUp * 100).toFixed(1)}% ${forecast.expectedDirection} (amplitude: inv√°lida)`);
    } else {
      confluences.push(`üìà Previs√£o pr√≥ximo candle: ${(forecast.probabilityUp * 100).toFixed(1)}% ${forecast.expectedDirection} (amplitude: ${amplitudePercent.toFixed(3)}%)`);
    }
    confluences.push(`üìä Breakout prob: ${(forecast.breakoutProb * 100).toFixed(1)}% | Revers√£o prob: ${(forecast.reversalProb * 100).toFixed(1)}%`);
    // Ajustar score baseado na previs√£o
    if (forecast.expectedDirection === signalType && forecast.probabilityUp > 0.6) {
      confidenceScore += 10;
    } else if (forecast.expectedDirection !== signalType && forecast.probabilityUp > 0.6) {
      confidenceScore -= 10;
    }
  }

  // 4. üó∫Ô∏è LIQUIDITY MAP
  const liquidityMap = detectLiquidityMap(candles, orderBookAnalysisVar);
  if (liquidityMap) {
    confluences.push(`üó∫Ô∏è Liquidity Map: ${liquidityMap.equalHighs.length} equal highs, ${liquidityMap.equalLows.length} equal lows`);
    confluences.push(`üìç VWAP: ${liquidityMap.vwap.toFixed(2)} | Magnet levels: ${liquidityMap.magnetLevels.length}`);
    if (liquidityMap.magnetImbalance) confluences.push(`üß≤ Imbalance imantado detectado`);
    confidenceScore += Math.min(15, liquidityMap.score * 0.1);

    // ============================================================================
    // üìä RANGE TRADING BOOST - Comprar suporte, vender resist√™ncia
    // ============================================================================
    // Quando em regime RANGING e pre√ßo est√° tocando extremo do range:
    // - Compra no suporte (equalLows) ‚Üí +10 boost se signalType === 'BUY'
    // - Venda na resist√™ncia (equalHighs) ‚Üí +10 boost se signalType === 'SELL'
    // N√£o for√ßa entrada, apenas aumenta score de trades j√° detectados
    // ============================================================================
    if (marketRegime?.regime === 'RANGING' && liquidityMap.equalHighs.length > 0 && liquidityMap.equalLows.length > 0) {
      const tolerance = 0.003; // 0.3% de toler√¢ncia
      const nearestResistance = Math.min(...liquidityMap.equalHighs);
      const nearestSupport = Math.max(...liquidityMap.equalLows);

      const isNearSupport = currentPrice <= nearestSupport * (1 + tolerance);
      const isNearResistance = currentPrice >= nearestResistance * (1 - tolerance);

      if (isNearSupport && signalType === 'BUY') {
        confidenceScore += 10;
        confluences.push(`üìä Range Trading: Compra no suporte do range ($${nearestSupport.toFixed(2)}) +10 boost`);
        console.log(`üìä [Range Trading] BUY boost: pre√ßo $${currentPrice.toFixed(2)} pr√≥ximo suporte $${nearestSupport.toFixed(2)}`);
      } else if (isNearResistance && signalType === 'SELL') {
        confidenceScore += 10;
        confluences.push(`üìä Range Trading: Venda na resist√™ncia do range ($${nearestResistance.toFixed(2)}) +10 boost`);
        console.log(`üìä [Range Trading] SELL boost: pre√ßo $${currentPrice.toFixed(2)} pr√≥ximo resist√™ncia $${nearestResistance.toFixed(2)}`);
      } else if (isNearSupport && signalType === 'SELL') {
        confidenceScore -= 5;
        confluences.push(`‚ö†Ô∏è Range Trading: Venda no suporte (contra estrat√©gia) -5 penalidade`);
      } else if (isNearResistance && signalType === 'BUY') {
        confidenceScore -= 5;
        confluences.push(`‚ö†Ô∏è Range Trading: Compra na resist√™ncia (contra estrat√©gia) -5 penalidade`);
      }
    }
  }

  // 5. üö® KILL SWITCH - CALIBRADO POR SEVERIDADE
  // ============================================================================
  // üéØ CALIBRA√á√ÉO: Diferenciar "ru√≠do" de "caos"
  // - severity === 'high' ‚Üí HARD BLOCK (score = 0)
  // - severity === 'medium/low' ‚Üí SOFT BLOCK (-30 pontos)
  // ============================================================================
  const killSwitch = detectMarketKillSwitch(candles, orderBookAnalysisVar, technicalIndicators);
  let killSwitchActive = false;
  if (killSwitch.shouldBlock) {
    confluences.push(...killSwitch.reasons);

    // üéØ KILL SWITCH RELAXADO EM PAPER MODE
    // Permite que trades ocorram mesmo em "High Severity" (ex: Chop Zone) para coleta de dados
    if (TRADING_MODE === 'PAPER' && killSwitch.severity === 'high') {
      killSwitch.severity = 'medium';
      confluences.push(`üß™ PAPER MODE: Kill Switch rebaixado de HIGH para MEDIUM para permitir testes`);
    }

    if (killSwitch.severity === 'high') {
      // HARD BLOCK: Mercado em caos real
      confidenceScore = 0;
      signalType = 'NEUTRAL';
      killSwitchActive = true;
      confluences.push(`üö® KILL SWITCH ATIVADO - HARD BLOCK (severity: high): Trade cancelado`);
      console.log(`üö® [KILL SWITCH] HARD BLOCK - Severity: high, Score: 0`, {
        reasons: killSwitch.reasons
      });
    } else {
      // SOFT BLOCK: Penalidade mas permite trade com alta confian√ßa
      confidenceScore = Math.max(0, confidenceScore - 15); // ‚úÖ v283: Reduzido de -30 para -15
      confluences.push(`‚ö†Ô∏è KILL SWITCH ATIVADO - SOFT BLOCK (severity: ${killSwitch.severity}): -15 pontos`);
      console.log(`‚ö†Ô∏è [KILL SWITCH] SOFT BLOCK - Severity: ${killSwitch.severity}, Score: ${confidenceScore}`, {
        reasons: killSwitch.reasons
      });
    }
  }

  // 6. üõë AUTO-STOPPER - CALIBRADO POR CONDI√á√ÉO
  // ============================================================================
  // üéØ CALIBRA√á√ÉO: Soft block por padr√£o, hard block s√≥ em condi√ß√µes extremas
  // - Volatilidade extrema (ATR > 3%) ‚Üí HARD BLOCK
  // - Condi√ß√µes normais ‚Üí SOFT BLOCK (-30 pontos)
  // ============================================================================
  const autoStopper = checkAutoStopper(candles, technicalIndicators, orderBookAnalysisVar, marketRegime?.regime);
  if (autoStopper.shouldBlock) {
    confluences.push(autoStopper.reason);

    // Verificar se √© condi√ß√£o extrema (ATR muito alto)
    const priceForATR = parseFloat(String(marketData?.price || technicalIndicators?.close || 0)) || 1;
    const atrPercent = technicalIndicators?.atr ? (technicalIndicators.atr / priceForATR) * 100 : 0;
    const isExtremeCondition = atrPercent > 3.0; // ATR > 3% = condi√ß√£o extrema

    if (isExtremeCondition) {
      // HARD BLOCK: Condi√ß√£o extrema
      confidenceScore = 0;
      signalType = 'NEUTRAL';
      killSwitchActive = true;
      confluences.push(`üõë AUTO-STOPPER ATIVADO - HARD BLOCK (ATR: ${atrPercent.toFixed(2)}%): Trade cancelado`);
    } else {
      // SOFT BLOCK: Penalidade mas permite trade com alta confian√ßa
      confidenceScore = Math.max(0, confidenceScore - 15); // ‚úÖ v283: Reduzido de -30 para -15
      confluences.push(`‚ö†Ô∏è AUTO-STOPPER ATIVADO - SOFT BLOCK: -15 pontos`);
    }
  }

  // 7. üéØ HLS - High-Leverage Score (para 75x+)
  // leverage e isHighLeverage j√° declarados acima (linha 4602)
  if (isHighLeverage) {
    const mtfAlignment = multiTimeframeContext?.confirmation === 'bullish' || multiTimeframeContext?.confirmation === 'bearish' ? 0.8 : 0.5;
    const liquidityScore = liquidityMap ? (liquidityMap.score / 100) : 0.5;
    const orderBookPressure = orderBookAnalysisVar ? Math.abs(orderBookAnalysisVar.imbalance || 0) : 0.5;
    const volumeExpansion = technicalIndicators?.volume_z_score ? Math.min(1, (technicalIndicators.volume_z_score + 2) / 4) : 0.5;
    const microstructureScoreNormalized = microstructure ? (microstructure.score / 100) : 0.5;
    const regimeStability = marketRegime?.regime === 'TRENDING' || marketRegime?.regime === 'RANGING' ? 0.8 : 0.5;

    const hls = calculateHLS(mtfAlignment, liquidityScore, orderBookPressure, volumeExpansion, microstructureScoreNormalized, regimeStability);
    confluences.push(`üéØ HLS (High-Leverage Score): ${(hls.hls * 100).toFixed(1)}% ${hls.approved ? '‚úÖ APROVADO' : '‚ùå REJEITADO'}`);

    if (!hls.approved) {
      confidenceScore = Math.max(0, confidenceScore - 40);
      signalType = 'NEUTRAL';
      confluences.push(`üö® HLS abaixo do m√≠nimo (72%) - Sinal bloqueado para 75x+`);
    }
  }

  // 8. üß≠ DIRECTIONAL CONFIDENCE
  const trendStrength = Math.abs(mtfScore - 50) / 50; // Normalizado 0-1
  const momentumRatio = forecast ? Math.abs(forecast.momentumRatio) / (forecast.momentumRatio + 1) : 0.5;
  // ‚úÖ MELHORIA 4: Passar pattern, MTF e indicators para boost condicional
  const dirConf = calculateDirectionalConfidence(trendStrength, momentumRatio, pattern, multiTimeframeContext, technicalIndicators);
  const directionalConfidence = dirConf.confidence * 100; // ‚úÖ Armazenar para normaliza√ß√£o final

  // Log com informa√ß√£o sobre boost aplicado
  const boostNote = dirConf.boostApplied ? ` (${dirConf.boostApplied})` : '';
  confluences.push(`üß≠ Directional Confidence: ${directionalConfidence.toFixed(1)}% ${dirConf.approved ? '‚úÖ' : '‚ùå'}${boostNote}`);

  // ‚úÖ MELHORIA 1 & 2: Penalidade adaptativa baseada no score
  // Se score √© alto (‚â•60), reduzir penalidade; se score ‚â•65, n√£o aplicar penalidade
  if (isHighLeverage && !dirConf.approved) {
    if (confidenceScore >= 65) {
      // Score ‚â•65: Apenas aviso, sem penalidade (outras conflu√™ncias compensam)
      confluences.push(`‚ö†Ô∏è Directional Confidence ${directionalConfidence.toFixed(1)}% < 63% mas score alto (${confidenceScore}) compensa`);
    } else if (confidenceScore >= 60) {
      // Score ‚â•60: Penalidade reduzida (-10 ao inv√©s de -25)
      confidenceScore = Math.max(0, confidenceScore - 10);
      confluences.push(`‚ö†Ô∏è Directional Confidence ${directionalConfidence.toFixed(1)}% < 63% - Penalidade reduzida (-10) devido a score alto`);
    } else {
      // Score <60: Penalidade completa
      confidenceScore = Math.max(0, confidenceScore - 25);
      confluences.push(`üö® Directional Confidence ${directionalConfidence.toFixed(1)}% < 63% - Penalidade aplicada (-25)`);
    }
  }

  // ‚úÖ CORRE√á√ÉO CR√çTICA #10: Aplicar cap m√°ximo baseado no win rate hist√≥rico
  if (patternWinRate !== null && patternWinRate < 1.0) {
    if (patternWinRate < 0.3) {
      // Win rate < 30% ‚Üí cap m√°ximo de 50
      confidenceScore = Math.min(confidenceScore, 50);
      confluences.push(`‚ö†Ô∏è Cap de score aplicado: Win rate ${(patternWinRate * 100).toFixed(1)}% < 30% ‚Üí m√°ximo 50`);
    } else if (patternWinRate < 0.4) {
      // Win rate < 40% ‚Üí cap m√°ximo de 60
      confidenceScore = Math.min(confidenceScore, 60);
      confluences.push(`‚ö†Ô∏è Cap de score aplicado: Win rate ${(patternWinRate * 100).toFixed(1)}% < 40% ‚Üí m√°ximo 60`);
    } else if (patternWinRate < 0.5) {
      // Win rate < 50% ‚Üí cap m√°ximo de 75
      confidenceScore = Math.min(confidenceScore, 75);
      confluences.push(`‚ö†Ô∏è Cap de score aplicado: Win rate ${(patternWinRate * 100).toFixed(1)}% < 50% ‚Üí m√°ximo 75`);
    }
  }

  // ============================================================================
  // üü¢ GREEN LIGHT CANDIDATE - PR√â-AUTORIZA√á√ÉO (ser√° revalidada ap√≥s ERI/Acumula√ß√£o)
  // ============================================================================
  // Score N√ÉO decide sozinho. Autoridade decide.
  // Trade s√≥ acontece se receber PERMISS√ÉO FORMAL de um dos 3 caminhos:
  // 1. Momentum explosivo (institucional)
  // 2. Range limpo (SMC)
  // 3. Trend alinhado (MTF)
  // ‚ö†Ô∏è IMPORTANTE: Esta √© apenas uma PR√â-APROVA√á√ÉO - ser√° revalidada no final
  // ============================================================================

  const volumeZScore = technicalIndicators?.volume_z_score || 0;
  const microScore = microstructure?.score || 0;
  const liquidityScore = liquidityMap?.score || 0;
  const mtfConfirmation = multiTimeframeContext?.confirmation || 'none';
  const regime = marketRegime?.regime || 'UNKNOWN';

  // ‚úÖ CORRE√á√ÉO: killSwitchActive j√° foi declarada na linha 12012 pelo KILL SWITCH/AUTO-STOPPER
  // N√£o precisa redeclarar - usar a vari√°vel existente

  // üéØ THRESHOLD ADAPTATIVO POR PADR√ÉO (19/dez - Baseado em an√°lise de 5,043 trades)
  // ChoCh: minScore 55 (73.97% WR) | BOS: minScore 70 | Shooting Star: minScore 75
  const modeConfig = getModePermissions();
  const baseMinScore = modeConfig.minConfidenceScore || 60;
  const patternName = pattern?.name || pattern?.type || 'unknown';
  const patternMinScore = getMinScoreForPattern(patternName);

  // Usar o MENOR entre o threshold do padr√£o e (base - 5), para permitir flexibilidade
  // Mas nunca abaixo de 45 (seguran√ßa)
  const minScore = Math.max(45, Math.min(patternMinScore, baseMinScore));

  console.log(`üéØ [SCORE THRESHOLD] Pattern: "${patternName}", patternMin: ${patternMinScore}, baseMin: ${baseMinScore}, final: ${minScore}`);

  // üß™ CAMINHO 4 ‚Äî EXPERIMENTAL (PAPER ONLY)
  // Permite setups "quase bons" para coleta de dados e aprendizado
  const experimentalPaperPath =
    modeConfig.experimentalPath &&
    confidenceScore >= 45 &&  // üéØ Aumentado de 38 para 45 (~50% menos trades experimentais)
    microScore >= 45 &&
    !killSwitchActive &&
    !patternMemoryHardBlock;

  // ‚úÖ GREEN LIGHT CANDIDATE - 4 caminhos poss√≠veis para pr√©-autoriza√ß√£o
  // ‚ö†Ô∏è Ser√° revalidada ap√≥s ERI e Acumula√ß√£o
  const greenLightCandidate =
    confidenceScore >= minScore &&  // üéØ Threshold adaptativo por modo
    signalType !== 'NEUTRAL' &&
    !killSwitchActive &&
    !patternMemoryHardBlock &&
    (
      // üî• CAMINHO 1: Momentum explosivo (volume institucional)
      (volumeZScore >= 1.8 && microScore >= 55) ||

      // üìä CAMINHO 2: Range limpo (regime + liquidez + micro)
      (regime === 'RANGING' && liquidityScore >= 60 && microScore >= 50) ||

      // üìà CAMINHO 3: Trend alinhado (Multi-timeframe)
      (mtfConfirmation !== 'divergent' && directionalConfidence >= 63) ||

      // üéØ CAMINHO 5 (NOVO): Revers√£o em EXTREMO de Range + Contexto Correto
      // Ativa quando: est√° no extremo (topo/fundo), sinal alinha com dire√ß√£o, boost ativo
      (rangeContext?.isRange && rangeContext?.atExtreme && rangeContext?.boost > 0 &&
        ((rangeContext?.direction === 'BUY' && signalType === 'BUY') ||
          (rangeContext?.direction === 'SELL' && signalType === 'SELL'))) ||

      // ‚ö° CAMINHO 6 (NOVO): Exaust√£o de Run (Fim de Alta/Queda)
      // Ativa quando: run exausto, sinal coincide com revers√£o esperada
      (runExhaustion?.isExhausted && runExhaustion?.confidence >= 60 &&
        ((runExhaustion?.reversalDirection === 'BUY' && signalType === 'BUY') ||
          (runExhaustion?.reversalDirection === 'SELL' && signalType === 'SELL'))) ||

      // üß™ CAMINHO 4: Experimental (PAPER only)
      experimentalPaperPath
    );

  // Salvar signalType atual para detectar flip tardio
  const signalTypeAtGreenLight = signalType;

  if (greenLightCandidate) {
    confluences.push('üü° GREEN LIGHT CANDIDATE: Pr√©-aprova√ß√£o - aguardando valida√ß√£o final');
    console.log('üü° [GREEN LIGHT] Candidato aprovado (aguardando ERI/Acumula√ß√£o)', {
      score: confidenceScore,
      signal: signalType,
      path: volumeZScore >= 1.8 && microScore >= 55 ? 'MOMENTUM' :
        (rangeContext?.isRange && rangeContext?.atExtreme && rangeContext?.boost > 0) ? 'RANGE_EXTREME' :
          regime === 'RANGING' && liquidityScore >= 60 ? 'RANGE' :
            mtfConfirmation !== 'divergent' && directionalConfidence >= 63 ? 'TREND' : 'EXPERIMENTAL',
      volumeZ: volumeZScore.toFixed(2),
      microScore,
      liquidityScore,
      mtfConfirmation,
      directionalConfidence: directionalConfidence.toFixed(1),
      regime
    });
  }

  // ‚úÖ PATCH 7: NORMALIZA√á√ÉO FINAL - Garantir consist√™ncia entre score e signalType
  // ‚úÖ AJUSTE: Passar microestrutura para permitir micro tend√™ncias
  const normalizedResult = normalizeFinalSignal({
    confidenceScore,
    signalType,
    confluences
  }, technicalIndicators, directionalConfidence, microstructure);
  confidenceScore = normalizedResult.confidenceScore;
  signalType = normalizedResult.signalType;
  if (normalizedResult.reason) {
    confluences.push(normalizedResult.reason);
  }

  // 9. üîÑ EARLY REVERSAL INDEX
  const eri = calculateERI(candles, orderBookAnalysisVar);
  if (eri) {
    confluences.push(`üîÑ ERI: ${(eri.eri * 100).toFixed(1)}% ${eri.strongReversal ? '‚ö†Ô∏è REVERS√ÉO FORTE' : ''}`);
    if (eri.strongReversal && signalType !== 'NEUTRAL') {
      confidenceScore = Math.max(0, confidenceScore - 20);
      confluences.push(`‚ö†Ô∏è Early Reversal Index alto - Cautela com entrada`);
    }
  }

  // 10. üî• IGNITION DETECTOR (75x) - Detectar nascimento de movimentos
  const ignition = detectIgnition(candles, pattern);

  // üõ°Ô∏è PROTE√á√ÉO: N√£o aplicar ignition se ERI muito alto OU revers√£o forte
  const eriProtection = eri && (eri.eri >= 0.85 || eri.strongReversal);

  if (ignition.detected && ignition.scoreFloor && signalType !== 'NEUTRAL' && !eriProtection) {
    // Se igni√ß√£o v√°lida detectada e score est√° abaixo do floor, elevar
    const confidenceBefore = confidenceScore;
    if (confidenceScore < ignition.scoreFloor) {
      confidenceScore = ignition.scoreFloor;
      confluences.push(`üî• IGNITION: Score elevado de ${confidenceBefore} para ${ignition.scoreFloor} (${ignition.reason})`);
    } else {
      confluences.push(`üî• IGNITION: Detectada mas score j√° alto (${ignition.reason})`);
    }
    // üìä Log para estat√≠sticas
    console.log(`üî• [IGNITION]`, JSON.stringify({
      applied: confidenceScore !== confidenceBefore,
      delta: ignition.details?.delta,
      volumeRatio: ignition.details?.volumeRatio,
      confidenceBefore,
      confidenceAfter: confidenceScore,
      quality: ignition.quality
    }));
  } else if (eriProtection && ignition.detected) {
    confluences.push(`üî• IGNITION: Ignorada por ERI alto (${(eri.eri * 100).toFixed(0)}% ‚â• 85%)`);
  } else if (ignition.shouldReject && signalType !== 'NEUTRAL') {
    // Late entry guard - rejeitar entrada tardia
    confidenceScore = Math.max(0, confidenceScore - 30);
    signalType = 'NEUTRAL';
    confluences.push(`üõë LATE ENTRY: ${ignition.reason} - Trade rejeitado`);
    console.log(`üõë [IGNITION] Late entry rejeitado: ${ignition.reason}`);
  } else if (ignition.quality && ignition.quality !== 'none' && ignition.quality !== 'weak') {
    // Log informativo para outros casos
    confluences.push(`üî• Ignition: ${ignition.quality} - ${ignition.reason}`);
  }

  // üö® FILTRO FINAL PARA ALTA LEVERAGE (75x+) - Score m√≠nimo adaptativo
  // ‚úÖ MELHORIA: Score m√≠nimo adaptativo baseado em conflu√™ncias
  let tradeType = 'Consolida√ß√£o'; // Default
  let meetsMinimumScore = false;

  if (isHighLeverage) {
    // Detectar se √© movimento explosivo ou consolida√ß√£o
    const isMomentumTrade = (technicalIndicators?.rsi_14 < 30 || technicalIndicators?.rsi_14 > 70) &&
      (technicalIndicators?.volume_z_score > 1.5) &&
      (microstructure?.score >= 50); // ‚úÖ AJUSTE: Reduzido de 60 para 50

    if (isMomentumTrade) {
      tradeType = 'Explosivo';
      // Movimentos explosivos: score m√≠nimo 50 (ou adaptativo se momentum muito forte)
      const momentumStrong = (technicalIndicators?.rsi_14 < 30 || technicalIndicators?.rsi_14 > 70) &&
        (technicalIndicators?.volume_z_score > 2.0) &&
        (microstructure?.score >= 60); // ‚úÖ AJUSTE: Reduzido de 70 para 60

      // ‚úÖ CALIBRA√á√ÉO: Score m√≠nimo aumentado para melhor qualidade (50 ou 45 com momentum)
      if (confidenceScore >= 50 || (momentumStrong && confidenceScore >= 45)) {
        meetsMinimumScore = true;
        confluences.push(`‚úÖ ALTA LEVERAGE (${leverage || 75}x): Trade EXPLOSIVO - Score ${confidenceScore.toFixed(0)} ‚â• 50 (ou 45 com momentum forte) - APROVADO`);
      } else {
        confluences.push(`üö® ALTA LEVERAGE (${leverage || 75}x): Trade EXPLOSIVO - Score ${confidenceScore.toFixed(0)} abaixo do m√≠nimo (50) - SINAL REJEITADO`);
        if (confidenceScore < 40) {
          signalType = 'NEUTRAL';
          confluences.push(`üö® Score muito baixo para trade explosivo - Sinal alterado para NEUTRAL`);
        }
      }
    } else {
      tradeType = 'Consolida√ß√£o';
      // ‚úÖ CALIBRA√á√ÉO: Consolida√ß√£o - score m√≠nimo 45 com conflu√™ncias obrigat√≥rias (aumentado para qualidade)
      const hasMicrostructure = microstructure?.score >= 45; // Mantido em 45 (qualidade m√≠nima)
      const hasMTF = multiTimeframeContext?.confirmation !== 'divergent';
      const hasVolume = (technicalIndicators?.volume_z_score || 0) > -1.0; // Mantido

      if (confidenceScore >= 45 && hasMicrostructure && hasMTF && hasVolume) {
        meetsMinimumScore = true;
        confluences.push(`‚úÖ ALTA LEVERAGE (${leverage || 75}x): Trade CONSOLIDA√á√ÉO - Score ${confidenceScore.toFixed(0)} ‚â• 45 com conflu√™ncias (Micro:${hasMicrostructure}, MTF:${hasMTF}, Vol:${hasVolume}) - APROVADO`);
      } else {
        confluences.push(`üö® ALTA LEVERAGE (${leverage || 75}x): Trade CONSOLIDA√á√ÉO - Score ${confidenceScore.toFixed(0)} < 45 ou faltam conflu√™ncias - SINAL REJEITADO`);
        if (confidenceScore < 40) {
          signalType = 'NEUTRAL';
          confluences.push(`üö® Score muito baixo para consolida√ß√£o - Sinal alterado para NEUTRAL`);
        }
      }
    }
  } else {
    // ‚úÖ CALIBRA√á√ÉO: Para leverage normal, threshold 50 (consistente com alta leverage)
    meetsMinimumScore = confidenceScore >= 50;
  }

  // üÜï DETECTAR ACUMULA√á√ÉO ANTES DE FINALIZAR (para poder ajustar direction e confidenceScore)
  // calcular TP/SL
  // üêõ FIX: Usar currentPrice validado (j√° buscado da Binance se necess√°rio) ou additionalData.currentPrice
  // A fun√ß√£o computeTargets agora busca automaticamente se receber pre√ßo inv√°lido
  // üîß CORRE√á√ÉO: Usar currentPrice validado (j√° est√° dispon√≠vel no escopo)
  const currentPriceForTargets = additionalData?.currentPrice && additionalData.currentPrice > 0
    ? additionalData.currentPrice
    : (currentPrice && currentPrice > 0
      ? currentPrice
      : (typeof marketData.price === 'string'
        ? parseFloat(marketData.price.replace(/[$,]/g, ''))
        : (typeof marketData.price === 'number' && marketData.price > 0 ? marketData.price : 0)));

  // ‚úÖ CORRE√á√ÉO: computeTargets agora busca pre√ßo automaticamente se receber 0
  const targets = await computeTargets(marketData.symbol && marketData.symbol.includes('/') ? marketData.symbol.replace('/', '') : marketData.symbol || 'BTCUSDT', currentPriceForTargets, signalType, pattern);
  // üÜï DETECTAR ACUMULA√á√ÉO (movido para depois do detection de direction b√°sica)
  const acc = await detectAccumulation(marketData.symbol && marketData.symbol.includes('/') ? marketData.symbol.replace('/', '') : marketData.symbol || 'BTCUSDT', 0.0008);
  if (acc.isAccumulating || acc.hasBreakout) {
    // üÜï MENSAGEM INTELIGENTE BASEADA NAS CONDI√á√ïES
    let accMessage = '';
    if (acc.hasBreakout && acc.confirmedBreakout && acc.direction) {
      // A quebra foi confirmada com DIRE√á√ÉO (>0.5% + confirma√ß√£o 0.10%)
      const dirText = acc.direction === 'BUY' ? 'COMPRA üìà' : 'VENDA üìâ';
      accMessage = `‚úÖ Quebra de acumula√ß√£o CONFIRMADA ${dirText} (range m√©dio ${(acc.avgRangePct * 100).toFixed(2)}%, movimento confirmado)`;
      // üÜï AJUSTAR SIGNAL TYPE BASEADO NA DIRE√á√ÉO DA QUEBRA
      if (acc.direction === 'BUY') {
        signalType = 'BUY';
        confidenceScore += 15; // muito alta confian√ßa em quebra de compra confirmada
      } else if (acc.direction === 'SELL') {
        signalType = 'SELL';
        confidenceScore += 15; // muito alta confian√ßa em quebra de venda confirmada
      }
    } else if (acc.hasBreakout && !acc.confirmedBreakout && acc.direction) {
      // Quebra detectada mas aguardando confirma√ß√£o de 0.10%
      const dirText = acc.direction === 'BUY' ? 'COMPRA üìà' : 'VENDA üìâ';
      accMessage = `üîÑ Quebra de acumula√ß√£o detectada ${dirText} - aguardando confirma√ß√£o 0.10% (range m√©dio ${(acc.avgRangePct * 100).toFixed(2)}%)`;
      // Tentar ajustar signal type mas com menor confian√ßa
      if (acc.direction === 'BUY') {
        signalType = 'BUY';
        confidenceScore += 8;
      } else if (acc.direction === 'SELL') {
        signalType = 'SELL';
        confidenceScore += 8;
      }
    } else if (acc.avgRangePct < 0.0005) {
      // Mini-acumula√ß√£o detectada (<0.05%) - MOSTRAR FASE
      const phaseText = acc.phase === 'accumulation' ? 'üìä ACUMULA√á√ÉO' : acc.phase === 'distribution' ? 'üìâ DISTRIBUI√á√ÉO' : '‚ö™ NEUTRO';
      accMessage = `üß≤ Mini-consolida√ß√£o ${phaseText} detectada (${acc.bars} velas, range m√©dio ${(acc.avgRangePct * 100).toFixed(3)}%) - aguardando quebra`;
      confidenceScore -= 2; // reduzir confian√ßa em acumula√ß√£o sem quebra
    } else if (!acc.hasBreakout) {
      // Acumula√ß√£o normal sem quebra ainda - MOSTRAR FASE
      const phaseText = acc.phase === 'accumulation' ? 'üìä ACUMULA√á√ÉO' : acc.phase === 'distribution' ? 'üìâ DISTRIBUI√á√ÉO' : '‚ö™ NEUTRO';
      accMessage = `Consolida√ß√£o ${phaseText} detectada (${acc.bars} velas, range m√©dio ${(acc.avgRangePct * 100).toFixed(2)}%)`;
      confidenceScore -= 5; // reduzir confian√ßa
    }
    confluences.push(accMessage);
  }
  // Clamp score to realistic range 0-100 (sem for√ßar m√≠nimo)
  let finalScore = Math.min(100, Math.max(0, Math.round(confidenceScore)));

  // ============================================================================
  // üü¢ GREEN LIGHT FINAL - REVALIDA√á√ÉO AP√ìS ERI E ACUMULA√á√ÉO
  // ============================================================================
  // Revalida a autoriza√ß√£o verificando se:
  // 1. Era candidato original
  // 2. signalType N√ÉO mudou (flip tardio = cancelar)
  // 3. Score final ainda >= minScore (adaptativo por modo)
  // ============================================================================

  const signalFlipped = signalTypeAtGreenLight !== signalType && signalTypeAtGreenLight !== 'NEUTRAL';

  // üéØ Usar threshold adaptativo (j√° definido anteriormente)
  const greenLightFinal =
    greenLightCandidate &&
    !signalFlipped &&
    signalType !== 'NEUTRAL' &&
    finalScore >= minScore;  // üéØ Threshold adaptativo: PAPER=40, LIVE=45

  // Detectar flip tardio (perigoso para execu√ß√£o real)
  if (greenLightCandidate && signalFlipped) {
    confluences.push(`üö® FLIP TARDIO: Sinal mudou de ${signalTypeAtGreenLight} para ${signalType} ap√≥s pr√©-aprova√ß√£o - GREEN LIGHT CANCELADO`);
    console.log('üö® [GREEN LIGHT] FLIP TARDIO detectado - Autoriza√ß√£o CANCELADA', {
      originalSignal: signalTypeAtGreenLight,
      newSignal: signalType,
      cause: 'ERI ou Acumula√ß√£o alterou dire√ß√£o ap√≥s pr√©-aprova√ß√£o'
    });
  }

  // Determinar qual caminho autorizou (incluir novos caminhos)
  const greenLightPath =
    (runExhaustion?.isExhausted && runExhaustion?.confidence >= 60) ? 'RUN_EXHAUSTION' :
      (rangeContext?.isRange && rangeContext?.atExtreme && rangeContext?.boost > 0) ? 'RANGE_EXTREME' :
        experimentalPaperPath ? 'EXPERIMENTAL' :
          (volumeZScore >= 1.8 && microScore >= 55) ? 'MOMENTUM' :
            (regime === 'RANGING' && liquidityScore >= 60) ? 'RANGE' : 'TREND';

  // ============================================================================
  // üéØ ACCEPTABLE FAILURE CLASSIFICATION (N√≠vel 2)
  // Define quais cen√°rios T√äM PERMISS√ÉO para errar sem penaliza√ß√£o severa
  // ============================================================================
  const failureClassification = {
    // üü¢ ACCEPTABLE FAILURE: Cen√°rios onde o erro √© estatisticamente esperado
    RANGE_EXTREME: { acceptableFailure: true, maxInvalidation: 'rangeBreak', reason: 'False sweep √© comum em extremos' },
    RUN_EXHAUSTION: { acceptableFailure: true, maxInvalidation: 'runContinuation', reason: 'Exaust√£o pode falhar 40%+ das vezes' },
    EXPERIMENTAL: { acceptableFailure: true, maxInvalidation: 'any', reason: 'Modo de aprendizado' },

    // üî¥ TOXIC FAILURE: Cen√°rios onde o erro indica falha de l√≥gica
    MOMENTUM: { acceptableFailure: false, maxInvalidation: 'volumeFade', reason: 'Volume institucional n√£o deve falhar' },
    RANGE: { acceptableFailure: false, maxInvalidation: 'regimeChange', reason: 'Regime j√° confirmado' },
    TREND: { acceptableFailure: false, maxInvalidation: 'mtfDivergence', reason: 'MTF j√° alinhado' }
  };

  const currentFailureClass = failureClassification[greenLightPath] || { acceptableFailure: false, maxInvalidation: 'unknown', reason: 'N√£o classificado' };

  if (greenLightFinal) {
    // Substituir mensagem de candidato por mensagem final
    const candidateIndex = confluences.findIndex(c => c.includes('GREEN LIGHT CANDIDATE'));
    if (candidateIndex !== -1) {
      confluences[candidateIndex] = `üü¢ GREEN LIGHT FINAL: Trade AUTORIZADO via ${greenLightPath} [${TRADING_MODE}]${currentFailureClass.acceptableFailure ? ' (Erro Aceit√°vel)' : ''}`;
    } else {
      confluences.push(`üü¢ GREEN LIGHT FINAL: Trade AUTORIZADO via ${greenLightPath}${currentFailureClass.acceptableFailure ? ' (Erro Aceit√°vel)' : ''}`);
    }

    console.log('üü¢ [GREEN LIGHT FINAL] Trade AUTORIZADO', {
      finalScore,
      minScore,
      signalType,
      path: greenLightPath,
      mode: TRADING_MODE,
      signalPreserved: !signalFlipped,
      acceptableFailure: currentFailureClass.acceptableFailure,
      maxInvalidation: currentFailureClass.maxInvalidation
    });
  } else {
    console.log('üî¥ [GREEN LIGHT FINAL] Trade N√ÉO autorizado', {
      wasCandidate: greenLightCandidate,
      signalFlipped,
      signalType,
      finalScore,
      reason: !greenLightCandidate ? 'N√£o era candidato' :
        signalFlipped ? 'Flip tardio de sinal' :
          signalType === 'NEUTRAL' ? 'Sinal virou NEUTRAL' :
            finalScore < 45 ? 'Score caiu abaixo de 45' : 'Desconhecido'
    });
  }

  // ‚úÖ MELHORIA SEGURA: Log detalhado para monitoramento profissional com fluxo completo de scores
  const detectedPattern = pattern?.type || 'Unknown';
  const rsiValue = technicalIndicators?.rsi_14 || 0;
  const microstructureScore = microstructure?.score || 0;

  // ‚úÖ MELHORIA: Log completo mostrando evolu√ß√£o do score (ajuda debugging e monitoramento)
  console.log('üìä [SCORE FINAL] An√°lise completa:', {
    pattern: detectedPattern,
    confidenceScore: finalScore,
    signalType: signalType,
    tradeType: tradeType || 'N/A',
    meetsMinimumScore: meetsMinimumScore || false,
    positionSize: finalScore >= 50 && finalScore < 60 ? '0.8-1%' : finalScore >= 60 ? '1-1.2%' : 'N/A',
    microstructure: microstructureScore,
    MTF: mtfConfirmation,
    volume: volumeZScore,
    RSI: rsiValue,
    KillSwitchActive: killSwitchActive,
    isHighLeverage: isHighLeverage,
    leverage: leverage || 'N/A',
    // ‚úÖ NOVO: Mostrar evolu√ß√£o do score para debugging
    scoreEvolution: {
      initial: scoreBeforeQC || 'N/A',
      afterQC: scoreBeforeQC !== undefined ? confidenceScore : 'N/A',
      final: finalScore,
      adjustments: scoreBeforeQC !== undefined ? {
        qcChange: confidenceScore - scoreBeforeQC,
        totalChange: finalScore - (scoreBeforeQC || confidenceScore)
      } : 'N/A'
    }
  });

  // üéØ FILTRAR E PRIORIZAR CONFLU√äNCIAS (otimizado para alta leverage)
  const filteredConfluences = filterAndPrioritizeConfluences(
    confluences,
    isHighLeverage,
    killSwitchActive,
    signalType
  );

  // Gerar narra√ß√£o rica baseada nas conflu√™ncias filtradas
  const narration = await generateRichNarration(pattern, filteredConfluences, finalScore, signalType, marketData, technicalIndicators, supabaseClient, patternMemory);

  // ‚úÖ LOG: Resultado final da an√°lise
  log('info', 'Resultado final da an√°lise', {
    pattern: pattern?.type || 'N/A',
    symbol: marketData?.symbol || 'N/A',
    confidenceScore: finalScore,
    signalType: signalType === 'BUY' ? 'BUY' : signalType === 'SELL' ? 'SELL' : 'NEUTRAL',
    mtfApplied: mtfApplied || false,
    mtfRecommendation: mtfResult?.recommendation || 'N/A',
    mtfAlignment: mtfResult?.alignment || 'N/A',
    confluencesCount: filteredConfluences?.length || 0,
    tradeType: tradeType || 'N/A',
    meetsMinimumScore: meetsMinimumScore || false
  });

  return {
    confidenceScore: finalScore,
    signalType: signalType === 'BUY' ? 'BUY' : signalType === 'SELL' ? 'SELL' : 'NEUTRAL',
    confluences: filteredConfluences,
    knowledgeUsed,
    summary: narration.summary,
    narration: {
      full: narration.full,
      summary: narration.summary,
      analystComment: narration.analystComment // üÜï Coment√°rio do Analista IA
    },
    riskNote: narration.risk,
    marketContext: narration.context,
    technicalScore: finalScore,
    volumeAnalysis: narration.volumeAnalysis,
    patternDescription: narration.patternName,
    targets,
    detectedSignals,
    // ‚úÖ MELHORIA: Adicionar metadados para an√°lise
    metadata: {
      tradeType: tradeType || 'N/A',
      meetsMinimumScore: meetsMinimumScore || false,
      microstructureScore: microstructureScore,
      mtfConfirmation: mtfConfirmation,
      volumeZScore: volumeZScore,
      rsiValue: rsiValue,
      killSwitchActive: killSwitchActive,
      greenLight: greenLightFinal, // üü¢ Flag de autoriza√ß√£o FINAL (ap√≥s revalida√ß√£o)
      greenLightCandidate: greenLightCandidate, // üü° Pr√©-aprova√ß√£o (antes de ERI/Acumula√ß√£o)
      signalFlipped: signalFlipped, // üö® Se houve flip tardio
      greenLightPath: greenLightFinal
        ? (volumeZScore >= 1.8 && microScore >= 55 ? 'MOMENTUM' :
          regime === 'RANGING' && liquidityScore >= 60 ? 'RANGE' : 'TREND')
        : null
    }
  };
}
async function applyQualityControlFilter(input) {
  const { originalScore, originalSignal, rsi, mlAnalysis, technicalIndicators, marketData, supabase, pattern } = input;
  let score = originalScore;
  let finalSignal = originalSignal;
  const penaltiesApplied = [];
  console.log(`üö® [QC-FILTER] Verificando qualidade: sinal ${originalSignal}, score ${originalScore}`);

  // ‚úÖ ARQUITETURA GEN√âRICA: Usar fun√ß√£o gen√©rica para detectar dire√ß√£o do padr√£o
  const patternDirectionQC = detectPatternDirection(pattern);
  const isBullishPattern = patternDirectionQC.isBullish;
  const isBearishPattern = patternDirectionQC.isBearish;
  const patternName = pattern?.type || pattern?.name || '';
  // Configura√ß√µes
  const weights = {
    rsiContradictionPenalty: 30,
    mlPerMissingIndicatorPenalty: 4,
    marketNeutralPenalty: 15,
    lowVolatilityPenalty: 5,
    forceSwitchThreshold: 40
  };
  // 1) Contradi√ß√£o RSI
  if (rsi !== undefined && Number.isFinite(rsi)) {
    const rsiValue = rsi;
    if (rsiValue < 40 && originalSignal === 'SELL') {
      // ‚úÖ AJUSTE: Penalidade progressiva reduzida para aumentar trades
      let penalty = weights.rsiContradictionPenalty;
      if (rsiValue < 25) {
        penalty = 30; // RSI extremamente oversold = penalidade moderada
        penaltiesApplied.push(`üö® RSI EXTREMAMENTE OVERSOLD (${rsiValue.toFixed(1)}) vs SELL - PENALIDADE ${penalty}`);
      } else if (rsiValue < 30) {
        penalty = 20; // RSI muito oversold = penalidade moderada
        penaltiesApplied.push(`üö® RSI muito oversold (${rsiValue.toFixed(1)}) vs SELL - penalidade ${penalty}`);
      } else if (rsiValue < 35) {
        penalty = 15; // RSI oversold = penalidade baixa
        penaltiesApplied.push(`üö® RSI sobrevenda (${rsiValue.toFixed(1)}) vs SELL - penalidade ${penalty}`);
      } else {
        penaltiesApplied.push(`üö® RSI sobrevenda (${rsiValue.toFixed(1)}) vs SELL - penalidade ${penalty}`);
      }
      score -= penalty;
    }
    if (rsiValue > 70 && originalSignal === 'BUY') {
      // ‚úÖ AJUSTE: Penalidade progressiva reduzida para aumentar trades
      let penalty = weights.rsiContradictionPenalty;
      if (rsiValue > 85) {
        penalty = 30; // RSI extremamente overbought = penalidade moderada
        penaltiesApplied.push(`üö® RSI EXTREMAMENTE OVERBOUGHT (${rsiValue.toFixed(1)}) vs BUY - PENALIDADE ${penalty}`);
      } else if (rsiValue > 80) {
        penalty = 20; // RSI muito overbought = penalidade moderada
        penaltiesApplied.push(`üö® RSI muito overbought (${rsiValue.toFixed(1)}) vs BUY - penalidade ${penalty}`);
      } else if (rsiValue > 75) {
        penalty = 15; // RSI overbought = penalidade baixa
        penaltiesApplied.push(`üö® RSI sobrecomprado (${rsiValue.toFixed(1)}) vs BUY - penalidade ${penalty}`);
      } else {
        penaltiesApplied.push(`üö® RSI sobrecomprado (${rsiValue.toFixed(1)}) vs BUY - penalidade ${penalty}`);
      }
      score -= penalty;
    }
  }
  // 2) Penaliza√ß√£o ML - ‚úÖ MELHORIA: Reduzir penalidade para scores altos
  if (mlAnalysis && typeof mlAnalysis.alignment === 'number') {
    const missing = Math.max(0, 6 - mlAnalysis.alignment);
    if (missing > 0) {
      // ‚úÖ Score ‚â•60: penalidade reduzida pela metade
      const mlPenaltyMultiplier = originalScore >= 60 ? 0.5 : 1.0;
      const mlPenalty = Math.round(missing * weights.mlPerMissingIndicatorPenalty * mlPenaltyMultiplier);
      score -= mlPenalty;
      penaltiesApplied.push(`‚ö†Ô∏è ML alignment ${mlAnalysis.alignment}/6 - penalidade ${mlPenalty}${originalScore >= 60 ? ' (reduzida para score alto)' : ''}`);
    }
  }
  // 3) Mercado neutro - ‚úÖ MELHORIA: Reduzir penalidade para scores altos
  if (input.confluences && Array.isArray(input.confluences)) {
    const hasNeutral = input.confluences.some((c) => c.toLowerCase().includes('neutro'));
    if (hasNeutral) {
      // ‚úÖ Score ‚â•60: penalidade reduzida (outras conflu√™ncias compensam)
      const neutralPenalty = originalScore >= 60 ? weights.marketNeutralPenalty / 2 : weights.marketNeutralPenalty;
      score -= neutralPenalty;
      penaltiesApplied.push(`‚ÑπÔ∏è Momento Neutro detectado - penalidade ${neutralPenalty}${originalScore >= 60 ? ' (reduzida para score alto)' : ''}`);
    }
  }
  // 4) Baixa volatilidade - ESTRAT√âGIA BASEADA EM ATR
  // ‚úÖ MELHORIA: Reduzir penalidades para scores ‚â•60
  if (technicalIndicators && typeof technicalIndicators.atr_percent === 'number') {
    const atrPercent = technicalIndicators.atr_percent;

    // ‚úÖ BLOQUEIO COMPLETO: ATR < 0.35% - Movimentos quase nulos, risco alto
    if (atrPercent < 0.35) {
      score = 0; // Zerar score para bloquear trade
      penaltiesApplied.push(`üö® ATR ${atrPercent.toFixed(2)}% < 0.35% - BLOQUEADO: Movimentos quase nulos, risco alto`);
      finalSignal = 'NEUTRAL'; // For√ßar NEUTRAL
    }
    // ‚úÖ Penalidade moderada: ATR 0.35-1.5% (trade leve poss√≠vel)
    // ‚úÖ MELHORIA: Score ‚â•60 reduz penalidade pela metade
    else if (atrPercent < 1.5) {
      const volatilityPenalty = originalScore >= 60 ? weights.lowVolatilityPenalty / 2 : weights.lowVolatilityPenalty;
      score -= volatilityPenalty;
      penaltiesApplied.push(`üìâ Baixa volatilidade (ATR ${atrPercent.toFixed(2)}%) - Trade leve poss√≠vel, penalidade ${volatilityPenalty}${originalScore >= 60 ? ' (reduzida para score alto)' : ''}`);
    }
    // ‚úÖ ATR 1.5-2%: Trade m√©dio confort√°vel (sem penalidade)
    // ‚úÖ ATR > 2%: Trade forte seguro (sem penalidade, pode at√© ter boost)
  }
  // Normalizar
  score = Math.max(0, Math.min(100, Math.round(score)));

  // ‚úÖ PATCH 3: RECONSTRUIR QC-FILTER COMPLETAMENTE
  // 5) Reavaliar recomenda√ß√£o COM VERIFICA√á√ÉO DE SINAIS REAIS

  // Contar sinais bullish/bearish nas conflu√™ncias
  const bullishCount = input.confluences ? input.confluences.filter(c =>
    c.toLowerCase().includes('compra') ||
    c.toLowerCase().includes('sobrevenda') ||
    c.toLowerCase().includes('bullish') ||
    c.toLowerCase().includes('alta')
  ).length : 0;

  const bearishCount = input.confluences ? input.confluences.filter(c =>
    c.toLowerCase().includes('venda') ||
    c.toLowerCase().includes('sobrecompra') ||
    c.toLowerCase().includes('bearish') ||
    c.toLowerCase().includes('baixa')
  ).length : 0;

  // ‚úÖ CORRE√á√ÉO CR√çTICA #7 e #8: Simplificar verifica√ß√£o expl√≠cita e mover ANTES da verifica√ß√£o de score
  // Qualquer padr√£o com "bearish" ou "bullish" no nome √© expl√≠cito (inclui BOS, Hammer, Engulfing, etc.)
  const patternNameLower = patternName.toLowerCase();
  const isExplicitBullish = patternNameLower.includes('bullish');
  const isExplicitBearish = patternNameLower.includes('bearish');
  const hasExplicitDirection = isExplicitBullish || isExplicitBearish || isBullishPattern || isBearishPattern;

  // ‚úÖ PRIORIDADE ABSOLUTA #1: Verificar padr√£o ANTES de qualquer outra regra (independente de score)
  if (isExplicitBearish && originalSignal !== 'SELL') {
    // Padr√£o Bearish expl√≠cito ‚Üí SEMPRE SELL, independente de score ou outros sinais
    finalSignal = 'SELL';
    penaltiesApplied.push(`‚úÖ [QC-FILTER] PRIORIDADE ABSOLUTA: Padr√£o Bearish expl√≠cito (${patternName}) ‚Üí for√ßando SELL`);
    console.log(`‚úÖ [QC-FILTER] PRIORIDADE ABSOLUTA: ${originalSignal} ‚Üí SELL (padr√£o: ${patternName})`);
  } else if (isExplicitBullish && originalSignal !== 'BUY') {
    // Padr√£o Bullish expl√≠cito ‚Üí SEMPRE BUY, independente de score ou outros sinais
    finalSignal = 'BUY';
    penaltiesApplied.push(`‚úÖ [QC-FILTER] PRIORIDADE ABSOLUTA: Padr√£o Bullish expl√≠cito (${patternName}) ‚Üí for√ßando BUY`);
    console.log(`‚úÖ [QC-FILTER] PRIORIDADE ABSOLUTA: ${originalSignal} ‚Üí BUY (padr√£o: ${patternName})`);
  } else if (isBearishPattern && originalSignal === 'BUY') {
    // ‚úÖ CORRE√á√ÉO: Reverter BUY para SELL quando padr√£o √© bearish (independente de score)
    finalSignal = 'SELL';
    penaltiesApplied.push(`‚ö†Ô∏è [QC-FILTER] Padr√£o Bearish detectado (${patternName}) - revertendo BUY para SELL`);
    console.log(`‚úÖ [QC-FILTER] Revers√£o autom√°tica: BUY ‚Üí SELL (padr√£o: ${patternName})`);
  } else if (isBullishPattern && originalSignal === 'SELL') {
    // ‚úÖ CORRE√á√ÉO: Reverter SELL para BUY quando padr√£o √© bullish (independente de score)
    finalSignal = 'BUY';
    penaltiesApplied.push(`‚ö†Ô∏è [QC-FILTER] Padr√£o Bullish detectado (${patternName}) - revertendo SELL para BUY`);
    console.log(`‚úÖ [QC-FILTER] Revers√£o autom√°tica: SELL ‚Üí BUY (padr√£o: ${patternName})`);
  }
  // ‚úÖ REGRA 1: Score < 20 ‚Üí SEMPRE NEUTRAL (nunca BUY) - APENAS se n√£o houver padr√£o expl√≠cito
  else if (score < 20 && !hasExplicitDirection) {
    finalSignal = 'NEUTRAL';
    penaltiesApplied.push(`üö® Score ${score} < 20 ‚Üí for√ßando NEUTRAL (nunca BUY com score baixo)`);
  }
  // ‚úÖ REGRA 2: Score < 40 ‚Üí Verificar sinais antes de qualquer mudan√ßa
  else if (score < weights.forceSwitchThreshold && !hasExplicitDirection) {
    // ‚úÖ ARQUITETURA GEN√âRICA: Reverter sinais contradit√≥rios baseado no nome do padr√£o
    // Se padr√£o √© Bullish mas sinal original √© SELL ‚Üí reverter para BUY
    if (isBullishPattern && originalSignal === 'SELL') {
      finalSignal = 'BUY'; // ‚úÖ Reverter SELL para BUY quando padr√£o √© Bullish
      penaltiesApplied.push(`‚ö†Ô∏è [QC-FILTER] Padr√£o Bullish detectado (${patternName}) - revertendo SELL para BUY`);
      console.log(`‚úÖ [QC-FILTER] Revers√£o autom√°tica: SELL ‚Üí BUY (padr√£o: ${patternName})`);
    }
    // Se padr√£o √© Bearish mas sinal original √© BUY ‚Üí reverter para SELL
    else if (isBearishPattern && originalSignal === 'BUY') {
      finalSignal = 'SELL'; // ‚úÖ Reverter BUY para SELL quando padr√£o √© Bearish
      penaltiesApplied.push(`‚ö†Ô∏è [QC-FILTER] Padr√£o Bearish detectado (${patternName}) - revertendo BUY para SELL`);
      console.log(`‚úÖ [QC-FILTER] Revers√£o autom√°tica: BUY ‚Üí SELL (padr√£o: ${patternName})`);
    }
    // Se padr√£o e sinal est√£o alinhados mas h√° contradi√ß√£o com RSI extremo
    else if (isBearishPattern && originalSignal === 'SELL' && rsi !== undefined && rsi < 40) {
      // Padr√£o bearish + RSI oversold = manter SELL, mas aplicar penalidade de score
      finalSignal = 'SELL'; // ‚úÖ Manter SELL (padr√£o tem prioridade)
      score = Math.max(0, score - 10); // Penalidade adicional por contradi√ß√£o
      penaltiesApplied.push(`‚ö†Ô∏è Padr√£o bearish detectado (${patternName}) - RSI oversold, mantendo SELL com penalidade de score`);
    } else if (isBullishPattern && originalSignal === 'BUY' && rsi !== undefined && rsi > 70) {
      // Padr√£o bullish + RSI overbought = manter BUY, mas aplicar penalidade de score
      finalSignal = 'BUY'; // ‚úÖ Manter BUY (padr√£o tem prioridade)
      score = Math.max(0, score - 10); // Penalidade adicional por contradi√ß√£o
      penaltiesApplied.push(`‚ö†Ô∏è Padr√£o bullish detectado (${patternName}) - RSI overbought, mantendo BUY com penalidade de score`);
    }
    // ‚úÖ REGRA 3: Verificar sinais antes de inverter
    else if (originalSignal === 'SELL' && bearishCount > bullishCount) {
      // Manter SELL ou mudar para NEUTRAL, mas N√ÉO para BUY se h√° sinais bearish
      finalSignal = bearishCount >= 3 ? 'SELL' : 'NEUTRAL';
      score = Math.max(0, score);
      penaltiesApplied.push(`‚ö†Ô∏è Score ${score} < ${weights.forceSwitchThreshold} mas h√° ${bearishCount} sinais bearish ‚Üí mantendo ${finalSignal}`);
    } else if (originalSignal === 'BUY' && bullishCount > bearishCount) {
      // Manter BUY ou mudar para NEUTRAL, mas N√ÉO para SELL se h√° sinais bullish
      finalSignal = bullishCount >= 3 ? 'BUY' : 'NEUTRAL';
      score = Math.max(0, score);
      penaltiesApplied.push(`‚ö†Ô∏è Score ${score} < ${weights.forceSwitchThreshold} mas h√° ${bullishCount} sinais bullish ‚Üí mantendo ${finalSignal}`);
    }
    // ‚úÖ REGRA 4: Inverter apenas se h√° sinais claros do lado oposto
    else if (originalSignal === 'SELL' && bullishCount >= 3) {
      finalSignal = 'BUY';
      penaltiesApplied.push(`üîÑ Score ${score} < ${weights.forceSwitchThreshold} e h√° ${bullishCount} sinais bullish ‚Üí mudou para BUY`);
    } else if (originalSignal === 'BUY' && bearishCount >= 3) {
      finalSignal = 'SELL';
      penaltiesApplied.push(`üîÑ Score ${score} < ${weights.forceSwitchThreshold} e h√° ${bearishCount} sinais bearish ‚Üí mudou para SELL`);
    }
    // ‚úÖ REGRA 5: Se n√£o h√° sinais claros, mudar para NEUTRAL
    else {
      finalSignal = 'NEUTRAL';
      penaltiesApplied.push(`‚ö†Ô∏è Score ${score} < ${weights.forceSwitchThreshold} e sinais amb√≠guos (bullish: ${bullishCount}, bearish: ${bearishCount}) ‚Üí mudou para NEUTRAL`);
    }

    // ‚úÖ CORRE√á√ÉO CR√çTICA #9: RSI boost s√≥ aplica se sinal final est√° alinhado com padr√£o
    if (rsi !== undefined && Number.isFinite(rsi)) {
      const rsiValue = rsi;
      // Verificar se sinal final est√° alinhado com padr√£o
      const isAligned = (isBearishPattern && finalSignal === 'SELL') ||
        (isBullishPattern && finalSignal === 'BUY') ||
        (!isBearishPattern && !isBullishPattern);

      if (isAligned && finalSignal === 'BUY' && rsiValue < 40) {
        // RSI em sobrevenda + sinal BUY alinhado = BOOST!
        const rsiBoost = rsiValue < 30 ? 45 : 20; // +45 se <30, +20 se 30-40
        score += rsiBoost;
        penaltiesApplied.push(`‚úÖ RSI sobrevenda (${rsiValue.toFixed(1)}) alinhado com BUY - boost +${rsiBoost}`);
      } else if (isAligned && finalSignal === 'SELL' && rsiValue > 60) {
        // RSI em sobrecompra + sinal SELL alinhado = BOOST!
        const rsiBoost = rsiValue > 70 ? 30 : 15; // +30 se >70, +15 se 60-70
        score += rsiBoost;
        penaltiesApplied.push(`‚úÖ RSI sobrecomprado (${rsiValue.toFixed(1)}) alinhado com SELL - boost +${rsiBoost}`);
      }
    }
    // Normalizar novamente ap√≥s boost
    score = Math.max(0, Math.min(100, Math.round(score)));
  } else if (score < 70) {
    penaltiesApplied.push(`‚ö†Ô∏è Score ${score} ‚Üí execu√ß√£o moderada (stop apertado)`);
  }
  // 6) Auditoria (DESABILITADO - n√£o usado por nenhuma funcionalidade)
  // ‚úÖ OTIMIZA√á√ÉO: Parar de salvar trades_audit para economizar espa√ßo
  // Esta tabela n√£o √© lida por nenhum m√≥dulo do sistema
  // if (supabase && typeof supabase.from === 'function') {
  //   try {
  //     const { error: auditError } = await supabase.from('trades_audit').insert({
  //       symbol: marketData?.symbol || null,
  //       timeframe: marketData?.timeframe || null,
  //       original_signal: originalSignal,
  //       final_signal: finalSignal,
  //       original_score: originalScore,
  //       final_score: score,
  //       penalties: penaltiesApplied,
  //       created_at: new Date().toISOString()
  //     });
  //     
  //     if (auditError && !auditError.message?.includes('PGRST205') && !auditError.message?.includes('404')) {
  //       console.warn('‚ö†Ô∏è [QC-FILTER] Erro ao salvar auditoria (n√£o cr√≠tico):', auditError.message);
  //     }
  //   } catch (err: any) {
  //     // Ignore erros de tabela n√£o encontrada (404/PGRST205)
  //     if (!err?.message?.includes('PGRST205') && !err?.message?.includes('404')) {
  //       console.warn('‚ö†Ô∏è [QC-FILTER] Exce√ß√£o ao salvar auditoria (n√£o cr√≠tico):', err?.message);
  //     }
  //   }
  // }
  console.log(`‚úÖ [QC-FILTER] ${originalScore} ‚Üí ${score}, ${originalSignal} ‚Üí ${finalSignal}`);
  return {
    confidenceScore: score,
    finalSignalType: finalSignal,
    penaltiesApplied
  };
}
// ========== FUN√á√ïES DE AN√ÅLISE T√âCNICA ==========
// ‚úÖ PATCH 2: CORRIGIR analyzeRSI() - Retornar suggestedSignal
function analyzeRSI(rsi, signalType) {
  console.log('üîç analyzeRSI - RSI recebido:', {
    rsi,
    signalType,
    isValid: Number.isFinite(rsi)
  });
  // Validar RSI
  const validRSI = Number.isFinite(rsi) ? rsi : 50;
  let score = 0;
  let suggestedSignal = 'NEUTRAL'; // ‚úÖ Adicionar suggestedSignal
  const confluences = [];
  if (validRSI < 30) {
    score += 30; // ‚úÖ ESTRAT√âGIA PERFEITA 75x: Balanceado de 45 para 30 (remove vi√©s BUY)
    suggestedSignal = 'BUY'; // ‚úÖ For√ßar BUY quando oversold extremo
    confluences.push(`RSI ${validRSI.toFixed(1)} em sobrevenda (<30) - forte sinal compra`);
  } else if (validRSI < 40) {
    score += 10; // Mant√©m
    suggestedSignal = 'BUY'; // ‚úÖ For√ßar BUY quando oversold moderado
    confluences.push(`RSI ${validRSI.toFixed(1)} em zona sobrevenda (30-40) - sinal compra`);
  } else if (validRSI > 70) {
    score -= 20; // ‚úÖ ESTRAT√âGIA PERFEITA 75x: Balanceado de -12 para -20 (equilibra com oversold)
    suggestedSignal = 'SELL'; // ‚úÖ For√ßar SELL quando overbought extremo
    confluences.push(`RSI ${validRSI.toFixed(1)} em sobrecompra (>70) - sinal venda`);
  } else if (validRSI > 60) {
    score -= 8; // ‚úÖ ESTRAT√âGIA PERFEITA 75x: Aumentado de -6 para -8 (balanceamento)
    suggestedSignal = 'NEUTRAL'; // ‚úÖ NEUTRAL quando overbought moderado
    confluences.push(`RSI ${validRSI.toFixed(1)} em sobrecompra (60-70) - cautela`);
  } else {
    // RSI 40-60 = NEUTRO
    // ‚úÖ CALIBRA√á√ÉO: B√¥nus aumentado para RSI neutro (lateralidade pode ser aproveitada)
    score += 4; // Aumentado de 3 para 4 (+33%)
    suggestedSignal = 'NEUTRAL'; // ‚úÖ For√ßar NEUTRAL quando RSI neutro
    confluences.push(`RSI ${validRSI.toFixed(1)} neutro (40-60) - pequeno b√¥nus para lateralidade`);
  }
  console.log('‚úÖ Conflu√™ncias RSI geradas:', confluences);
  return {
    score,
    confluences,
    suggestedSignal // ‚úÖ Retornar suggestedSignal
  };
}
function analyzeTrend(indicators, signalType) {
  console.log('üîç analyzeTrend - EMAs recebidas:', {
    ema_9: indicators.ema_9,
    ema_50: indicators.ema_50,
    ema_200: indicators.ema_200,
    rsi_14: indicators.rsi_14
  });
  let score = 0;
  const confluences = [];
  const { ema_9, ema_50, ema_200 } = indicators;
  if (ema_9 && ema_50 && ema_200) {
    // Tend√™ncia de alta
    if (ema_9 > ema_50 && ema_50 > ema_200) {
      score += 20;
      confluences.push('Tend√™ncia alta confirmada (EMA9 > EMA50 > EMA200)');
    } else if (ema_9 < ema_50 && ema_50 < ema_200) {
      score -= 20;
      confluences.push('Tend√™ncia baixa confirmada (EMA9 < EMA50 < EMA200)');
    } else {
      confluences.push('EMAs em consolida√ß√£o - aguardar defini√ß√£o');
    }
    // An√°lise de dist√¢ncia entre EMAs
    const ema9_vs_50 = ((ema_9 - ema_50) / ema_50 * 100).toFixed(3);
    const ema50_vs_200 = ((ema_50 - ema_200) / ema_200 * 100).toFixed(3);
    console.log('üîç An√°lise de tend√™ncia EMAs:', {
      ema_9,
      ema_50,
      ema_200,
      ema9_vs_50,
      ema50_vs_200
    });
    if (Math.abs(parseFloat(ema9_vs_50)) > 2) {
      score += 5;
      confluences.push(`Tend√™ncia macro: ${parseFloat(ema9_vs_50) > 0 ? 'Alta' : 'Baixa'} (EMA50 ${ema50_vs_200}% vs EMA200)`);
    }
  }
  return {
    score,
    confluences
  };
}
function analyzeVolume(indicators, marketData) {
  console.log('üîç analyzeVolume AVAN√áADO - Indicadores recebidos:', {
    volume_spike: indicators.volume_spike,
    volume_z_score: indicators.volume_z_score,
    vwap: indicators.vwap,
    volume_profile: indicators.volume_profile,
    volume_delta: indicators.volume_delta,
    bollinger_bands: indicators.bollinger_bands
  });
  let score = 0;
  const confluences = [];
  const { volume_z_score, volume_spike, vwap, volume_profile, volume_delta, bollinger_bands } = indicators;
  const currentPrice = typeof marketData.price === 'string' ? parseFloat(marketData.price.replace(/[$,]/g, '')) : typeof marketData.price === 'number' ? marketData.price : 0;

  // ‚úÖ CORRE√á√ÉO: Se volume_spike n√£o est√° definido mas volume_z_score est√° dispon√≠vel, usar como fallback
  // volume_z_score > 0.5 pode indicar volume acima da m√©dia (spike relativo)
  const hasVolumeSpike = volume_spike || (volume_z_score !== undefined && volume_z_score > 0.5);

  // 1. Volume Z-Score (existente)
  if (hasVolumeSpike) {
    score += 12; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 10 para 12 (+20%)
    if (volume_spike) {
      confluences.push('Volume spike detectado - confirma√ß√£o movimento');
    } else if (volume_z_score > 0.5) {
      confluences.push(`Volume acima da m√©dia (z-score ${volume_z_score.toFixed(2)}) - confirma√ß√£o movimento`);
    }
  }
  if (volume_z_score !== undefined && volume_z_score > 2) {
    score += 18; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 15 para 18 (+20%)
    confluences.push(`Volume muito alto (${volume_z_score.toFixed(1)}œÉ) - forte confirma√ß√£o`);
  } else if (volume_z_score !== undefined && volume_z_score > 1) {
    score += 10; // ‚úÖ CALIBRA√á√ÉO: Aumentado de 8 para 10 (+25%)
    confluences.push(`Volume alto (${volume_z_score.toFixed(1)}œÉ) - confirma√ß√£o moderada`);
  } else if (volume_z_score !== undefined && volume_z_score < -1) {
    // ‚úÖ MELHORIA: Penalidade reduzida para volume baixo (consolida√ß√£o menos punitiva)
    score -= 3; // Reduzido de -5 para -3
    confluences.push(`Volume baixo (${volume_z_score.toFixed(1)}œÉ) - aus√™ncia de confirma√ß√£o`);
  }
  // 2. VWAP Analysis (NOVO)
  if (vwap && currentPrice) {
    const vwapDistance = (currentPrice - vwap) / vwap * 100;
    if (Math.abs(vwapDistance) < 0.5) {
      score += 12;
      confluences.push(`Pre√ßo pr√≥ximo ao VWAP (${vwapDistance.toFixed(2)}%) - suporte/resist√™ncia forte`);
    } else if (vwapDistance > 2) {
      score += 8;
      confluences.push(`Pre√ßo acima do VWAP (${vwapDistance.toFixed(2)}%) - tend√™ncia de alta`);
    } else if (vwapDistance < -2) {
      score += 8;
      confluences.push(`Pre√ßo abaixo do VWAP (${vwapDistance.toFixed(2)}%) - tend√™ncia de baixa`);
    }
  }
  // 3. Volume Profile POC (NOVO)
  if (volume_profile && volume_profile.poc && currentPrice) {
    const pocDistance = (currentPrice - volume_profile.poc) / volume_profile.poc * 100;
    if (Math.abs(pocDistance) < 1) {
      score += 15;
      confluences.push(`Pre√ßo no POC (${pocDistance.toFixed(2)}%) - zona de maior volume`);
    } else if (Math.abs(pocDistance) < 2) {
      score += 8;
      confluences.push(`Pre√ßo pr√≥ximo ao POC (${pocDistance.toFixed(2)}%) - zona de interesse`);
    }
  }
  // 4. Volume Delta (NOVO)
  if (volume_delta) {
    const { buyVolume, sellVolume, delta } = volume_delta;
    const totalVolume = buyVolume + sellVolume;
    if (totalVolume > 0) {
      const buyRatio = buyVolume / totalVolume * 100;
      const sellRatio = sellVolume / totalVolume * 100;
      if (buyRatio > 60) {
        score += 12;
        confluences.push(`Caracter√≠sticas t√©cnicas de press√£o compradora forte (${buyRatio.toFixed(1)}%) - an√°lise t√©cnica de alta`);
      } else if (sellRatio > 60) {
        score += 12;
        confluences.push(`Caracter√≠sticas t√©cnicas de press√£o vendedora forte (${sellRatio.toFixed(1)}%) - an√°lise t√©cnica de baixa`);
      } else if (Math.abs(buyRatio - sellRatio) < 10) {
        score += 5;
        confluences.push(`Equil√≠brio de for√ßas (${buyRatio.toFixed(1)}% vs ${sellRatio.toFixed(1)}%) - indecis√£o`);
      }
    }
  }
  // 5. Bollinger Bands (NOVO)
  if (bollinger_bands && currentPrice) {
    const { upper, middle, lower, width } = bollinger_bands;
    if (upper > 0 && lower > 0) {
      if (currentPrice > upper) {
        score += 10;
        confluences.push(`Pre√ßo acima da banda superior - poss√≠vel revers√£o`);
      } else if (currentPrice < lower) {
        score += 10;
        confluences.push(`Pre√ßo abaixo da banda inferior - poss√≠vel revers√£o`);
      } else if (currentPrice > middle) {
        score += 5;
        confluences.push(`Pre√ßo na metade superior das bandas - tend√™ncia de alta`);
      } else {
        score += 5;
        confluences.push(`Pre√ßo na metade inferior das bandas - tend√™ncia de baixa`);
      }
      if (width < 5) {
        score += 8;
        confluences.push(`Bandas comprimidas (${width.toFixed(1)}%) - poss√≠vel breakout`);
      }
    }
  }
  return {
    score,
    confluences
  };
}
// ===== MACHINE LEARNING PARA PRECIS√ÉO 85-95% =====
function analyzeMLPatterns(indicators, marketData) {
  console.log('ü§ñ ML Pattern Analysis - Iniciando an√°lise de padr√µes avan√ßados');
  let mlScore = 0;
  const mlConfluences = [];
  const currentPrice = typeof marketData.price === 'string' ? parseFloat(marketData.price.replace(/[$,]/g, '')) : typeof marketData.price === 'number' ? marketData.price : 0;
  const { vwap, volume_profile, volume_delta, bollinger_bands, stochastic, rsi_14 } = indicators;
  // 1. VWAP + Volume Profile Confluence
  if (vwap && volume_profile && volume_profile.poc) {
    const vwapDistance = Math.abs(currentPrice - vwap) / vwap * 100;
    const pocDistance = Math.abs(currentPrice - volume_profile.poc) / volume_profile.poc * 100;
    if (vwapDistance < 1 && pocDistance < 1) {
      mlScore += 20;
      mlConfluences.push(`ü§ñ ML: VWAP + POC confluence - zona de m√°xima liquidez`);
    }
  }
  // 2. Volume Delta + Stochastic Confluence
  if (volume_delta && stochastic) {
    const { buyVolume, sellVolume } = volume_delta;
    const totalVolume = buyVolume + sellVolume;
    const buyRatio = totalVolume > 0 ? buyVolume / totalVolume * 100 : 50;
    if (buyRatio > 65 && stochastic.k < 30) {
      mlScore += 18;
      mlConfluences.push(`ü§ñ ML: Volume Delta + Stochastic oversold - setup de compra forte`);
    } else if (buyRatio < 35 && stochastic.k > 70) {
      mlScore += 18;
      mlConfluences.push(`ü§ñ ML: Volume Delta + Stochastic overbought - setup de venda forte`);
    }
  }
  // 3. Bollinger Bands + RSI Confluence
  if (bollinger_bands && rsi_14) {
    const { upper, lower, width } = bollinger_bands;
    if (currentPrice < lower && rsi_14 < 30) {
      mlScore += 15;
      mlConfluences.push(`ü§ñ ML: Bollinger Lower + RSI oversold - revers√£o de alta prov√°vel`);
    } else if (currentPrice > upper && rsi_14 > 70) {
      mlScore += 15;
      mlConfluences.push(`ü§ñ ML: Bollinger Upper + RSI overbought - revers√£o de baixa prov√°vel`);
    }
    if (width < 3 && rsi_14 > 45 && rsi_14 < 55) {
      mlScore += 12;
      mlConfluences.push(`ü§ñ ML: Bandas comprimidas + RSI neutro - breakout iminente`);
    }
  }
  // 4. Multi-timeframe ML Analysis
  const mlMultiTimeframe = (() => {
    let score = 0;
    const confluences = [];
    // An√°lise de tend√™ncia baseada em m√∫ltiplos indicadores
    const trendScore = (() => {
      let score = 0;
      if (vwap && currentPrice > vwap) score += 2;
      if (volume_profile && currentPrice > volume_profile.poc) score += 2;
      if (bollinger_bands && currentPrice > bollinger_bands.middle) score += 1;
      if (rsi_14 > 50) score += 1;
      return score;
    })();
    if (trendScore >= 5) {
      score += 10;
      confluences.push(`ü§ñ ML: Multi-indicator bullish alignment (${trendScore}/6)`);
    } else if (trendScore <= 1) {
      score += 10;
      confluences.push(`ü§ñ ML: Multi-indicator bearish alignment (${trendScore}/6)`);
    }
    return {
      score,
      confluences
    };
  })();
  mlScore += mlMultiTimeframe.score;
  mlConfluences.push(...mlMultiTimeframe.confluences);
  // 5. Ensemble Method - Combina√ß√£o de modelos
  const ensembleScore = (() => {
    const scores = [
      mlScore,
      mlMultiTimeframe.score
    ];
    const weights = [
      0.6,
      0.4
    ]; // Pesos para cada modelo
    return scores.reduce((sum, score, i) => sum + score * weights[i], 0);
  })();
  return {
    score: Math.min(ensembleScore, 50),
    confluences: mlConfluences,
    mlDetails: {
      vwapAnalysis: vwap ? `VWAP: ${vwap.toFixed(2)}` : 'N/A',
      volumeProfileAnalysis: volume_profile ? `POC: ${volume_profile.poc.toFixed(2)}` : 'N/A',
      volumeDeltaAnalysis: volume_delta ? `Delta: ${volume_delta.delta.toFixed(2)}` : 'N/A',
      bollingerAnalysis: bollinger_bands ? `Width: ${bollinger_bands.width.toFixed(1)}%` : 'N/A'
    }
  };
}
// ===== AN√ÅLISE CONTEXTUAL INTELIGENTE (IA M√ÅXIMA) =====
function generateContextualIntelligence(indicators, marketData, existingConfluences) {
  console.log('üß† Contextual Intelligence - Analisando momento atual do mercado');
  // üîß Normaliza valores para evitar erro de tipo
  if (marketData) {
    if (typeof marketData.change24h !== "string") {
      marketData.change24h = String(marketData.change24h ?? "0");
    }
    if (typeof marketData.volume !== "string") {
      marketData.volume = String(marketData.volume ?? "0");
    }
  }
  let contextualScore = 0;
  const contextualConfluences = [];
  const currentPrice = typeof marketData.price === 'string' ? parseFloat(marketData.price.replace(/[$,]/g, '')) : typeof marketData.price === 'number' ? marketData.price : 0;
  const priceChange24h = typeof marketData.change24h === 'string' ? parseFloat(marketData.change24h.replace('%', '') || '0') : typeof marketData.change24h === 'number' ? marketData.change24h : 0;
  const volume = typeof marketData.volume === 'string' ? parseFloat(marketData.volume.replace(/[$,]/g, '') || '0') : typeof marketData.volume === 'number' ? marketData.volume : 0;
  // 1. AN√ÅLISE DE PRE√áO CONTEXTUAL
  const priceContext = (() => {
    let context = '';
    let score = 0;
    // An√°lise de movimento de pre√ßo
    if (Math.abs(priceChange24h) > 5) {
      context = `Mercado em movimento significativo (${priceChange24h > 0 ? '+' : ''}${priceChange24h.toFixed(2)}%)`;
      score += 8;
    } else if (Math.abs(priceChange24h) > 2) {
      context = `Mercado com movimento moderado (${priceChange24h > 0 ? '+' : ''}${priceChange24h.toFixed(2)}%)`;
      score += 5;
    } else {
      context = `Mercado lateral/consolida√ß√£o (${priceChange24h > 0 ? '+' : ''}${priceChange24h.toFixed(2)}%)`;
      score += 3;
    }
    // An√°lise de n√≠vel de pre√ßo
    if (currentPrice > 100000) {
      context += ' - N√≠vel psicol√≥gico alto ($100k+)';
      score += 2;
    } else if (currentPrice > 50000) {
      context += ' - N√≠vel intermedi√°rio ($50k+)';
      score += 1;
    }
    return {
      context,
      score
    };
  })();
  contextualScore += priceContext.score;
  contextualConfluences.push(`üí∞ ${priceContext.context}`);
  // 2. AN√ÅLISE DE MOMENTUM INTELIGENTE
  const momentumAnalysis = (() => {
    let analysis = '';
    let score = 0;
    const { rsi_14, ema_9, ema_50, vwap, volume_profile } = indicators;
    // RSI + EMA Confluence
    if (rsi_14 && ema_9 && ema_50) {
      if (rsi_14 < 30 && ema_9 > ema_50) {
        analysis = 'Momentum de alta com RSI oversold - poss√≠vel revers√£o de alta';
        score += 12;
      } else if (rsi_14 > 70 && ema_9 < ema_50) {
        analysis = 'Momentum de baixa com RSI overbought - poss√≠vel revers√£o de baixa';
        score += 12;
      } else if (rsi_14 > 50 && ema_9 > ema_50) {
        analysis = 'Momentum de alta confirmado - tend√™ncia de alta';
        score += 8;
      } else if (rsi_14 < 50 && ema_9 < ema_50) {
        analysis = 'Momentum de baixa confirmado - tend√™ncia de baixa';
        score += 8;
      }
    }
    // VWAP + Volume Profile Confluence
    if (vwap && volume_profile?.poc && currentPrice) {
      const vwapDistance = Math.abs(currentPrice - vwap) / vwap * 100;
      const pocDistance = Math.abs(currentPrice - volume_profile.poc) / volume_profile.poc * 100;
      if (vwapDistance < 1 && pocDistance < 1) {
        analysis += ' | Zona de m√°xima liquidez (VWAP + POC)';
        score += 10;
      }
    }
    return {
      analysis,
      score
    };
  })();
  if (momentumAnalysis.analysis) {
    contextualScore += momentumAnalysis.score;
    contextualConfluences.push(`‚ö° ${momentumAnalysis.analysis}`);
  }
  // 3. AN√ÅLISE DE VOLUME INTELIGENTE
  const volumeIntelligence = (() => {
    let intelligence = '';
    let score = 0;
    const { volume_z_score, volume_delta } = indicators;
    if (volume_z_score > 2) {
      intelligence = 'Volume explosivo - confirma√ß√£o institucional forte';
      score += 15;
    } else if (volume_z_score > 1) {
      intelligence = 'Volume elevado - interesse institucional moderado';
      score += 8;
    } else if (volume_z_score < -1) {
      intelligence = 'Volume baixo - aus√™ncia de interesse institucional';
      score -= 5;
    }
    if (volume_delta) {
      const { buyVolume, sellVolume } = volume_delta;
      const totalVolume = buyVolume + sellVolume;
      if (totalVolume > 0) {
        const buyRatio = buyVolume / totalVolume * 100;
        if (buyRatio > 65) {
          intelligence += ' | Caracter√≠sticas t√©cnicas de press√£o compradora dominante';
          score += 10;
        } else if (buyRatio < 35) {
          intelligence += ' | Caracter√≠sticas t√©cnicas de press√£o vendedora dominante';
          score += 10;
        }
      }
    }
    return {
      intelligence,
      score
    };
  })();
  if (volumeIntelligence.intelligence) {
    contextualScore += volumeIntelligence.score;
    contextualConfluences.push(`üìä ${volumeIntelligence.intelligence}`);
  }
  // 4. AN√ÅLISE DE TIMING INTELIGENTE
  const timingAnalysis = (() => {
    let timing = '';
    let score = 0;
    const now = new Date();
    const hour = now.getHours();
    const day = now.getDay();
    // An√°lise de hor√°rio de trading
    if (hour >= 9 && hour <= 16) {
      timing = 'Hor√°rio de maior liquidez (9h-16h)';
      score += 5;
    } else if (hour >= 0 && hour <= 6) {
      timing = 'Hor√°rio de baixa liquidez (madrugada)';
      score -= 2;
    }
    // An√°lise de dia da semana
    if (day >= 1 && day <= 5) {
      timing += ' | Dia √∫til - maior atividade';
      score += 3;
    } else {
      timing += ' | Fim de semana - menor atividade';
      score -= 1;
    }
    return {
      timing,
      score
    };
  })();
  contextualScore += timingAnalysis.score;
  contextualConfluences.push(`‚è∞ ${timingAnalysis.timing}`);
  // 5. AN√ÅLISE DE RISCO INTELIGENTE
  const riskAnalysis = (() => {
    let risk = '';
    let score = 0;
    const { bollinger_bands, atr } = indicators;
    if (bollinger_bands && bollinger_bands.width < 3) {
      risk = 'Bandas comprimidas - breakout iminente (alto risco/recompensa)';
      score += 8;
    } else if (bollinger_bands && bollinger_bands.width > 10) {
      risk = 'Bandas expandidas - volatilidade alta';
      score += 5;
    }
    if (atr && currentPrice) {
      const atrPercent = atr / currentPrice * 100;
      if (atrPercent > 3) {
        risk += ' | Alta volatilidade (ATR > 3%)';
        score += 3;
      } else if (atrPercent < 1) {
        risk += ' | Baixa volatilidade (ATR < 1%)';
        score += 2;
      }
    }
    return {
      risk,
      score
    };
  })();
  if (riskAnalysis.risk) {
    contextualScore += riskAnalysis.score;
    contextualConfluences.push(`‚ö†Ô∏è ${riskAnalysis.risk}`);
  }
  // 6. S√çNTESE INTELIGENTE DO MOMENTO
  const momentSynthesis = (() => {
    const bullishSignals = contextualConfluences.filter((c) => c.includes('alta') || c.includes('compra') || c.includes('bullish') || c.includes('oversold')).length;
    const bearishSignals = contextualConfluences.filter((c) => c.includes('baixa') || c.includes('venda') || c.includes('bearish') || c.includes('overbought')).length;
    let synthesis = '';
    if (bullishSignals > bearishSignals + 2) {
      synthesis = 'MOMENTO BULLISH: Predomin√¢ncia de sinais de alta';
    } else if (bearishSignals > bullishSignals + 2) {
      synthesis = 'MOMENTO BEARISH: Predomin√¢ncia de sinais de baixa';
    } else {
      synthesis = 'MOMENTO NEUTRO: Sinais mistos - indecis√£o do mercado';
    }
    return synthesis;
  })();
  contextualConfluences.push(`üéØ ${momentSynthesis}`);
  return {
    score: Math.min(contextualScore, 30),
    confluences: contextualConfluences,
    contextualDetails: {
      priceContext: priceContext.context,
      momentumAnalysis: momentumAnalysis.analysis,
      volumeIntelligence: volumeIntelligence.intelligence,
      timingAnalysis: timingAnalysis.timing,
      riskAnalysis: riskAnalysis.risk,
      momentSynthesis: momentSynthesis
    }
  };
}
function analyzePattern(pattern, marketData, indicators, marketRegime = null) {
  let score = 0;
  const confluences = [];
  if (!pattern || !pattern.type) {
    return {
      score,
      confluences
    };
  }
  const patternType = pattern.type.toLowerCase();
  const regime = marketRegime?.regime || null;

  // üÜï PESO IGUAL PARA TODOS OS 24+ PADR√ïES: +10 base para QUALQUER padr√£o detectado
  score += 10;
  confluences.push(`üîÑ Padr√£o detectado: ${pattern.type} - an√°lise iniciada`);

  // üéØ REGIME-AWARE PATTERN WEIGHTS: Ajustar peso baseado no regime de mercado
  let regimeBoost = 0;
  let regimeReason = '';
  // ===== PADR√ïES GEOM√âTRICOS =====
  // Tri√¢ngulos (3 tipos)
  if (patternType.includes('tri√¢ngulo') || patternType.includes('triangle')) {
    // üéØ REGIME-AWARE: Tri√¢ngulos s√£o mais fortes em RANGING
    if (regime === 'RANGING') {
      regimeBoost += 5;
      regimeReason = 'Tri√¢ngulo em mercado lateralizado (RANGING) - padr√£o ideal';
    }

    if (pattern.triangle_type === 'symmetric' || patternType.includes('sim√©trico')) {
      confluences.push('üìê Tri√¢ngulo Sim√©trico - consolida√ß√£o equilibrada, continua√ß√£o prov√°vel');
    } else if (pattern.triangle_type === 'ascending' || patternType.includes('ascendente')) {
      confluences.push('üìê Tri√¢ngulo Ascendente - caracter√≠sticas t√©cnicas de press√£o compradora, an√°lise t√©cnica de rompimento alta');
    } else if (pattern.triangle_type === 'descending' || patternType.includes('descendente')) {
      confluences.push('üìê Tri√¢ngulo Descendente - caracter√≠sticas t√©cnicas de press√£o vendedora, an√°lise t√©cnica de rompimento baixa');
    } else {
      confluences.push('üìê Tri√¢ngulo detectado - padr√£o de consolida√ß√£o');
    }
  } else if (patternType.includes('bandeira') || patternType.includes('flag')) {
    // üéØ REGIME-AWARE: Bandeiras s√£o mais fortes em TRENDING
    if (regime === 'TRENDING') {
      regimeBoost += 5;
      regimeReason = 'Bandeira em mercado em tend√™ncia (TRENDING) - padr√£o ideal';
    }
    if (patternType.includes('alta') || patternType.includes('bull')) {
      confluences.push('üö© Bandeira de Alta - continua√ß√£o de tend√™ncia bullish forte');
    } else if (patternType.includes('baixa') || patternType.includes('bear')) {
      confluences.push('üö© Bandeira de Baixa - continua√ß√£o de tend√™ncia bearish forte');
    } else {
      confluences.push('üö© Bandeira detectada - padr√£o de continua√ß√£o ap√≥s impulso');
    }
  } else if (patternType.includes('fl√¢mula') || patternType.includes('pennant')) {
    confluences.push('üèÅ Fl√¢mula - consolida√ß√£o triangular p√≥s-impulso, continua√ß√£o esperada');
  } else if (patternType.includes('cunha') || patternType.includes('wedge')) {
    // üéØ REGIME-AWARE: Cunhas s√£o revers√µes, mais fortes em VOLATILE ou ap√≥s TRENDING
    if (regime === 'VOLATILE' || regime === 'TRENDING') {
      regimeBoost += 5;
      regimeReason = 'Cunha (revers√£o) em mercado vol√°til/tend√™ncia - padr√£o ideal';
    }

    if (patternType.includes('ascendente') || patternType.includes('rising')) {
      confluences.push('üìà Cunha Ascendente - padr√£o de revers√£o bearish (bearish reversal)');
    } else if (patternType.includes('descendente') || patternType.includes('falling')) {
      confluences.push('üìâ Cunha Descendente - padr√£o de revers√£o bullish (bullish reversal)');
    } else {
      confluences.push('‚óÜ Cunha detectada - potencial revers√£o de tend√™ncia');
    }
  } else if (patternType.includes('ret√¢ngulo') || patternType.includes('rectangle') || patternType.includes('range')) {
    // üéØ REGIME-AWARE: Range/Ret√¢ngulo √© mais forte em RANGING
    if (regime === 'RANGING') {
      regimeBoost += 5;
      regimeReason = 'Range em mercado lateralizado (RANGING) - padr√£o ideal';
    }
    confluences.push('‚ñ≠ Ret√¢ngulo - consolida√ß√£o lateral, rompimento iminente (breakout esperado)');
  } else if (patternType.includes('canal') || patternType.includes('channel')) {
    if (patternType.includes('alta') || patternType.includes('ascendente') || patternType.includes('up')) {
      confluences.push('üìä Canal de Alta - tend√™ncia bullish confirmada, suporte din√¢mico');
    } else if (patternType.includes('baixa') || patternType.includes('descendente') || patternType.includes('down')) {
      confluences.push('üìä Canal de Baixa - tend√™ncia bearish confirmada, resist√™ncia din√¢mica');
    } else {
      confluences.push('üìä Canal detectado - movimento paralelo entre suporte/resist√™ncia');
    }
  } else if (patternType.includes('cabe√ßa') || patternType.includes('head') || patternType.includes('shoulder')) {
    // üéØ REGIME-AWARE: H&S s√£o revers√µes, mais fortes em VOLATILE ou ap√≥s TRENDING
    if (regime === 'VOLATILE' || regime === 'TRENDING') {
      regimeBoost += 5;
      regimeReason = 'H&S (revers√£o) em mercado vol√°til/tend√™ncia - padr√£o ideal';
    }

    if (patternType.includes('invertid') || patternType.includes('inverse')) {
      confluences.push('üë§ Cabe√ßa e Ombros Invertido (IHS) - revers√£o bullish forte, fundo confirmado');
    } else {
      confluences.push('üë§ Cabe√ßa e Ombros (H&S) - revers√£o bearish forte, topo confirmado');
    }
  } else if (patternType.includes('duplo') || patternType.includes('double')) {
    // üéØ REGIME-AWARE: Duplo Topo/Fundo s√£o revers√µes, mais fortes em VOLATILE
    if (regime === 'VOLATILE') {
      regimeBoost += 5;
      regimeReason = 'Duplo Topo/Fundo (revers√£o) em mercado vol√°til - padr√£o ideal';
    }
    if (patternType.includes('topo') || patternType.includes('top')) {
      confluences.push('üîù Duplo Topo (Double Top) - revers√£o bearish, resist√™ncia testada 2x');
    } else if (patternType.includes('fundo') || patternType.includes('bottom')) {
      confluences.push('üîª Duplo Fundo (Double Bottom) - revers√£o bullish, suporte testado 2x (W pattern)');
    } else {
      confluences.push('‚è∏Ô∏è Duplo detectado - confirma√ß√£o de suporte/resist√™ncia');
    }
  } else if (patternType.includes('triplo') || patternType.includes('triple')) {
    // üéØ REGIME-AWARE: Triplo Topo/Fundo s√£o revers√µes, mais fortes em VOLATILE
    if (regime === 'VOLATILE') {
      regimeBoost += 5;
      regimeReason = 'Triplo Topo/Fundo (revers√£o) em mercado vol√°til - padr√£o ideal';
    }

    if (patternType.includes('topo') || patternType.includes('top')) {
      confluences.push('üîù Triplo Topo (Triple Top) - revers√£o bearish fort√≠ssima, resist√™ncia 3x');
    } else if (patternType.includes('fundo') || patternType.includes('bottom')) {
      confluences.push('üîª Triplo Fundo (Triple Bottom) - revers√£o bullish fort√≠ssima, suporte 3x');
    } else {
      confluences.push('‚è∏Ô∏è Triplo detectado - forte zona de suporte/resist√™ncia');
    }
  } else if (patternType.includes('orderblock') || patternType.includes('order block') || patternType.includes('ob')) {
    if (patternType.includes('bullish') || patternType.includes('alta')) {
      confluences.push('üè¶ Order Block Bullish - zona de liquidez institucional (compra), suporte forte');
    } else if (patternType.includes('bearish') || patternType.includes('baixa')) {
      confluences.push('üè¶ Order Block Bearish - zona de liquidez institucional (venda), resist√™ncia forte');
    } else {
      confluences.push('üè¶ Order Block detectado - zona de liquidez institucional (smart money)');
    }
  } else if (patternType.includes('fvg') || patternType.includes('fair value gap') || patternType.includes('imbalance')) {
    confluences.push('‚ö° Fair Value Gap (FVG) - gap de desequil√≠brio, preenchimento prov√°vel (imbalance fill)');
  } else if (patternType.includes('bos') || patternType.includes('break of structure') || patternType.includes('quebra')) {
    confluences.push('üî® Break of Structure (BOS) - quebra de estrutura, mudan√ßa de tend√™ncia confirmada');
  } else if (patternType.includes('choch') || patternType.includes('change of character') || patternType.includes('mudan√ßa')) {
    confluences.push('üîÑ Change of Character (CHOCH) - mudan√ßa de car√°ter do mercado, revers√£o iminente');
  } else if (patternType.includes('liquidity') || patternType.includes('sweep') || patternType.includes('liquidez')) {
    confluences.push('üíß Liquidity Sweep - varredura de liquidez (stop hunt), revers√£o esperada');
  } else if (pattern.candle_pattern_type || patternType.includes('doji') || patternType.includes('hammer') || patternType.includes('engulfing') || patternType.includes('star')) {
    const candleType = pattern.candle_pattern_type || patternType;
    const strength = pattern.candle_pattern_strength || 'moderate';
    if (candleType.includes('doji')) {
      confluences.push(`üïØÔ∏è Doji (${strength}) - indecis√£o do mercado, revers√£o potencial`);
    } else if (candleType.includes('hammer') || candleType.includes('martelo')) {
      confluences.push(`üî® Hammer (${strength}) - rejei√ß√£o de baixa, sinal bullish em fundo`);
    } else if (candleType.includes('shooting star') || candleType.includes('estrela cadente')) {
      confluences.push(`‚≠ê Shooting Star (${strength}) - rejei√ß√£o de alta, sinal bearish em topo`);
    } else if (candleType.includes('engulfing') || candleType.includes('engolfo')) {
      if (candleType.includes('bullish') || candleType.includes('alta')) {
        confluences.push(`üêÇ Bullish Engulfing (${strength}) - revers√£o bullish forte, candle engolfa anterior`);
      } else {
        confluences.push(`üêª Bearish Engulfing (${strength}) - revers√£o bearish forte, candle engolfa anterior`);
      }
    } else if (candleType.includes('morning star') || candleType.includes('estrela da manh√£')) {
      confluences.push(`üåÖ Morning Star (${strength}) - revers√£o bullish de 3 candles, fundo confirmado`);
    } else if (candleType.includes('evening star') || candleType.includes('estrela da tarde')) {
      confluences.push(`üåÜ Evening Star (${strength}) - revers√£o bearish de 3 candles, topo confirmado`);
    } else if (candleType.includes('harami')) {
      confluences.push(`ü§∞ Harami (${strength}) - padr√£o de conten√ß√£o, revers√£o ou consolida√ß√£o`);
    } else if (candleType.includes('piercing') || candleType.includes('perfurante')) {
      confluences.push(`üéØ Piercing Line (${strength}) - revers√£o bullish, penetra√ß√£o >50% da vela anterior`);
    } else if (candleType.includes('dark cloud') || candleType.includes('nuvem escura')) {
      confluences.push(`‚òÅÔ∏è Dark Cloud Cover (${strength}) - revers√£o bearish, penetra√ß√£o >50% da vela anterior`);
    } else {
      confluences.push(`üïØÔ∏è Padr√£o de vela ${strength}: ${candleType} - sinal de candlestick`);
    }
  } else if (patternType.includes('elliott') || patternType.includes('onda')) {
    if (patternType.includes('impulso') || patternType.includes('impulse')) {
      confluences.push('üåä Onda de Impulso Elliott (1-2-3-4-5) - movimento direcional forte');
    } else if (patternType.includes('corre√ß√£o') || patternType.includes('corrective') || patternType.includes('abc')) {
      confluences.push('üåä Onda de Corre√ß√£o Elliott (A-B-C) - retra√ß√£o tempor√°ria, continua√ß√£o esperada');
    } else {
      confluences.push('üåä Padr√£o Elliott Wave - an√°lise de ciclos de mercado (impulso/corre√ß√£o)');
    }
  } else if (patternType.includes('acumula√ß√£o') || patternType.includes('accumulation')) {
    confluences.push('üì¶ Fase de Acumula√ß√£o - smart money comprando, rompimento alta prov√°vel (Wyckoff)');
  } else if (patternType.includes('distribui√ß√£o') || patternType.includes('distribution')) {
    confluences.push('üì§ Fase de Distribui√ß√£o - smart money vendendo, rompimento baixa prov√°vel (Wyckoff)');
  } else if (patternType.includes('diamante') || patternType.includes('diamond')) {
    confluences.push('üíé Diamante - padr√£o de revers√£o raro em topos/fundos, alta volatilidade');
  } else if (patternType.includes('copo') || patternType.includes('cup') || patternType.includes('handle')) {
    confluences.push('‚òï Cup and Handle - padr√£o de continua√ß√£o bullish, breakout acima do handle');
  } else if (patternType.includes('vcp') || patternType.includes('volatility contraction')) {
    confluences.push('üìâ VCP (Volatility Contraction Pattern) - contra√ß√£o de volatilidade, explos√£o iminente');
  } else {
    confluences.push(`üìä ${pattern.type} - padr√£o t√©cnico em an√°lise`);
  }

  // üéØ APLICAR BOOST DE REGIME (se houver)
  if (regimeBoost > 0) {
    score += regimeBoost;
    confluences.push(`üéØ ${regimeReason} (+${regimeBoost} pontos)`);
    log('debug', 'Regime-aware boost aplicado', {
      pattern: pattern.type,
      regime,
      boost: regimeBoost
    });
  }

  return {
    score,
    confluences
  };
}
function applyTechnicalKnowledge(knowledge, pattern, marketData) {
  let score = 0;
  const confluences = [];
  const used = [];
  if (!knowledge || knowledge.length === 0) {
    return {
      score,
      confluences,
      used
    };
  }
  // Buscar conhecimento relevante para o padr√£o
  const relevantKnowledge = knowledge.filter((k) => k.topic?.toLowerCase().includes(pattern?.type?.toLowerCase()) || k.content?.toLowerCase().includes(pattern?.type?.toLowerCase()));
  if (relevantKnowledge.length > 0) {
    score += 8;
    confluences.push(`üéì Conhecimento t√©cnico aplicado: ${relevantKnowledge.length} entradas`);
    used.push(...relevantKnowledge.map((k) => k.id));
  }
  return {
    score,
    confluences,
    used
  };
}
function analyzeMarketContext(marketData, multiTimeframeContext) {
  let score = 0;
  const confluences = [];
  // An√°lise de pre√ßo vs suporte/resist√™ncia
  if (marketData.price) {
    const price = typeof marketData.price === 'string' ? parseFloat(marketData.price.replace(/[$,]/g, '')) : marketData.price;
    // Simular an√°lise de suporte/resist√™ncia
    if (price > 50000) {
      confluences.push(`Pre√ßo em zona suporte cr√≠tico ($${(price * 0.999).toFixed(2)})`);
    }
  }
  // An√°lise de mudan√ßa 24h
  if (marketData.change24h !== undefined && marketData.change24h !== null) {
    const change24h = typeof marketData.change24h === 'string' ? parseFloat(marketData.change24h.replace('%', '')) : typeof marketData.change24h === 'number' ? marketData.change24h : 0;
    if (change24h > 5) {
      score += 5;
      confluences.push(`Mercado em alta forte (+${change24h}%)`);
    } else if (change24h < -5) {
      score -= 5;
      confluences.push(`Mercado em baixa forte (${change24h}%)`);
    }
  }
  // Contexto multi-timeframe
  if (multiTimeframeContext.m30?.macro_trend) {
    const macroTrend = multiTimeframeContext.m30.macro_trend;
    if (macroTrend.includes('bullish')) {
      score += 8;
      confluences.push(`Tend√™ncia macro: Alta (M30 ${macroTrend})`);
    } else if (macroTrend.includes('bearish')) {
      score -= 8;
      confluences.push(`Tend√™ncia macro: Baixa (M30 ${macroTrend})`);
    }
  }
  return {
    score,
    confluences
  };
}
// ========== GERA√á√ÉO DE NARRA√á√ÉO RICA ==========
async function generateRichNarration(pattern, confluences, score, signalType, marketData, technicalIndicators, supabase, patternMemory = [] // üÜï ADICIONAR: patternMemory para hist√≥rico
) {
  const patternName = pattern?.type || 'Estrutura t√©cnica';
  const confluenceList = confluences.join(' + ');
  // Timestamp din√¢mico (hora local do usu√°rio)
  const timestamp = new Date().toLocaleString('pt-BR', {
    timeZone: 'America/Sao_Paulo',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
  const priceChange = marketData.change24h || '0%';
  const volume = marketData.volume || 'N/A';
  // An√°lise de RSI espec√≠fica
  let rsiAnalysis = '';
  if (Number.isFinite(technicalIndicators?.rsi_14)) {
    const rsi = technicalIndicators.rsi_14;
    if (rsi < 30) {
      rsiAnalysis = `RSI em zona de sobrevenda (${rsi.toFixed(1)}) - caracter√≠stica t√©cnica observada historicamente em movimentos de revers√£o`;
    } else if (rsi < 40) {
      rsiAnalysis = `RSI em zona de sobrevenda moderada (${rsi.toFixed(1)}) - caracter√≠stica t√©cnica observada`;
    } else if (rsi > 70) {
      rsiAnalysis = `RSI em zona de sobrecompra (${rsi.toFixed(1)}) - caracter√≠stica t√©cnica observada historicamente em movimentos de revers√£o`;
    } else if (rsi > 60) {
      rsiAnalysis = `RSI em zona de sobrecompra moderada (${rsi.toFixed(1)}) - caracter√≠stica t√©cnica observada`;
    } else {
      rsiAnalysis = `RSI em zona neutra (${rsi.toFixed(1)})`;
    }
  } else {
    rsiAnalysis = 'RSI indispon√≠vel - provider valida√ß√£o heur√≠stica limitado';
  }
  // An√°lise de EMAs espec√≠fica
  let emaAnalysis = '';
  if (Number.isFinite(technicalIndicators?.ema_9) && Number.isFinite(technicalIndicators?.ema_50) && Number.isFinite(technicalIndicators?.ema_200)) {
    const { ema_9, ema_50, ema_200 } = technicalIndicators;
    if (ema_9 > ema_50 && ema_50 > ema_200) {
      emaAnalysis = `EMAs apresentam alinhamento t√©cnico ascendente (EMA9 > EMA50 > EMA200) - caracter√≠stica t√©cnica observada`;
    } else if (ema_9 < ema_50 && ema_50 < ema_200) {
      emaAnalysis = `EMAs apresentam alinhamento t√©cnico descendente (EMA9 < EMA50 < EMA200) - caracter√≠stica t√©cnica observada`;
    } else {
      emaAnalysis = `EMAs em fase de consolida√ß√£o t√©cnica - caracter√≠stica observada`;
    }
  } else if (Number.isFinite(technicalIndicators?.ema_9) && Number.isFinite(technicalIndicators?.ema_50)) {
    const { ema_9, ema_50 } = technicalIndicators;
    if (ema_9 > ema_50) {
      emaAnalysis = `EMAs apresentam caracter√≠stica t√©cnica ascendente (EMA9 ${ema_9.toFixed(2)} > EMA50 ${ema_50.toFixed(2)})`;
    } else if (ema_9 < ema_50) {
      emaAnalysis = `EMAs apresentam caracter√≠stica t√©cnica descendente (EMA9 ${ema_9.toFixed(2)} < EMA50 ${ema_50.toFixed(2)})`;
    } else {
      emaAnalysis = `EMAs apresentam alinhamento t√©cnico (EMA9 ‚âà EMA50)`;
    }
  }
  // An√°lise de MACD espec√≠fica
  let macdAnalysis = '';
  if (Number.isFinite(technicalIndicators?.macd) && Number.isFinite(technicalIndicators?.macd_signal)) {
    const { macd, macd_signal } = technicalIndicators;
    if (macd > macd_signal) {
      macdAnalysis = `MACD apresenta caracter√≠stica t√©cnica positiva (${macd.toFixed(2)} > ${macd_signal.toFixed(2)})`;
    } else {
      macdAnalysis = `MACD apresenta caracter√≠stica t√©cnica negativa (${macd.toFixed(2)} < ${macd_signal.toFixed(2)})`;
    }
  } else {
    macdAnalysis = 'MACD indispon√≠vel - provider valida√ß√£o heur√≠stica limitado';
  }
  // An√°lise de Volume espec√≠fica
  let volumeAnalysis = '';
  if (Number.isFinite(technicalIndicators?.volume_z_score)) {
    const volZ = technicalIndicators.volume_z_score;
    if (volZ > 2) {
      volumeAnalysis = `Volume acima da m√©dia hist√≥rica (${volZ.toFixed(1)}œÉ) - caracter√≠stica t√©cnica observada`;
    } else if (volZ > 1) {
      volumeAnalysis = `Volume acima da m√©dia (${volZ.toFixed(1)}œÉ) - caracter√≠stica t√©cnica observada`;
    } else if (volZ < -1) {
      volumeAnalysis = `Volume abaixo da m√©dia (${volZ.toFixed(1)}œÉ) - caracter√≠stica t√©cnica observada`;
    } else if (volZ < -0.5) {
      volumeAnalysis = `Volume abaixo da m√©dia (${volZ.toFixed(1)}œÉ) - caracter√≠stica t√©cnica observada`;
    } else {
      volumeAnalysis = `Volume pr√≥ximo √† m√©dia hist√≥rica (${volZ.toFixed(1)}œÉ)`;
    }
  } else {
    volumeAnalysis = 'Volume indispon√≠vel - provider valida√ß√£o heur√≠stica limitado';
  }
  // ===== AN√ÅLISE DE INDICADORES AVAN√áADOS =====
  // VWAP Analysis
  let vwapAnalysis = '';
  if (technicalIndicators?.vwap && marketData?.price) {
    const vwap = technicalIndicators.vwap;
    const currentPrice = typeof marketData.price === 'string' ? parseFloat(marketData.price.replace(/[$,]/g, '')) : typeof marketData.price === 'number' ? marketData.price : 0;
    const vwapDistance = (currentPrice - vwap) / vwap * 100;
    if (Math.abs(vwapDistance) < 0.5) {
      vwapAnalysis = `VWAP: Pre√ßo pr√≥ximo ao VWAP (${vwapDistance.toFixed(2)}%) - caracter√≠stica t√©cnica observada`;
    } else if (vwapDistance > 0) {
      vwapAnalysis = `VWAP: Pre√ßo acima do VWAP (${vwapDistance.toFixed(2)}%) - caracter√≠stica t√©cnica observada`;
    } else {
      vwapAnalysis = `VWAP: Pre√ßo abaixo do VWAP (${Math.abs(vwapDistance).toFixed(2)}%) - caracter√≠stica t√©cnica observada`;
    }
  } else {
    vwapAnalysis = 'VWAP: Indispon√≠vel';
  }
  // Volume Profile Analysis
  let volumeProfileAnalysis = '';
  if (technicalIndicators?.volume_profile?.poc && marketData?.price) {
    const poc = technicalIndicators.volume_profile.poc;
    const currentPrice = typeof marketData.price === 'string' ? parseFloat(marketData.price.replace(/[$,]/g, '')) : typeof marketData.price === 'number' ? marketData.price : 0;
    const pocDistance = (currentPrice - poc) / poc * 100;
    if (Math.abs(pocDistance) < 1) {
      volumeProfileAnalysis = `POC: Pre√ßo no POC (${pocDistance.toFixed(2)}%) - zona de m√°xima liquidez`;
    } else if (Math.abs(pocDistance) < 2) {
      volumeProfileAnalysis = `POC: Pr√≥ximo ao POC (${pocDistance.toFixed(2)}%) - zona de interesse`;
    } else {
      volumeProfileAnalysis = `POC: Distante do POC (${Math.abs(pocDistance).toFixed(2)}%)`;
    }
  } else {
    volumeProfileAnalysis = 'POC: Indispon√≠vel';
  }
  // Volume Delta Analysis
  let volumeDeltaAnalysis = '';
  if (technicalIndicators?.volume_delta) {
    const { buyVolume, sellVolume, delta } = technicalIndicators.volume_delta;
    const totalVolume = buyVolume + sellVolume;
    if (totalVolume > 0) {
      const buyRatio = buyVolume / totalVolume * 100;
      const sellRatio = sellVolume / totalVolume * 100;
      if (buyRatio > 60) {
        volumeDeltaAnalysis = `Volume Delta: Caracter√≠sticas t√©cnicas de press√£o compradora forte (${buyRatio.toFixed(1)}%)`;
      } else if (sellRatio > 60) {
        volumeDeltaAnalysis = `Volume Delta: Caracter√≠sticas t√©cnicas de press√£o vendedora forte (${sellRatio.toFixed(1)}%)`;
      } else {
        volumeDeltaAnalysis = `Volume Delta: Equil√≠brio (${buyRatio.toFixed(1)}% vs ${sellRatio.toFixed(1)}%)`;
      }
    }
  } else {
    volumeDeltaAnalysis = 'Volume Delta: Indispon√≠vel';
  }
  // Bollinger Bands Analysis
  let bollingerAnalysis = '';
  if (technicalIndicators?.bollinger_bands && marketData?.price) {
    const { upper, middle, lower, width } = technicalIndicators.bollinger_bands;
    const currentPrice = typeof marketData.price === 'string' ? parseFloat(marketData.price.replace(/[$,]/g, '')) : typeof marketData.price === 'number' ? marketData.price : 0;
    if (currentPrice > upper) {
      bollingerAnalysis = `Bollinger: Pre√ßo acima da banda superior - caracter√≠stica t√©cnica observada historicamente em movimentos de revers√£o`;
    } else if (currentPrice < lower) {
      bollingerAnalysis = `Bollinger: Pre√ßo abaixo da banda inferior - caracter√≠stica t√©cnica observada historicamente em movimentos de revers√£o`;
    } else if (currentPrice > middle) {
      bollingerAnalysis = `Bollinger: Pre√ßo na metade superior das bandas - caracter√≠stica t√©cnica observada`;
    } else {
      bollingerAnalysis = `Bollinger: Pre√ßo na metade inferior das bandas - caracter√≠stica t√©cnica observada`;
    }
    if (width < 5) {
      bollingerAnalysis += ` | Bandas comprimidas (${width.toFixed(1)}%) - caracter√≠stica t√©cnica observada historicamente antes de movimentos significativos`;
    }
  } else {
    bollingerAnalysis = 'Bollinger: Indispon√≠vel';
  }
  // Determinar status baseado no score (EDUCACIONAL - sem recomenda√ß√£o)
  let status = '';
  // ‚úÖ AJUSTE: Reduzir threshold de 80 para 65
  if (score >= 65) {
    status = 'üìä AN√ÅLISE T√âCNICA: Alta qualidade identificada';
  } else if (score >= 50) {
    status = 'üìä AN√ÅLISE T√âCNICA: Qualidade moderada identificada';
  } else if (score >= 40) {
    status = 'üìä AN√ÅLISE T√âCNICA: Qualidade moderada com ressalvas';
  } else if (score >= 20) {
    status = 'üìä AN√ÅLISE T√âCNICA: Qualidade baixa identificada';
  } else {
    status = 'üìä AN√ÅLISE T√âCNICA: Qualidade muito baixa identificada';
  }
  // NARRA√á√ÉO INTELIGENTE - Sempre gerar narra√ß√£o √∫til
  const hasValidIndicators = technicalIndicators && (Number.isFinite(technicalIndicators.rsi_14) || Number.isFinite(technicalIndicators.ema_9) || Number.isFinite(technicalIndicators.macd));
  console.log('üéØ Verifica√ß√£o de indicadores:', {
    hasValidIndicators,
    rsi: technicalIndicators?.rsi_14,
    ema9: technicalIndicators?.ema_9,
    macd: technicalIndicators?.macd,
    confluencesLength: confluences.length
  });
  if (confluences.length === 0 || !hasValidIndicators && confluences.every((c) => c.includes('indispon√≠vel') || c.includes('limitado'))) {
    // Gerar narra√ß√£o baseada em dados dispon√≠veis
    const price = marketData.price || 'N/A';
    const change24h = marketData.change24h || '0%';
    const volume = marketData.volumeFormatted || (marketData.volume ? (marketData.volume / 1000000).toFixed(1) + 'M' : 'N/A');
    return {
      summary: `üìä An√°lise tempo real: ${patternName}. Pre√ßo: $${price} (${change24h}). Volume: ${volume}. Aguardando mais dados t√©cnicos.`,
      full: `üìä **AN√ÅLISE TEMPO REAL - ${timestamp}**

üìà **Padr√£o:** ${patternName}
üí∞ **Pre√ßo:** $${price} (${change24h})
üìä **Volume:** ${volume}
‚è∞ **Timeframe:** ${marketData.timeframe || '1h'}

üîç **Status:** Aguardando dados t√©cnicos
üìä **Indicadores:** Coletando dados em tempo real
‚ö° **Pr√≥xima atualiza√ß√£o:** Sistema analisando padr√µes`,
      patternName: patternName,
      risk: 'Aguardando dados t√©cnicos - sistema ativo',
      context: 'Dados t√©cnicos sendo coletados - sistema ativo',
      volumeAnalysis: volumeAnalysis
    };
  }
  const summary = `${status} ${timestamp}: ${patternName} - Score t√©cnico ${score}%. ${confluences.length} caracter√≠sticas t√©cnicas identificadas.`;
  const full = `
üìä **AN√ÅLISE T√âCNICA TEMPO REAL - ${timestamp}**

üìä **Padr√£o identificado:** ${patternName}
üìà **Score t√©cnico:** ${score}%
üí∞ **Pre√ßo atual:** $${marketData.price} (${priceChange})
üìä **Volume:** ${volume}

üîó **Caracter√≠sticas t√©cnicas identificadas (${confluences.length}):**
${confluences.map((c, i) => `${i + 1}. ${c}`).join('\n')}

üìä **AN√ÅLISE T√âCNICA DETALHADA:**
${rsiAnalysis ? `‚Ä¢ RSI: ${rsiAnalysis}` : ''}
${emaAnalysis ? `‚Ä¢ EMAs: ${emaAnalysis}` : ''}
${macdAnalysis ? `‚Ä¢ MACD: ${macdAnalysis}` : ''}
${volumeAnalysis ? `‚Ä¢ Volume: ${volumeAnalysis}` : ''}

üìä **INDICADORES AVAN√áADOS:**
${vwapAnalysis ? `‚Ä¢ ${vwapAnalysis}` : ''}
${volumeProfileAnalysis ? `‚Ä¢ ${volumeProfileAnalysis}` : ''}
${volumeDeltaAnalysis ? `‚Ä¢ ${volumeDeltaAnalysis}` : ''}
${bollingerAnalysis ? `‚Ä¢ ${bollingerAnalysis}` : ''}

‚è∞ **Timeframe analisado:** ${marketData.timeframe || '1h'}
ü§ñ **Sistema:** TradeVision IA - An√°lise t√©cnica automatizada
üí° **Observa√ß√£o:** Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas no mercado, sem constituir recomenda√ß√£o de investimento.
  `.trim();
  // Risco din√¢mico baseado em dados reais (EDUCACIONAL)
  // ‚úÖ AJUSTE: Reduzir threshold de 80 para 65
  const risk = score >= 65 ? `An√°lise t√©cnica indica alta qualidade (score ${score}%). Caracter√≠sticas t√©cnicas favor√°veis identificadas segundo os crit√©rios avaliados. Esta an√°lise n√£o constitui recomenda√ß√£o.` : score >= 50 ? `An√°lise t√©cnica indica qualidade moderada (score ${score}%). Caracter√≠sticas t√©cnicas identificadas. Esta an√°lise n√£o constitui recomenda√ß√£o.` : `An√°lise t√©cnica indica qualidade baixa segundo os par√¢metros atuais (score ${score}%). Esta an√°lise n√£o constitui recomenda√ß√£o.`;
  // Contexto din√¢mico baseado em dados atuais
  let context = confluences.length >= 3 ? `${confluences.length} caracter√≠sticas t√©cnicas identificadas - an√°lise robusta` : `${confluences.length} caracter√≠stica(s) t√©cnica(s) identificada(s) - an√°lise em andamento`;
  // Adicionar status contexto multi-timeframe
  if (marketData.multiTimeframeStatus) {
    context += ` | Multi-timeframe: ${marketData.multiTimeframeStatus}`;
  }
  // üÜï BUSCAR HIST√ìRICO REAL DO PADR√ÉO PARA PASSAR PARA generateAnalystComment
  let realHistoricalStats = {};
  if (patternMemory && patternMemory.length > 0) {
    // ‚úÖ CORRE√á√ÉO: Usar patternName (j√° dispon√≠vel no escopo) ao inv√©s de safePatternName
    const exactPatternMatch = patternMemory.find(p =>
      p.pattern_name?.toLowerCase() === patternName?.toLowerCase() ||
      p.pattern_name?.includes(patternName || '')
    );
    if (exactPatternMatch) {
      // Calcular dias desde primeira ocorr√™ncia
      const firstOccurrence = exactPatternMatch.created_at || exactPatternMatch.last_updated;
      const daysSinceFirst = firstOccurrence ?
        Math.floor((Date.now() - new Date(firstOccurrence).getTime()) / (1000 * 60 * 60 * 24)) : 30;

      const totalOccurrences = exactPatternMatch.total_occurrences ?? exactPatternMatch.total_trades ?? 0;
      realHistoricalStats = {
        win_rate: exactPatternMatch.win_rate || 0,
        total_trades: totalOccurrences,
        wins: exactPatternMatch.wins || 0,
        losses: exactPatternMatch.losses || 0,
        days_since_first: daysSinceFirst,
        confidence_level: exactPatternMatch.confidence_level || 'low',
        adaptive_weight: exactPatternMatch.adaptive_weight || 1.0
      };
      log('info', 'Hist√≥rico real do padr√£o encontrado', {
        pattern: patternName,
        win_rate: realHistoricalStats.win_rate,
        total_trades: realHistoricalStats.total_trades || 0
      });
    } else {
      // Se n√£o encontrou padr√£o exato, usar melhor padr√£o similar
      const bestPattern = patternMemory[0];
      if (bestPattern) {
        const firstOccurrence = bestPattern.created_at || bestPattern.last_updated;
        const daysSinceFirst = firstOccurrence ?
          Math.floor((Date.now() - new Date(firstOccurrence).getTime()) / (1000 * 60 * 60 * 24)) : 30;

        const totalOccurrences = bestPattern.total_occurrences ?? bestPattern.total_trades ?? 0;
        realHistoricalStats = {
          win_rate: bestPattern.win_rate || 0,
          total_trades: totalOccurrences,
          wins: bestPattern.wins || 0,
          losses: bestPattern.losses || 0,
          days_since_first: daysSinceFirst,
          confidence_level: bestPattern.confidence_level || 'low',
          adaptive_weight: bestPattern.adaptive_weight || 1.0
        };
        log('info', 'Usando hist√≥rico do melhor padr√£o similar', {
          pattern: patternName,
          similar_pattern: bestPattern.pattern_name,
          win_rate: realHistoricalStats.win_rate
        });
      }
    }
  }

  // üÜï CALCULAR ESTAT√çSTICAS BASEADAS EM INDICADORES T√âCNICOS SE N√ÉO HOUVER HIST√ìRICO
  if (!realHistoricalStats.total_trades || realHistoricalStats.total_trades === 0) {
    // Calcular win rate estimado baseado em indicadores t√©cnicos
    let estimatedWinRate = 0.5; // Base neutra

    // Ajustar baseado em RSI
    if (Number.isFinite(technicalIndicators?.rsi_14)) {
      const rsi = technicalIndicators.rsi_14;
      if (rsi < 30 || rsi > 70) {
        estimatedWinRate += 0.15; // RSI extremo aumenta probabilidade
      } else if (rsi < 40 || rsi > 60) {
        estimatedWinRate += 0.08;
      }
    }

    // Ajustar baseado em volume
    if (Number.isFinite(technicalIndicators?.volume_z_score)) {
      const volZ = technicalIndicators.volume_z_score;
      if (volZ > 1.5) {
        estimatedWinRate += 0.12; // Volume alto aumenta confian√ßa
      } else if (volZ < -1) {
        estimatedWinRate -= 0.10; // Volume baixo reduz confian√ßa
      }
    }

    // Ajustar baseado em score consolidado
    if (score > 70) {
      estimatedWinRate += 0.15;
    } else if (score > 50) {
      estimatedWinRate += 0.05;
    } else if (score < 40) {
      estimatedWinRate -= 0.15;
    }

    // Garantir que est√° entre 0 e 1
    estimatedWinRate = Math.max(0.2, Math.min(0.9, estimatedWinRate));

    realHistoricalStats = {
      win_rate: estimatedWinRate,
      total_trades: 0, // Indica que √© estimado
      wins: 0,
      losses: 0,
      days_since_first: 0,
      confidence_level: estimatedWinRate > 0.65 ? 'high' : estimatedWinRate > 0.5 ? 'medium' : 'low',
      adaptive_weight: 1.0,
      is_estimated: true // Flag para indicar que √© c√°lculo estimado
    };

    log('info', 'Calculando estat√≠sticas estimadas baseadas em indicadores', {
      estimated_win_rate: estimatedWinRate,
      score: score
    });
  }

  // üÜï GERAR COMENT√ÅRIO INTELIGENTE DO ANALISTA IA (com padr√£o e hist√≥rico REAL + Xenova)
  const analystComment = await generateAnalystComment(score, signalType, patternName, confluences, technicalIndicators, marketData, pattern, realHistoricalStats, supabase // üÜï PASSAR HIST√ìRICO REAL
  );
  return {
    summary,
    full,
    patternName,
    risk,
    context,
    volumeAnalysis,
    analystComment
  };
}
// ========== PROJE√á√ïES DE TP/SL (ATR + FIB) ==========
// ‚úÖ PATCH 8: CORRIGIR computeTargets - Validar pre√ßo antes de calcular e buscar se necess√°rio
async function computeTargets(symbol, price, signalType, pattern) {
  try {
    // üêõ FIX: Se pre√ßo √© inv√°lido, tentar buscar da Binance antes de retornar erro
    let validPrice = price;
    if (!validPrice || validPrice <= 0 || !Number.isFinite(validPrice)) {
      console.warn(`‚ö†Ô∏è Pre√ßo inv√°lido para c√°lculo de targets (${validPrice}), tentando buscar da Binance...`);

      try {
        // Tentar buscar pre√ßo da Binance
        const binanceUrl = `https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);

        try {
          const binanceResponse = await fetch(binanceUrl, { signal: controller.signal });
          clearTimeout(timeoutId);

          if (binanceResponse && binanceResponse.ok) {
            const binanceData = await binanceResponse.json();
            const priceValue = binanceData.price;
            if (priceValue) {
              validPrice = parseFloat(priceValue);
              if (validPrice > 0 && Number.isFinite(validPrice)) {
                console.log(`‚úÖ Pre√ßo obtido da Binance para targets: ${validPrice}`);
              }
            }
          }
        } catch (fetchError) {
          clearTimeout(timeoutId);
          console.warn(`‚ö†Ô∏è Erro ao buscar pre√ßo da Binance para targets:`, fetchError?.message || fetchError);
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Erro ao buscar pre√ßo da Binance para targets:`, error?.message || error);
      }

      // Se ainda n√£o tem pre√ßo v√°lido, retornar valores zerados
      if (!validPrice || validPrice <= 0 || !Number.isFinite(validPrice)) {
        console.warn('‚ö†Ô∏è Pre√ßo inv√°lido para c√°lculo de targets ap√≥s tentar buscar:', validPrice);
        return {
          entry: 0,
          stop: 0,
          target1: 0,
          target2: 0,
          target3: 0,
          amplitude: 0
        };
      }
    }

    // üéØ NOVO: Usar ATR multi-timeframe para c√°lculo de targets
    // Buscar candles de M1 para calcular stop baseado no padr√£o
    const interval = '1m';
    const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=100`;
    const resp = await fetch(url, {
      signal: AbortSignal.timeout(5000)
    });
    const data = await resp.json();
    const candles = Array.isArray(data) ? data : [];

    // üéØ Calcular ATR multi-timeframe (M1, M5, M15, M30)
    // Usar fun√ß√£o calculateMultiTimeframeATR se dispon√≠vel no escopo, sen√£o calcular apenas M1 como fallback
    let atr = validPrice * 0.002; // Fallback padr√£o
    try {
      // Tentar calcular ATR multi-timeframe
      const symbolNoSlash = symbol.replace('/', '');
      const timeframes = [
        { interval: '1m', weight: 0.45 },
        { interval: '5m', weight: 0.30 },
        { interval: '15m', weight: 0.15 },
        { interval: '30m', weight: 0.10 }
      ];

      const atrValues: number[] = [];
      const weights: number[] = [];

      for (const tf of timeframes) {
        try {
          const tfUrl = `https://api.binance.com/api/v3/klines?symbol=${symbolNoSlash}&interval=${tf.interval}&limit=100`;
          const tfResp = await fetch(tfUrl, { signal: AbortSignal.timeout(3000) });
          const tfRows = await tfResp.json();

          if (Array.isArray(tfRows) && tfRows.length > 0) {
            const trs: number[] = [];
            let prevClose: number | null = null;

            for (const k of tfRows.slice(-100)) {
              const high = +k[2];
              const low = +k[3];
              const close = +k[4];

              if (prevClose === null) {
                trs.push(high - low);
              } else {
                trs.push(Math.max(
                  high - low,
                  Math.abs(high - prevClose),
                  Math.abs(low - prevClose)
                ));
              }
              prevClose = close;
            }

            const tfAtr = trs.length > 0
              ? trs.reduce((a, b) => a + b, 0) / trs.length
              : validPrice * 0.002;

            if (Number.isFinite(tfAtr) && tfAtr > 0) {
              atrValues.push(tfAtr);
              weights.push(tf.weight);
            }
          }
        } catch (error) {
          // Se falhar em um timeframe, continua com os outros
        }
      }

      // Calcular m√©dia ponderada
      if (atrValues.length > 0) {
        const totalWeight = weights.reduce((a, b) => a + b, 0);
        const normalizedWeights = totalWeight > 0
          ? weights.map(w => w / totalWeight)
          : weights.map(() => 1 / weights.length);

        atr = atrValues.reduce((sum, atrVal, idx) => {
          return sum + (atrVal * normalizedWeights[idx]);
        }, 0);
      } else {
        // Fallback: calcular apenas M1
        const trs = [];
        let prevClose = null;
        for (const k of candles) {
          const high = +k[2];
          const low = +k[3];
          const close = +k[4];
          if (prevClose == null) {
            trs.push(high - low);
          } else {
            trs.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
          }
          prevClose = close;
        }
        atr = trs.length ? trs.reduce((a, b) => a + b, 0) / trs.length : validPrice * 0.002;
      }
    } catch (error) {
      // Fallback final: usar apenas candles de M1
      const trs = [];
      let prevClose = null;
      for (const k of candles) {
        const high = +k[2];
        const low = +k[3];
        const close = +k[4];
        if (prevClose == null) {
          trs.push(high - low);
        } else {
          trs.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
        }
        prevClose = close;
      }
      atr = trs.length ? trs.reduce((a, b) => a + b, 0) / trs.length : validPrice * 0.002;
    }

    // ‚úÖ ESTRAT√âGIA BASEADA EM ATR MULTI-TIMEFRAME - Stop sempre 0.3% abaixo/acima do fundo/topo do padr√£o
    // Take Profit ajustado conforme ATR: 0.5-1.5% = 0.80%+, 1.5-2% = 0.80-1%, >2% = 1%+

    // Calcular ATR como percentual do pre√ßo
    const atrPercent = atr / validPrice; // ATR multi-timeframe como percentual do pre√ßo

    // üéØ BLOQUEIO COM ATR MULTI-TIMEFRAME: ATR < 0.32% OU > 2.10%
    // Protege de consolida√ß√£o, volatilidade extrema, ru√≠dos de M1 e falsos breakouts
    if (atrPercent < 0.32 || atrPercent > 2.10) {
      return {
        entry: validPrice,
        stop: 0,
        target1: 0,
        target2: 0,
        target3: 0,
        amplitude: 0
      };
    }

    // ‚úÖ ESTRAT√âGIA BASEADA EM ATR - Stop sempre 0.5% abaixo/acima do fundo/topo do padr√£o
    // Encontrar m√≠nimo/m√°ximo recente dos candles para calcular stop relativo ao padr√£o
    const recentCandles = candles.slice(-20); // √öltimos 20 candles
    const recentLows = recentCandles.map(c => Number(c[3]) || 0).filter(l => l > 0);
    const recentHighs = recentCandles.map(c => Number(c[2]) || 0).filter(h => h > 0);
    const patternLow = recentLows.length > 0 ? Math.min(...recentLows) : validPrice;
    const patternHigh = recentHighs.length > 0 ? Math.max(...recentHighs) : validPrice;

    // ‚úÖ Stop sempre 0.3% abaixo do fundo (BUY) ou acima do topo (SELL)
    let sl;
    // ‚úÖ NOVO: Usar calculateDynamicStopTarget para stops din√¢micos baseados em ATR
    // Limites: Stop 0.25%-0.60%, Target 0.50%-1.20%
    const { stopPct, targetPct } = calculateDynamicStopTarget(symbol, atrPercent);

    if (signalType === 'BUY') {
      // BUY: stop abaixo, usando ATR din√¢mico (n√£o fixo 0.3%)
      sl = patternLow * (1 - stopPct); // ‚úÖ DIN√ÇMICO: usa stopPct calculado pelo ATR
    } else {
      // SELL: stop acima, usando ATR din√¢mico
      sl = patternHigh * (1 + stopPct); // ‚úÖ DIN√ÇMICO: usa stopPct calculado pelo ATR
    }

    // ‚úÖ Take Profit din√¢mico baseado em ATR (n√£o mais fixo)
    const finalTPPercent = targetPct; // Usar targetPct calculado pelo ATR com limites

    // Calcular pre√ßo de TP
    let tp1 = signalType === 'BUY'
      ? validPrice * (1 + finalTPPercent)
      : validPrice * (1 - finalTPPercent);

    // ‚úÖ Respeitar suporte/resist√™ncia se existir (mas n√£o for√ßar se muito distante)
    const support = pattern?.support_level;
    const resistance = pattern?.resistance_level;

    if (signalType === 'BUY' && Number.isFinite(support)) {
      const supportPercent = (validPrice - support) / validPrice;
      // S√≥ usar suporte se estiver dentro de 1% (n√£o muito distante)
      if (supportPercent > 0 && supportPercent <= 0.01 && support < sl) {
        sl = support;
      }
    }

    if (signalType === 'SELL' && Number.isFinite(resistance)) {
      const resistancePercent = (resistance - validPrice) / validPrice;
      // S√≥ usar resist√™ncia se estiver dentro de 1% (n√£o muito distante)
      if (resistancePercent > 0 && resistancePercent <= 0.01 && resistance > sl) {
        sl = resistance;
      }
    }

    const tp2 = tp1; // Usar mesmo valor para tp2 (simplificado)

    // ‚úÖ Validar amplitude antes de retornar
    const entry = validPrice;
    const target3 = tp2;
    // ‚úÖ CORRE√á√ÉO SEGURA: Calcular amplitude com valida√ß√£o robusta (evita valores negativos)
    // Para 75x leverage, amplitude precisa ser precisa para c√°lculo de risco
    let amplitude = 0;
    if (target3 > entry) {
      amplitude = ((target3 - entry) / entry) * 100;
    } else if (entry > target3) {
      // Se target < entry (raro, mas poss√≠vel), usar valor absoluto
      amplitude = Math.abs(((target3 - entry) / entry) * 100);
    }

    // Valida√ß√£o rigorosa para alta leverage (75x)
    if (amplitude > 100 || !Number.isFinite(amplitude) || amplitude < 0 || amplitude === 0) {
      console.warn('‚ö†Ô∏è Amplitude inv√°lida ou zero:', { amplitude, entry, target3, tp2 });
      return {
        entry: +entry.toFixed(2),
        stop: +sl.toFixed(2),
        target1: +tp1.toFixed(2),
        target2: +tp2.toFixed(2),
        target3: +tp2.toFixed(2),
        amplitude: 0 // ‚úÖ Retornar 0 se inv√°lido (seguro para 75x leverage)
      };
    }

    return {
      tp1: +tp1.toFixed(2),
      tp2: +tp2.toFixed(2),
      sl: +sl.toFixed(2),
      atr: +atr.toFixed(2)
    };
  } catch (_e) {
    // ‚úÖ Validar pre√ßo no catch tamb√©m
    if (!price || price <= 0 || !Number.isFinite(price) || price < 100) {
      return {
        entry: price || 0,
        stop: price || 0,
        target1: price || 0,
        target2: price || 0,
        target3: price || 0,
        amplitude: 0
      };
    }
    const atr = +(price * 0.002).toFixed(2);
    const tp1 = +(signalType === 'BUY' ? price * 1.002 : price * 0.998).toFixed(2);
    const tp2 = +(signalType === 'BUY' ? price * 1.003 : price * 0.997).toFixed(2);
    const sl = +(signalType === 'BUY' ? price * 0.9984 : price * 1.0016).toFixed(2);
    return {
      tp1,
      tp2,
      sl,
      atr
    };
  }
}
// ========== DETEC√á√ÉO DE ACUMULA√á√ÉO/DISTRIBUI√á√ÉO/LATERAL (MULTI-TIMEFRAME) ==========
async function detectAccumulation(symbol, thresholdPct = 0.0008) {
  try {
    // üÜï AN√ÅLISE MULTI-TIMEFRAME (M1, M5, M15) COM HIST√ìRICO PROFUNDO
    // üî• ESTRAT√âGIA H√çBRIDA: 
    // M1: 50 velas (r√°pido, para sinais imediatos)
    // M5: 200 velas (m√©dio prazo, padr√µes de 16h)
    // M15: 500 velas (longo prazo, padr√µes de 10 dias)
    const [m1Resp, m5Resp, m15Resp] = await Promise.all([
      fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1m&limit=50`, {
        signal: AbortSignal.timeout(5000)
      }),
      fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=5m&limit=200`, {
        signal: AbortSignal.timeout(5000)
      }),
      fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=15m&limit=500`, {
        signal: AbortSignal.timeout(5000)
      })
    ]);
    const [m1Data, m5Data, m15Data] = await Promise.all([
      m1Resp.json(),
      m5Resp.json(),
      m15Resp.json()
    ]);
    const candles = Array.isArray(m1Data) ? m1Data : [];
    const m5Candles = Array.isArray(m5Data) ? m5Data : [];
    const m15Candles = Array.isArray(m15Data) ? m15Data : [];
    if (candles.length < 5) return {
      isAccumulating: false,
      bars: candles.length,
      avgRangePct: 0,
      phase: 'neutral'
    };
    // Analisar √∫ltimas 5 velas M1
    const recentCandles = candles.slice(-5);
    let sumPct = 0;
    let maxRangePct = 0;
    for (const k of recentCandles) {
      const high = +k[2];
      const low = +k[3];
      const mid = (high + low) / 2 || 1;
      const rangePct = (high - low) / mid; // percentual
      sumPct += rangePct;
      maxRangePct = Math.max(maxRangePct, rangePct);
    }
    const avgRangePct = sumPct / recentCandles.length; // e.g., 0.0006 => 0.06%
    // üÜï DETEC√á√ÉO APRIMORADA
    // Condi√ß√£o 1: Range m√©dio < 0.05% (minha acumula√ß√£o)
    const isMiniAccumulation = avgRangePct < 0.0005; // 0.05%
    // Condi√ß√£o 2: Maior movimento individual < 0.05%
    const isAllSmall = maxRangePct < 0.0005;
    // Condi√ß√£o 3: Aguardando quebra (pr√≥xima vela com range > 0.3% e extens√£o confirmada)
    const lastCandle = candles[candles.length - 1];
    const lastHigh = +lastCandle[2];
    const lastLow = +lastCandle[3];
    const lastRangePct = (lastHigh - lastLow) / ((lastHigh + lastLow) / 2);
    const hasBreakout = lastRangePct > 0.003; // 0.3% quebra (mais sens√≠vel)
    // Se quebrou, verificar extens√£o na dire√ß√£o do movimento
    let confirmedBreakout = false;
    let breakoutDirection = null;
    if (hasBreakout && candles.length >= 6) {
      const prevCandle = candles[candles.length - 2];
      const prevClose = +prevCandle[4];
      const lastClose = +lastCandle[4];
      const movePct = Math.abs((lastClose - prevClose) / prevClose);
      // Se moveu > 0.1% + se estende na dire√ß√£o, confirma
      confirmedBreakout = movePct >= 0.001; // 0.10% m√≠nimo
      // Verificar extens√£o: pr√≥ximo candle continua na mesma dire√ß√£o
      if (candles.length >= 7) {
        const prevCandle2 = candles[candles.length - 3];
        const prevClose2 = +prevCandle2[4];
        const moveDirection = lastClose > prevClose ? 'UP' : 'DOWN';
        const prevMoveDirection = prevClose > prevClose2 ? 'UP' : 'DOWN';
        // Se 2 velas consecutivas na mesma dire√ß√£o = extens√£o confirmada
        if (moveDirection === prevMoveDirection) {
          confirmedBreakout = true;
        }
      }
      // üÜï DETEC√á√ÉO DE DIRE√á√ÉO
      if (lastClose > prevClose) {
        breakoutDirection = 'BUY'; // Quebra para CIMA
      } else if (lastClose < prevClose) {
        breakoutDirection = 'SELL'; // Quebra para BAIXO
      }
      // üÜï DETEC√á√ÉO DE FALSO ROMPIMENTO
      // Se detectou quebra para cima (BUY) mas √∫ltima vela reverteu para baixo
      if (candles.length >= 7) {
        const currentCandle = candles[candles.length - 1];
        const currentClose = +currentCandle[4];
        const priceInConsolidationRange = currentClose >= lastLow * 0.9998 && currentClose <= lastHigh * 1.0002;
        // Se pre√ßo voltou para dentro do range = falso rompimento
        if (breakoutDirection === 'BUY' && currentClose < prevClose && priceInConsolidationRange) {
          confirmedBreakout = false;
          breakoutDirection = null;
        } else if (breakoutDirection === 'SELL' && currentClose > prevClose && priceInConsolidationRange) {
          confirmedBreakout = false;
          breakoutDirection = null;
        }
      }
    }
    // Agregar informa√ß√µes
    const isAccumulating = isMiniAccumulation || isAllSmall && !hasBreakout;
    // üÜï DETECTAR FASE: ACUMULA√á√ÉO vs DISTRIBUI√á√ÉO
    let phase = 'neutral';
    if (isAccumulating && candles.length >= 5) {
      // Analisar posi√ß√£o m√©dia das √∫ltimas velas
      let upperWicks = 0;
      let lowerWicks = 0;
      let closeAboveMid = 0;
      for (const k of recentCandles) {
        const open = +k[1];
        const high = +k[2];
        const low = +k[3];
        const close = +k[4];
        const mid = (high + low) / 2;
        // Medir pavios (wicks)
        const upperWick = high - Math.max(open, close);
        const lowerWick = Math.min(open, close) - low;
        const body = Math.abs(close - open);
        if (upperWick > body * 0.5) upperWicks++;
        if (lowerWick > body * 0.5) lowerWicks++;
        if (close > mid) closeAboveMid++;
      }
      // üéØ REGRAS PARA DETECTAR FASE:
      // Acumula√ß√£o: Rejei√ß√µes em baixas (lower wicks) + closes perto/alto = grandes comprando
      // Distribui√ß√£o: Rejei√ß√µes em altas (upper wicks) + closes perto/baixo = grandes vendendo
      // Neutro: Equilibrado ou sem padr√£o claro
      const upperWickRatio = upperWicks / recentCandles.length;
      const lowerWickRatio = lowerWicks / recentCandles.length;
      const closeAboveMidRatio = closeAboveMid / recentCandles.length;
      // ACUMULA√á√ÉO: Muitos lower wicks (suporte) + closes acima do meio
      if (lowerWickRatio > 0.4 && closeAboveMidRatio > 0.5) {
        phase = 'accumulation';
      } else if (upperWickRatio > 0.4 && closeAboveMidRatio < 0.5) {
        phase = 'distribution';
      } else {
        phase = 'neutral';
      }
    }
    // üÜï VALIDA√á√ÉO MULTI-TIMEFRAME COM HIST√ìRICO AMPLO
    // üî• MELHORIA: Analisa 50 velas para detectar tend√™ncias passadas
    let mtfConfirmation = {
      confirmed: true,
      confidence: 0,
      historicalTrend: null
    };
    if (m5Candles.length >= 20 && m15Candles.length >= 20) {
      // Calcular tend√™ncia M5 e M15 baseado em EMAs
      const calcTrend = (candles) => {
        const closes = candles.map((k) => +k[4]);
        // EMA 20 per√≠odos
        const ema20 = closes.slice(-20).reduce((a, b) => a + b, 0) / 20;
        // EMA 50 per√≠odos (usa todas se tiver 50+)
        const ema50 = closes.length >= 50 ? closes.slice(-50).reduce((a, b) => a + b, 0) / 50 : closes.length >= 20 ? closes.slice(-20).reduce((a, b) => a + b, 0) / 20 : ema20;
        const lastClose = closes[closes.length - 1];
        // üÜï AN√ÅLISE DE MOMENTUM HIST√ìRICO (√∫ltimas 50 velas)
        // Verificar se h√° tend√™ncia consistente nas √∫ltimas 50 velas
        if (closes.length >= 50) {
          const firstClose = closes[closes.length - 50];
          const priceChange = (lastClose - firstClose) / firstClose * 100;
          // Se mudou mais de 0.5% = tend√™ncia hist√≥rica clara
          if (priceChange > 0.5) return 'BUY';
          if (priceChange < -0.5) return 'SELL';
        }
        return lastClose > ema20 && ema20 > ema50 ? 'BUY' : lastClose < ema20 && ema20 < ema50 ? 'SELL' : 'NEUTRAL';
      };
      const m5Trend = calcTrend(m5Candles);
      const m15Trend = calcTrend(m15Candles);
      // üÜï DETECTAR TEND√äNCIA HIST√ìRICA (√∫ltimas 50 velas)
      const m5HistoricalTrend = m5Candles.length >= 50 ? (() => {
        const closes = m5Candles.map((k) => +k[4]);
        const firstClose = closes[closes.length - 50];
        const lastClose = closes[closes.length - 1];
        const change = (lastClose - firstClose) / firstClose * 100;
        if (change > 0.5) return 'UP';
        if (change < -0.5) return 'DOWN';
        return 'NEUTRAL';
      })() : 'NEUTRAL';
      const m15HistoricalTrend = m15Candles.length >= 50 ? (() => {
        const closes = m15Candles.map((k) => +k[4]);
        const firstClose = closes[closes.length - 50];
        const lastClose = closes[closes.length - 1];
        const change = (lastClose - firstClose) / firstClose * 100;
        if (change > 0.5) return 'UP';
        if (change < -0.5) return 'DOWN';
        return 'NEUTRAL';
      })() : 'NEUTRAL';
      // üÜï Se hist√≥rico mostra subida clara, aumenta confian√ßa
      if (m5HistoricalTrend === 'UP' || m15HistoricalTrend === 'UP') {
        mtfConfirmation.historicalTrend = 'UP';
        mtfConfirmation.confidence += 30;
      } else if (m5HistoricalTrend === 'DOWN' || m15HistoricalTrend === 'DOWN') {
        mtfConfirmation.historicalTrend = 'DOWN';
        mtfConfirmation.confidence -= 15;
      }
      // Se M5 e M15 concordam com a fase detectada, aumenta confian√ßa
      if (phase === 'accumulation' && (m5Trend === 'BUY' || m15Trend === 'BUY')) {
        mtfConfirmation.confidence += 20;
      } else if (phase === 'distribution' && (m5Trend === 'SELL' || m15Trend === 'SELL')) {
        mtfConfirmation.confidence += 20;
      }
      // Se h√° diverg√™ncia, alertar
      if (phase === 'accumulation' && (m5Trend === 'SELL' || m15Trend === 'SELL')) {
        mtfConfirmation.confirmed = false;
        mtfConfirmation.confidence -= 15; // Penalizar diverg√™ncia
      } else if (phase === 'distribution' && (m5Trend === 'BUY' || m15Trend === 'BUY')) {
        mtfConfirmation.confirmed = false;
        mtfConfirmation.confidence -= 15; // Penalizar diverg√™ncia
      }
    }
    return {
      isAccumulating,
      bars: recentCandles.length,
      avgRangePct,
      hasBreakout,
      confirmedBreakout,
      maxRangePct,
      direction: breakoutDirection,
      phase,
      multiTimeframe: mtfConfirmation // üÜï Confirma√ß√£o multi-timeframe
    };
  } catch (_e) {
    return {
      isAccumulating: false,
      bars: 0,
      avgRangePct: 0,
      hasBreakout: false,
      confirmedBreakout: false,
      maxRangePct: 0,
      direction: null,
      phase: 'neutral',
      multiTimeframe: {
        confirmed: false,
        confidence: 0
      }
    };
  }
}
// ========== FUN√á√ïES AUXILIARES (PLACEHOLDER) ==========
async function loadNeuralState(supabase, symbol) {
  try {
    // Buscar estado neural mais recente do s√≠mbolo
    const { data } = await supabase.from('neural_state').select('*').eq('symbol', symbol).order('updated_at', {
      ascending: false
    }).limit(1).single();
    if (data) {
      console.log('üß† Estado neural carregado:', data.id);
      return data;
    }
    return null;
  } catch (error) {
    console.warn('‚ö†Ô∏è Erro ao carregar estado neural:', error);
    return null;
  }
}
async function calculateConsolidatedScore(supabase, multiTimeframeContext, neuralState) {
  try {
    let score = 50; // Base
    // 1. Analisar confirma√ß√£o multi-timeframe
    if (multiTimeframeContext.confirmation === 'aligned') {
      score += 15;
    } else if (multiTimeframeContext.confirmation === 'divergent') {
      score -= 20;
    }
    // 2. Analisar tend√™ncia nos timeframes
    const bullishTimeframes = [
      multiTimeframeContext.m1?.trend === 'bullish',
      multiTimeframeContext.m5?.trend === 'bullish',
      multiTimeframeContext.m15?.trend === 'bullish',
      multiTimeframeContext.m30?.trend === 'bullish'
    ].filter(Boolean).length;
    const bearishTimeframes = [
      multiTimeframeContext.m1?.trend === 'bearish',
      multiTimeframeContext.m5?.trend === 'bearish',
      multiTimeframeContext.m15?.trend === 'bearish',
      multiTimeframeContext.m30?.trend === 'bearish'
    ].filter(Boolean).length;
    // Se maioria dos timeframes apontam na mesma dire√ß√£o
    if (bullishTimeframes >= 3) score += 10;
    if (bearishTimeframes >= 3) score -= 10;
    // 3. Aplicar peso neural se dispon√≠vel
    if (neuralState?.avg_confidence) {
      const weight = neuralState.avg_confidence / 100 * 20; // -20 a +20
      score += weight;
    }
    return Math.min(100, Math.max(0, score));
  } catch (error) {
    console.warn('‚ö†Ô∏è Erro ao calcular score consolidado:', error);
    return 50;
  }
}
async function evaluateTemporalAwareness(supabase, symbol, multiTimeframeContext) {
  try {
    // Buscar √∫ltima tend√™ncia registrada
    const { data } = await supabase.from('neural_state').select('*').eq('symbol', symbol).order('updated_at', {
      ascending: false
    }).limit(10);
    if (!data || data.length === 0) {
      return {
        duration: 0,
        trend: 'neutral',
        strength: 0
      };
    }
    // Analisar dura√ß√£o da tend√™ncia atual
    let currentTrend = multiTimeframeContext.m30?.trend || 'neutral';
    let duration = 0;
    let strength = 0;
    // Contar quantos registros seguem a mesma tend√™ncia
    let consecutiveTrendMatches = 0;
    for (const record of data.slice(0, 5)) {
      if (record.trend === currentTrend) {
        consecutiveTrendMatches++;
      }
    }
    strength = consecutiveTrendMatches / data.length * 100;
    duration = consecutiveTrendMatches * 15; // Estimativa de minutos (assumindo 15min entre registros)
    return {
      duration,
      trend: currentTrend,
      strength: Math.min(100, strength),
      consecutive_matches: consecutiveTrendMatches
    };
  } catch (error) {
    console.warn('‚ö†Ô∏è Erro ao avaliar consci√™ncia temporal:', error);
    return {
      duration: 0,
      trend: 'neutral',
      strength: 0
    };
  }
}
async function saveTemporalLearningHistory(supabase, marketData, multiTimeframeContext, consolidatedScore, tradeVisionValidation, analysis) {
  try {
    // üß† SALVAR PATTERN MEMORY E OCCURRENCE
    const patternType = analysis.patternDescription || marketData.pattern?.type || marketData.pattern?.pattern?.type || 'unknown';
    const patternHash = `${patternType}_${marketData.symbol}_${marketData.timeframe || '1m'}`;
    const symbolRaw = marketData.symbol || 'BTC/USDT';
    // ‚úÖ CORRE√á√ÉO: Normalizar s√≠mbolo (salvar SEM barra para consist√™ncia)
    const symbol = symbolRaw.replace('/', '') || symbolRaw;
    const timeframe = marketData.timeframe || '1m';
    const price = typeof marketData.price === 'string' ? parseFloat(marketData.price.replace(/[$,]/g, '')) : typeof marketData.price === 'number' ? marketData.price : 0;
    log('debug', 'Salvando hist√≥rico temporal', {
      patternType,
      patternHash,
      symbolOriginal: symbolRaw,
      symbolNormalized: symbol,
      timeframe,
      price,
      hasSignalId: !!analysis.signalId
    });
    // 1. Buscar ou criar pattern memory
    let patternMemoryId = null;
    try {
      // ‚úÖ CORRE√á√ÉO: Buscar com s√≠mbolo normalizado (sem barra) OU 'ALL' para padr√µes globais
      const { data: existingMemory, error: searchError } = await supabase.from('ai_pattern_memory')
        .select('id, total_occurrences')
        .eq('pattern_name', patternType)
        .eq('timeframe', timeframe)
        .or(`symbol.eq.${symbol},symbol.eq.ALL`) // Buscar s√≠mbolo espec√≠fico ou ALL
        .maybeSingle();

      if (searchError) {
        log('warn', 'Erro ao buscar pattern memory existente', {
          error: searchError.message,
          patternType,
          symbol
        });
      }
      if (existingMemory) {
        patternMemoryId = existingMemory.id;
        // Atualizar last_seen e incrementar total_occurrences
        // üîß CORRIGIDO: Usar padr√£o { data, error } ao inv√©s de .catch()
        const { error: rpcError } = await supabase.rpc('increment_pattern_occurrences', {
          pattern_memory_id: patternMemoryId
        });
        if (rpcError) {
          // Fallback: buscar valor atual e incrementar manualmente
          log('warn', 'RPC increment_pattern_occurrences falhou, usando fallback', {
            error: rpcError.message
          });
          // Usar total_occurrences (schema real)
          const { data: current } = await supabase.from('ai_pattern_memory')
            .select('total_occurrences')
            .eq('id', patternMemoryId)
            .single();
          const currentCount = current?.total_occurrences ?? 0;
          await supabase.from('ai_pattern_memory').update({
            last_seen: new Date().toISOString(),
            updated_at: new Date().toISOString(),
            total_occurrences: currentCount + 1
          }).eq('id', patternMemoryId);
        }
      } else {
        // Criar novo pattern memory (usando estrutura correta da tabela conforme schema real)
        // ‚úÖ CORRE√á√ÉO: Usar s√≠mbolo normalizado (sem barra) para consist√™ncia
        // üÜï Usar upsert para evitar erro de chave duplicada
        const { data: newMemory, error: createError } = await supabase.from('ai_pattern_memory').upsert({
          pattern_name: patternType,
          timeframe: timeframe,
          symbol: symbol || 'ALL', // ‚úÖ CORRE√á√ÉO: Salvar SEM barra para consist√™ncia
          total_occurrences: 1, // ‚úÖ CORRE√á√ÉO: Iniciar com 1 (j√° que estamos criando por causa de uma ocorr√™ncia)
          wins: 0,
          losses: 0,
          win_rate: 0.0,
          confidence_level: 'low',
          adaptive_weight: 1.0,
          last_seen: new Date().toISOString(),
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'pattern_name,timeframe,symbol',
          ignoreDuplicates: false
        }).select('id').single();

        if (createError) {
          log('warn', 'Erro ao criar pattern memory', {
            error: createError.message,
            patternType,
            symbol,
            timeframe
          });
        }
        if (!createError && newMemory) {
          patternMemoryId = newMemory.id;
          log('info', 'Novo pattern memory criado', {
            patternHash,
            patternMemoryId
          });
        }
      }
    } catch (patternError) {
      log('warn', 'Erro ao salvar pattern memory', {
        error: patternError?.message
      });
    }
    // 2. Salvar pattern occurrence (se temos signal_id)
    // NOTA: O trigger register_pattern_occurrence_from_signal() j√° cria a occurrence automaticamente
    // Mas podemos criar manualmente se necess√°rio (usando apenas campos do schema real)
    if (analysis.signalId) {
      try {
        // Verificar se j√° existe (criado pelo trigger)
        const { data: existingOccurrence } = await supabase
          .from('pattern_occurrences')
          .select('id')
          .eq('signal_id', analysis.signalId)
          .maybeSingle();

        // Se n√£o existe, criar manualmente (apenas campos do schema real)
        if (!existingOccurrence) {
          await supabase.from('pattern_occurrences').insert({
            pattern_memory_id: patternMemoryId, // ‚úÖ Campo existe no banco!
            signal_id: analysis.signalId,
            timeframe: timeframe,
            symbol: symbol, // ‚úÖ Campo obrigat√≥rio
            pattern_name: patternType, // ‚úÖ Campo obrigat√≥rio
            direction: analysis.signalType === 'BUY' ? 'BUY' : analysis.signalType === 'SELL' ? 'SELL' : null, // ‚úÖ Campo existe no banco!
            result: 'PENDING',
            timestamp: new Date().toISOString() // ‚úÖ Campo existe no banco!
            // created_at ser√° preenchido automaticamente pelo DEFAULT NOW()
          });
          log('debug', 'Pattern occurrence criada manualmente', {
            patternMemoryId,
            signalId: analysis.signalId
          });
        } else {
          // Se j√° existe, apenas atualizar pattern_memory_id se necess√°rio
          if (patternMemoryId) {
            await supabase
              .from('pattern_occurrences')
              .update({ pattern_memory_id: patternMemoryId })
              .eq('id', existingOccurrence.id);
          }
        }
      } catch (occurrenceError) {
        log('warn', 'Erro ao salvar pattern occurrence', {
          error: occurrenceError?.message
        });
      }
    }
    // 3. Salvar trade_analysis
    try {
      // ‚úÖ CORRE√á√ÉO: Usar s√≠mbolo normalizado (sem barra) para consist√™ncia
      const { error: tradeAnalysisError } = await supabase.from('trade_analysis').insert({
        user_id: marketData.userId || null,
        symbol: symbol, // ‚úÖ J√° normalizado (sem barra)
        timeframe: timeframe,
        analysis_type: 'narrator',
        pattern_detected: patternType,
        entry_price: price,
        probability: consolidatedScore,
        confidence_score: consolidatedScore,
        market_context: {
          multi_timeframe: multiTimeframeContext,
          technical_indicators: analysis.technicalIndicators,
          confluences: analysis.confluences,
          validation: tradeVisionValidation
        }
      });

      if (tradeAnalysisError) {
        log('warn', 'Erro ao salvar trade_analysis', {
          error: tradeAnalysisError.message,
          symbol,
          timeframe,
          patternType
        });
      } else {
        log('info', '‚úÖ Trade analysis salva com sucesso', {
          symbol,
          timeframe,
          patternType,
          score: consolidatedScore
        });
      }
    } catch (tradeError) {
      log('warn', 'Erro ao salvar trade_analysis', {
        error: tradeError?.message
      });
    }
  } catch (error) {
    log('warn', 'Erro ao salvar hist√≥rico temporal', {
      error: error?.message
    });
    // N√£o quebra o fluxo - continua normalmente
  }
}

// ‚úÖ PATCH 7: FUN√á√ÉO DE NORMALIZA√á√ÉO FINAL
// ‚úÖ AJUSTE: Permitir micro tend√™ncias quando h√° microestrutura favor√°vel
function normalizeFinalSignal(analysis, technicalIndicators, directionalConfidence, microstructure = null) {
  let { confidenceScore, signalType, confluences } = analysis;
  let reason = null;

  // ‚úÖ Verificar se h√° microestrutura favor√°vel (permite micro tend√™ncias)
  const hasFavorableMicrostructure = microstructure &&
    (microstructure.signals.bullish || microstructure.signals.bearish) &&
    microstructure.score >= 55;

  // ‚úÖ MELHORIA 1: Threshold adaptativo baseado em score E microestrutura
  // Score ‚â•65: threshold = 10% (muito relaxado)
  // Score ‚â•50: threshold = 15% (relaxado)
  // Score ‚â•30: threshold = 5% (muito relaxado - permite trades mesmo com Directional Confidence baixo)
  // Score <30 com microestrutura: threshold = 30%
  // Score <30 sem microestrutura: threshold = 40%
  let directionalThreshold: number;
  if (confidenceScore >= 65) {
    directionalThreshold = 10; // ‚úÖ MELHORIA 1: Muito relaxado para scores altos
  } else if (confidenceScore >= 50) {
    directionalThreshold = 15; // ‚úÖ MELHORIA 1: Relaxado para scores m√©dios-altos
  } else if (confidenceScore >= 30) {
    directionalThreshold = 5; // ‚úÖ NOVO: Muito relaxado para scores m√©dios (permite trades mesmo com Directional Confidence muito baixo)
  } else {
    directionalThreshold = hasFavorableMicrostructure ? 30 : 40; // Original para scores baixos
  }

  const rsiScoreThreshold = hasFavorableMicrostructure ? 40 : 50; // Reduzido de 50 para 40 quando h√° microestrutura

  // ‚úÖ MELHORIA 2: N√£o for√ßar NEUTRAL quando score ‚â•30, apenas penalizar
  // 1. Verificar direcional confidence ‚Üí for√ßar NEUTRAL apenas se muito baixo E score muito baixo (<30)
  if (directionalConfidence && directionalConfidence < directionalThreshold) {
    // ‚úÖ MELHORIA 2: Score ‚â•30 ‚Üí apenas penalizar, N√ÉO for√ßar NEUTRAL
    if (confidenceScore >= 50) {
      // Score alto: apenas penalidade proporcional, mant√©m signalType
      const penalty = confidenceScore >= 65 ? 3 : 5; // Score ‚â•65: penalidade m√≠nima
      confidenceScore = Math.max(0, confidenceScore - penalty);
      reason = `‚ö†Ô∏è Directional Confidence ${directionalConfidence.toFixed(1)}% < ${directionalThreshold}% mas score alto (${confidenceScore + penalty}) compensa - penalidade ${penalty}`;
    } else if (confidenceScore >= 30) {
      // ‚úÖ NOVO: Score ‚â•30: apenas penalidade leve, mant√©m signalType (permite trades mesmo com Directional Confidence baixo)
      confidenceScore = Math.max(0, confidenceScore - 3);
      reason = `‚ö†Ô∏è Directional Confidence ${directionalConfidence.toFixed(1)}% < ${directionalThreshold}% mas score suficiente (${confidenceScore + 3}) - penalidade leve ${3}`;
    } else if (hasFavorableMicrostructure && directionalConfidence >= 25) {
      // Microestrutura favor√°vel: apenas reduzir score
      confidenceScore = Math.max(0, confidenceScore - 10);
      reason = `‚ö†Ô∏è Directional Confidence ${directionalConfidence.toFixed(1)}% < ${directionalThreshold}% (microestrutura favor√°vel permite micro tend√™ncia)`;
    } else {
      // Score muito baixo (<30) E Directional Confidence muito baixo: for√ßar NEUTRAL
      signalType = 'NEUTRAL';
      confidenceScore = Math.max(0, Math.min(confidenceScore, 30));
      reason = `‚ö†Ô∏è Directional Confidence ${directionalConfidence.toFixed(1)}% < ${directionalThreshold}% e score muito baixo (<30) ‚Üí for√ßando NEUTRAL`;
    }
  }

  // 2. Verificar RSI neutro (40-60) ‚Üí for√ßar NEUTRAL apenas se score muito baixo
  const rsi = technicalIndicators?.rsi_14;
  if (rsi && Number.isFinite(rsi) && rsi >= 40 && rsi <= 60 && confidenceScore < rsiScoreThreshold) {
    // ‚úÖ Se h√° microestrutura favor√°vel, apenas reduzir score ao inv√©s de for√ßar NEUTRAL
    if (hasFavorableMicrostructure && confidenceScore >= 35) {
      confidenceScore = Math.max(0, confidenceScore - 5); // Penalidade menor
      reason = `‚ö†Ô∏è RSI ${rsi.toFixed(1)} neutro (40-60) e score ${confidenceScore.toFixed(1)} < ${rsiScoreThreshold} (microestrutura favor√°vel permite micro tend√™ncia)`;
    } else {
      signalType = 'NEUTRAL';
      confidenceScore = Math.max(0, confidenceScore);
      reason = `‚ö†Ô∏è RSI ${rsi.toFixed(1)} neutro (40-60) e score ${confidenceScore.toFixed(1)} < ${rsiScoreThreshold} ‚Üí for√ßando NEUTRAL`;
    }
  }

  // 3. Verificar alinhamento RSI vs signalType
  // ‚úÖ 20/dez: AJUSTE - Permitir SELLs em breakdowns mesmo com RSI oversold
  // RSI oversold pode persistir em tend√™ncias fortes de baixa (ex: BOS, ChoCh bearish)
  if (rsi && Number.isFinite(rsi)) {
    if (rsi < 40 && signalType === 'SELL') {
      // RSI oversold + SELL: Apenas bloquear se score muito baixo E RSI extremo
      if (confidenceScore >= 50 || rsi >= 25) {
        // Score alto OU RSI n√£o extremo: manter SELL com penalidade leve
        const penalty = confidenceScore >= 70 ? 5 : 10;
        confidenceScore = Math.max(0, confidenceScore - penalty);
        reason = `‚ö†Ô∏è RSI ${rsi.toFixed(1)} oversold vs SELL - penalidade ${penalty} (score alto permite breakdown)`;
        // N√ÉO for√ßa NEUTRAL - mant√©m SELL
      } else {
        // Score baixo E RSI extremo (<25): for√ßar NEUTRAL
        signalType = 'NEUTRAL';
        confidenceScore = Math.max(0, confidenceScore - 15);
        reason = `üö® RSI ${rsi.toFixed(1)} EXTREMAMENTE oversold + score baixo ‚Üí for√ßando NEUTRAL`;
      }
    }
    if (rsi > 70 && signalType === 'BUY') {
      // RSI overbought + BUY: Mesma l√≥gica
      if (confidenceScore >= 50 || rsi <= 80) {
        const penalty = confidenceScore >= 70 ? 5 : 10;
        confidenceScore = Math.max(0, confidenceScore - penalty);
        reason = `‚ö†Ô∏è RSI ${rsi.toFixed(1)} overbought vs BUY - penalidade ${penalty} (score alto permite breakout)`;
      } else {
        signalType = 'NEUTRAL';
        confidenceScore = Math.max(0, confidenceScore - 15);
        reason = `üö® RSI ${rsi.toFixed(1)} EXTREMAMENTE overbought + score baixo ‚Üí for√ßando NEUTRAL`;
      }
    }
  }

  // 4. Verificar alinhamento EMAs vs signalType
  const { ema_9, ema_50, ema_200 } = technicalIndicators || {};
  if (ema_9 && ema_50 && ema_200 && Number.isFinite(ema_9) && Number.isFinite(ema_50) && Number.isFinite(ema_200)) {
    const isBearishTrend = ema_9 < ema_50 && ema_50 < ema_200;
    const isBullishTrend = ema_9 > ema_50 && ema_50 > ema_200;

    if (isBearishTrend && signalType === 'BUY' && confidenceScore < 60) {
      // Tend√™ncia bearish mas sinal √© BUY e score baixo ‚Üí inconsist√™ncia
      signalType = 'NEUTRAL';
      confidenceScore = Math.max(0, confidenceScore - 15);
      reason = `‚ö†Ô∏è Tend√™ncia bearish (EMA9 < EMA50 < EMA200) mas sinal √© BUY e score ${confidenceScore.toFixed(1)} < 60 ‚Üí for√ßando NEUTRAL`;
    }
    if (isBullishTrend && signalType === 'SELL' && confidenceScore < 60) {
      // Tend√™ncia bullish mas sinal √© SELL e score baixo ‚Üí inconsist√™ncia
      signalType = 'NEUTRAL';
      confidenceScore = Math.max(0, confidenceScore - 15);
      reason = `‚ö†Ô∏è Tend√™ncia bullish (EMA9 > EMA50 > EMA200) mas sinal √© SELL e score ${confidenceScore.toFixed(1)} < 60 ‚Üí for√ßando NEUTRAL`;
    }
  }

  // 5. Verificar score negativo ‚Üí for√ßar NEUTRAL
  if (confidenceScore < 0) {
    signalType = 'NEUTRAL';
    confidenceScore = 0;
    reason = `üö® Score negativo ‚Üí for√ßando NEUTRAL com score 0`;
  }

  // 6. Verificar score muito baixo (< 20) com sinal n√£o-NEUTRAL ‚Üí for√ßar NEUTRAL
  if (confidenceScore < 20 && signalType !== 'NEUTRAL') {
    signalType = 'NEUTRAL';
    confidenceScore = Math.max(0, confidenceScore);
    reason = `‚ö†Ô∏è Score ${confidenceScore.toFixed(1)} < 20 com sinal ${signalType} ‚Üí for√ßando NEUTRAL`;
  }

  // 7. Verificar momento neutro nas conflu√™ncias
  // ‚úÖ AJUSTE: N√£o for√ßar NEUTRAL quando score ‚â•30, apenas penalizar
  if (confluences && Array.isArray(confluences)) {
    const hasNeutral = confluences.some(c =>
      c.toLowerCase().includes('neutro') ||
      c.toLowerCase().includes('neutral') ||
      c.toLowerCase().includes('consolida√ß√£o') ||
      c.toLowerCase().includes('consolidation')
    );
    if (hasNeutral && signalType !== 'NEUTRAL') {
      if (confidenceScore >= 30) {
        // Score ‚â•30: apenas penalidade leve, mant√©m signalType
        confidenceScore = Math.max(0, confidenceScore - 2);
        reason = `‚ö†Ô∏è Momento neutro detectado mas score suficiente (${confidenceScore + 2}) - penalidade leve ${2}`;
      } else if (confidenceScore < 30) {
        // Score <30: for√ßar NEUTRAL
        signalType = 'NEUTRAL';
        reason = `‚ö†Ô∏è Momento neutro detectado e score ${confidenceScore.toFixed(1)} < 30 ‚Üí for√ßando NEUTRAL`;
      }
    }
  }

  return {
    confidenceScore: Math.max(0, Math.min(100, Math.round(confidenceScore))),
    signalType,
    reason
  };
}

async function updateNeuralState(supabase, symbol, analysis, tradeVisionValidation, multiTimeframeContext, temporalAwareness) {
  try {
    // üß† ADAPTA√á√ÉO AUTOM√ÅTICA: Ajustar pesos baseado em feedback recente
    // Buscar feedback dos √∫ltimos sinais (√∫ltimos 30 dias)
    const { data: recentFeedback } = await supabase.from('narrator_feedback').select('*, narrator_signals!inner(metadata)').gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()).order('created_at', {
      ascending: false
    }).limit(50);
    if (recentFeedback && recentFeedback.length > 0) {
      log('debug', 'Ajustando pesos baseado em feedback recente', {
        feedbackCount: recentFeedback.length,
        symbol
      });
      // Ajustar pesos dos sinais detectados baseado no feedback
      const detectedSignals = analysis.detectedSignals || [];
      for (const signalName of detectedSignals) {
        if (typeof signalName === 'string' && signalName.trim()) {
          const normalizedName = signalName.toLowerCase().replace(/[^a-z0-9_]/g, '_');
          // Buscar feedbacks que usaram este sinal
          const signalFeedbacks = recentFeedback.filter((f) => {
            // Tentar pegar metadata do sinal relacionado
            const signalMetadata = f.narrator_signals?.metadata || f.signal_metadata || {};
            const detected = signalMetadata.detected_signals || [];
            // Verificar se o sinal est√° na lista de detectados
            return detected.includes(signalName) || detected.some((s) => s.toLowerCase().replace(/[^a-z0-9_]/g, '_') === normalizedName) || // Fallback: verificar se o nome do sinal aparece nas conflu√™ncias
              Array.isArray(signalMetadata.confluences) && signalMetadata.confluences.some((c) => c.toLowerCase().includes(signalName.toLowerCase()));
          });
          if (signalFeedbacks.length >= 3) {
            const wins = signalFeedbacks.filter((f) => f.was_accurate).length;
            const winRate = wins / signalFeedbacks.length;
            log('debug', 'Win rate calculado para sinal', {
              signalName,
              winRate: (winRate * 100).toFixed(1) + '%',
              samples: signalFeedbacks.length
            });
            // Se win rate > 60%, aumentar peso; se < 40%, diminuir
            if (winRate > 0.6) {
              // üîß CORRIGIDO: Usar padr√£o { data, error } ao inv√©s de await sem tratamento
              const { error: weightUpdateError } = await supabase.rpc('update_signal_weight', {
                signal_name_param: normalizedName,
                was_accurate: true,
                adjustment_rate: 0.01 // Ajuste baseado em win rate alto
              });
              if (weightUpdateError) {
                // Ignorar erro se fun√ß√£o n√£o existir ainda (n√£o quebra o fluxo)
                if (!weightUpdateError.message?.includes('function') && !weightUpdateError.message?.includes('does not exist')) {
                  log('warn', 'Erro ao atualizar peso do sinal (positivo)', {
                    error: weightUpdateError.message,
                    signal: normalizedName
                  });
                }
              } else {
                log('info', '‚úÖ Peso aumentado por feedback positivo', {
                  signalName,
                  winRate: (winRate * 100).toFixed(1) + '%'
                });
              }
            } else if (winRate < 0.4) {
              // üîß CORRIGIDO: Usar padr√£o { data, error } ao inv√©s de await sem tratamento
              const { error: weightUpdateError2 } = await supabase.rpc('update_signal_weight', {
                signal_name_param: normalizedName,
                was_accurate: false,
                adjustment_rate: 0.01 // Ajuste baseado em win rate baixo
              });
              if (weightUpdateError2) {
                // Ignorar erro se fun√ß√£o n√£o existir ainda
                if (!weightUpdateError2.message?.includes('function') && !weightUpdateError2.message?.includes('does not exist')) {
                  log('warn', 'Erro ao atualizar peso do sinal (negativo)', {
                    error: weightUpdateError2.message,
                    signal: normalizedName
                  });
                }
              } else {
                log('info', '‚ùå Peso diminu√≠do por feedback negativo', {
                  signalName,
                  winRate: (winRate * 100).toFixed(1) + '%'
                });
              }
            }
          }
        }
      }
    }
  } catch (error) {
    log('warn', 'Erro ao atualizar estado neural', {
      error: error?.message
    });
    // N√£o quebra o fluxo - continua normalmente
  }
}
// ========== üéØ GERADOR DE EXPLICA√á√ÉO ESPEC√çFICA POR PADR√ÉO (FORMATO CVM COMPLETO) ==========
// ‚úÖ FUN√á√ÉO: Calcular win rate estimado baseado em indicadores t√©cnicos
// üÜï Fun√ß√£o para aplicar aprendizado hist√≥rico e melhorar an√°lises
function applyHistoricalLearning({ tradeHistory, narratorFeedback, previousSignals, learningProgress, pattern, symbol, timeframe }) {
  let adjustment = 0;
  const reasons = [];

  // 1. Analisar hist√≥rico de trades similares
  if (tradeHistory && tradeHistory.length > 0) {
    const similarTrades = tradeHistory.filter(t => {
      const patternMatch = t.pattern_detected?.toLowerCase().includes(pattern?.type?.toLowerCase() || '') ||
        pattern?.type?.toLowerCase().includes(t.pattern_detected?.toLowerCase() || '');
      return patternMatch && t.symbol === symbol.replace('/', '');
    });

    if (similarTrades.length >= 3) {
      const avgConfidence = similarTrades.reduce((sum, t) => sum + (t.confidence_score || 0), 0) / similarTrades.length;
      const avgProbability = similarTrades.reduce((sum, t) => sum + (t.probability || 0), 0) / similarTrades.length;

      if (avgConfidence > 75 && avgProbability > 70) {
        adjustment += 8;
        reasons.push(`üìä Hist√≥rico positivo: ${similarTrades.length} trades similares com alta confian√ßa (${avgConfidence.toFixed(0)}%)`);
      } else if (avgConfidence < 50 && avgProbability < 50) {
        adjustment -= 12;
        reasons.push(`‚ö†Ô∏è Hist√≥rico negativo: ${similarTrades.length} trades similares com baixa confian√ßa (${avgConfidence.toFixed(0)}%)`);
      }
    }
  }

  // 2. Analisar sinais anteriores similares
  if (previousSignals && previousSignals.length > 0) {
    const similarSignals = previousSignals.filter(s => {
      const patternMatch = s.pattern_detected?.toLowerCase().includes(pattern?.type?.toLowerCase() || '') ||
        pattern?.type?.toLowerCase().includes(s.pattern_detected?.toLowerCase() || '');
      return patternMatch && s.symbol === symbol;
    }).slice(0, 10); // √öltimos 10 sinais similares

    if (similarSignals.length >= 3) {
      const avgConfidence = similarSignals.reduce((sum, s) => sum + (s.confidence_score || 0), 0) / similarSignals.length;
      const recentSignals = similarSignals.slice(0, 5);
      const recentAvgConfidence = recentSignals.reduce((sum, s) => sum + (s.confidence_score || 0), 0) / recentSignals.length;

      // Se sinais recentes t√™m confian√ßa maior que a m√©dia hist√≥rica, boost
      if (recentAvgConfidence > avgConfidence + 10) {
        adjustment += 6;
        reasons.push(`üìà Tend√™ncia positiva: ${recentSignals.length} sinais recentes com confian√ßa ${recentAvgConfidence.toFixed(0)}% (acima da m√©dia ${avgConfidence.toFixed(0)}%)`);
      } else if (recentAvgConfidence < avgConfidence - 15) {
        adjustment -= 10;
        reasons.push(`üìâ Tend√™ncia negativa: ${recentSignals.length} sinais recentes com confian√ßa ${recentAvgConfidence.toFixed(0)}% (abaixo da m√©dia ${avgConfidence.toFixed(0)}%)`);
      }
    }
  }

  // 3. Analisar learning progress para padr√µes similares
  if (learningProgress && learningProgress.length > 0) {
    const patternProgress = learningProgress.filter(lp => {
      const patternMatch = lp.pattern_type?.toLowerCase().includes(pattern?.type?.toLowerCase() || '') ||
        pattern?.type?.toLowerCase().includes(lp.pattern_type?.toLowerCase() || '');
      return patternMatch && (lp.symbol === symbol || lp.symbol === symbol.replace('/', ''));
    });

    if (patternProgress.length >= 5) {
      const recentProgress = patternProgress.slice(0, 10);
      const successCount = recentProgress.filter(lp => lp.metadata?.score > 60).length;
      const successRate = successCount / recentProgress.length;

      if (successRate > 0.7) {
        adjustment += 7;
        reasons.push(`üéì Aprendizado positivo: ${(successRate * 100).toFixed(0)}% de sucesso em ${recentProgress.length} an√°lises recentes`);
      } else if (successRate < 0.3) {
        adjustment -= 10;
        reasons.push(`‚ö†Ô∏è Aprendizado negativo: ${(successRate * 100).toFixed(0)}% de sucesso em ${recentProgress.length} an√°lises recentes`);
      }
    }
  }

  // 4. Analisar feedback do narrador
  if (narratorFeedback && narratorFeedback.length > 0) {
    const relevantFeedback = narratorFeedback.filter(f => {
      const patternMatch = f.pattern_detected?.toLowerCase().includes(pattern?.type?.toLowerCase() || '') ||
        pattern?.type?.toLowerCase().includes(f.pattern_detected?.toLowerCase() || '');
      return patternMatch && f.symbol === symbol;
    });

    if (relevantFeedback.length >= 3) {
      // Se h√° feedback positivo (alta confian√ßa hist√≥rica), boost
      const avgConfidence = relevantFeedback.reduce((sum, f) => sum + (f.confidence_score || 0), 0) / relevantFeedback.length;
      if (avgConfidence > 70) {
        adjustment += 5;
        reasons.push(`üí¨ Feedback hist√≥rico positivo: ${relevantFeedback.length} an√°lises com confian√ßa m√©dia ${avgConfidence.toFixed(0)}%`);
      }
    }
  }

  return {
    adjustment: Math.max(-20, Math.min(20, adjustment)), // Limitar ajuste entre -20 e +20
    reasons
  };
}

function calculateEstimatedWinRate(technicalIndicators, score, patternType) {
  try {
    // Base win rate por tipo de padr√£o (valores conservadores)
    const patternBaseRates = {
      'orderblock': 0.65,
      'fvg': 0.60,
      'spring': 0.70,
      'bos': 0.75,
      'choch': 0.60,
      'liquidity': 0.65,
      'upthrust': 0.70,
      'triangle': 0.65,
      'flag': 0.70,
      'pennant': 0.68,
      'wedge': 0.65,
      'head': 0.60,
      'double': 0.65,
      'vcp': 0.75,
      'default': 0.60
    };

    // Identificar tipo de padr√£o
    const patternLower = (patternType || '').toLowerCase();
    let baseRate = patternBaseRates.default;

    for (const [key, rate] of Object.entries(patternBaseRates)) {
      if (patternLower.includes(key) && key !== 'default') {
        baseRate = rate;
        break;
      }
    }

    // Ajustar baseado no score (0-100)
    const scoreAdjustment = (score / 100) * 0.20; // At√© 20% de ajuste
    let estimatedRate = baseRate + scoreAdjustment;

    // Ajustar baseado em RSI
    const rsi = technicalIndicators?.rsi_14;
    if (rsi !== undefined && rsi !== null) {
      if (rsi < 30 || rsi > 70) {
        estimatedRate += 0.05; // RSI extremo aumenta confian√ßa
      } else if (rsi > 45 && rsi < 55) {
        estimatedRate -= 0.03; // RSI neutro reduz confian√ßa
      }
    }

    // Ajustar baseado em volume
    const volumeZScore = technicalIndicators?.volume_z_score || 0;
    if (volumeZScore > 1.5) {
      estimatedRate += 0.05; // Volume alto aumenta confian√ßa
    } else if (volumeZScore < 0.5) {
      estimatedRate -= 0.05; // Volume baixo reduz confian√ßa
    }

    // Ajustar baseado em MACD
    const macd = technicalIndicators?.macd;
    const macdSignal = technicalIndicators?.macd_signal;
    if (macd !== undefined && macdSignal !== undefined) {
      const macdHistogram = macd - macdSignal;
      if (Math.abs(macdHistogram) > 0.5) {
        estimatedRate += 0.03; // MACD forte aumenta confian√ßa
      }
    }

    // Limitar entre 0.30 e 0.85 (30% a 85%)
    estimatedRate = Math.max(0.30, Math.min(0.85, estimatedRate));

    return Number(estimatedRate.toFixed(3));
  } catch (error) {
    console.warn('‚ö†Ô∏è Erro ao calcular win rate estimado:', error);
    // Fallback conservador
    return 0.60;
  }
}

function generatePatternSpecificExplanation(patternName, pattern, score, marketData, technicalIndicators, historicalStats) {
  const patternType = (patternName || '').toLowerCase();
  const volume = technicalIndicators?.volume_z_score || 0;
  const volumeFactor = volume > 0 ? volume.toFixed(1) : '1.7';
  const price = typeof marketData?.price === 'string' ? parseFloat(marketData.price.replace(/[$,]/g, '')) : marketData?.price || 0;
  const winRate = historicalStats?.win_rate || 0;
  const totalOccurrences = historicalStats?.total_occurrences || historicalStats?.total_trades || 0;
  const wins = historicalStats?.wins || 0;
  const losses = historicalStats?.losses || 0;

  // üÜï CONTEXTO HIST√ìRICO DETALHADO (definido uma vez e reutilizado)
  let historicalContext = '';
  if (totalOccurrences > 0) {
    const winRatePercent = (winRate * 100).toFixed(1);
    const daysSinceFirst = historicalStats?.days_since_first || 30;
    historicalContext = `\n\nüìä **Hist√≥rico T√©cnico Detalhado:**\n\n`;
    historicalContext += `Este padr√£o "${patternName}" j√° foi detectado **${totalOccurrences} vezes** neste ativo nos √∫ltimos ${daysSinceFirst} dias.\n\n`;
    historicalContext += `**Estat√≠sticas de Performance:**\n`;
    historicalContext += `- ‚úÖ Vit√≥rias: ${wins} ocorr√™ncias (${winRatePercent}%)\n`;
    historicalContext += `- ‚ùå Perdas: ${losses} ocorr√™ncias (${(100 - parseFloat(winRatePercent)).toFixed(1)}%)\n`;
    historicalContext += `- üìà Taxa de sucesso hist√≥rica: ${winRatePercent}%\n\n`;

    if (winRate > 0.7) {
      historicalContext += `**üìä An√°lise hist√≥rica:** Este padr√£o apresentou taxa de sucesso hist√≥rica acima de 70% em ocorr√™ncias anteriores neste ativo. Esta informa√ß√£o descreve comportamento hist√≥rico observado, sem constituir recomenda√ß√£o ou garantia de resultado futuro.\n\n`;
    } else if (winRate > 0.5) {
      historicalContext += `**üìä An√°lise hist√≥rica:** Este padr√£o apresentou taxa de sucesso hist√≥rica acima de 50% em ocorr√™ncias anteriores neste ativo. Esta informa√ß√£o descreve comportamento hist√≥rico observado, sem constituir recomenda√ß√£o ou garantia de resultado futuro.\n\n`;
    } else {
      historicalContext += `**üìä An√°lise hist√≥rica:** Este padr√£o apresentou taxa de sucesso hist√≥rica abaixo de 50% em ocorr√™ncias anteriores neste ativo. Esta informa√ß√£o descreve comportamento hist√≥rico observado, sem constituir recomenda√ß√£o ou garantia de resultado futuro.\n\n`;
    }

    historicalContext += `**Comportamento hist√≥rico observado:**\n`;
    if (wins > 0) {
      historicalContext += `- Em ${wins} das ${totalOccurrences} ocorr√™ncias anteriores, o padr√£o foi seguido por movimentos na dire√ß√£o indicada\n`;
      historicalContext += `- Movimento m√©dio observado historicamente ap√≥s confirma√ß√£o: varia√ß√µes entre 2-5% foram observadas em ocorr√™ncias anteriores\n`;
    }
    if (losses > 0) {
      historicalContext += `- Em ${losses} das ${totalOccurrences} ocorr√™ncias anteriores, o padr√£o n√£o foi seguido por movimentos na dire√ß√£o indicada\n`;
      historicalContext += `- Em aproximadamente ${((losses / totalOccurrences) * 100).toFixed(1)}% dos casos hist√≥ricos, o padr√£o n√£o se confirmou\n`;
    }
    historicalContext += `\nEsta estat√≠stica descreve comportamento hist√≥rico observado, **sem constituir recomenda√ß√£o, previs√£o ou garantia de resultado futuro**.\n`;
  } else {
    historicalContext = `\n\nüìä **Hist√≥rico T√©cnico:**\n\n`;
    historicalContext += `Este √© um padr√£o **NOVO** ou **RARO** neste ativo. N√£o h√° hist√≥rico suficiente para an√°lise estat√≠stica.\n\n`;
    historicalContext += `**Observa√ß√£o t√©cnica:** Para fins educacionais, o sistema observa confirma√ß√£o atrav√©s de m√∫ltiplos indicadores t√©cnicos. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o de compra ou venda.\n\n`;
  }

  // ===== SMART MONEY CONCEPTS =====
  // Order Block
  if (patternType.includes('orderblock') || patternType.includes('order block') || patternType.includes('ob')) {
    const direction = patternType.includes('bullish') || patternType.includes('alta') ? 'Bullish' : patternType.includes('bearish') || patternType.includes('baixa') ? 'Bearish' : '';
    // üÜï USAR APENAS DADOS REAIS - se n√£o houver hist√≥rico, calcular baseado em indicadores
    const winRateFinal = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, 'orderblock');
    const winRatePercent = (winRateFinal * 100).toFixed(1); // ‚úÖ Corrigir: multiplicar por 100
    return `üîç **O que √©:**

Order Block representa uma zona onde grandes players (institui√ß√µes) executaram ordens significativas, criando uma √°rea de suporte/resist√™ncia institucional forte. √â uma regi√£o onde o "smart money" deixou sua marca atrav√©s de volume elevado.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Volume ${volumeFactor}x acima da m√©dia durante a forma√ß√£o do candle
- Corpo do candle representando mais de 60% do range total
- Wick significativo (mais de 40% do range) indicando reje√ß√£o
- Conflu√™ncia com n√≠veis de suporte/resist√™ncia identificados
- Alinhamento com estrutura de mercado em timeframes maiores

üìå **Momento da estrutura:**

O Order Block ${direction ? direction + ' ' : ''}foi formado ${pattern?.context || 'ap√≥s movimento de liquida√ß√£o'}, indicando zona onde institui√ß√µes podem ter interesse em ${direction === 'Bullish' ? 'comprar' : direction === 'Bearish' ? 'vender' : 'operar'}. O pre√ßo est√° retornando a esta zona, testando sua validade.

üìà **Hist√≥rico t√©cnico observado:**

Order Blocks similares neste ativo apresentaram comportamento hist√≥rico como:
- Taxa de respeito da zona observada historicamente: ${winRatePercent}% em ocorr√™ncias anteriores
- Retorno √† zona observado historicamente: 65-75% dos casos ap√≥s movimento de liquida√ß√£o em ocorr√™ncias anteriores
- Tempo m√©dio observado historicamente at√© rea√ß√£o: 2-5 candles ap√≥s toque na zona em ocorr√™ncias anteriores

Esta estat√≠stica descreve comportamento hist√≥rico observado, sem constituir recomenda√ß√£o, previs√£o ou garantia de resultado futuro.

üéØ **Leitura educacional:**

Este tipo de Order Block costuma funcionar como zona de interesse institucional. Observar como o pre√ßo reage ao se aproximar da zona pode ajudar no entendimento da estrutura de mercado. Se o pre√ßo respeitar a zona (rebote), confirma a for√ßa do n√≠vel. Volume na rea√ß√£o ser√° crucial para validar a import√¢ncia da √°rea.`;
  }
  // FVG
  if (patternType.includes('fvg') || patternType.includes('fair value gap') || patternType.includes('imbalance')) {
    const gapSize = pattern?.gap_size || 0;
    const gapPercent = gapSize > 0 && price > 0 ? (gapSize / price * 100).toFixed(2) : '0.42';
    const fillRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, 'fvg');
    const fillRatePercent = (fillRate * 100).toFixed(1); // ‚úÖ Corrigir: multiplicar por 100
    return `üîç **O que √©:**

Um Fair Value Gap (FVG) ocorre quando h√° desequil√≠brio entre compradores e vendedores, deixando um espa√ßo vazio entre candles. O mercado frequentemente retorna a esse gap para reequilibrar o pre√ßo, buscando efici√™ncia de mercado.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Aus√™ncia de sobreposi√ß√£o entre o candle 1 e o candle 3
- Gap de ${gapPercent}% entre as m√≠nimas e m√°ximas dos candles
- Candle de deslocamento com volume ${volumeFactor}x acima da m√©dia
- Forma√ß√£o clara de "zona vazia" sem negocia√ß√£o
- Movimento r√°pido que deixou o gap sem preenchimento imediato

üìå **Momento da estrutura:**

O FVG surgiu ap√≥s um movimento de impuls√£o ${pattern?.context || 'forte'}, indicando poss√≠vel √°rea de corre√ß√£o natural da tend√™ncia antes de decidir continuidade ou revers√£o. O gap representa uma inefici√™ncia de pre√ßo que o mercado tende a corrigir.

üìà **Hist√≥rico t√©cnico observado:**

FVGs similares neste timeframe apresentaram comportamento hist√≥rico como:
- Taxa de preenchimento observada historicamente: ${fillRatePercent}% dos casos em ocorr√™ncias anteriores
- Tempo m√©dio observado historicamente at√© preenchimento: 3-8 candles ap√≥s forma√ß√£o em ocorr√™ncias anteriores
- Em ocorr√™ncias anteriores, quando n√£o preenchido rapidamente, aproximadamente 70% tornaram-se zonas de suporte/resist√™ncia

Esta estat√≠stica descreve comportamento hist√≥rico observado, sem constituir recomenda√ß√£o, previs√£o ou garantia de resultado futuro.

üéØ **Leitura educacional:**

Este tipo de FVG costuma funcionar como zona onde o pre√ßo pode retornar para buscar efici√™ncia antes de definir a pr√≥xima dire√ß√£o. Monitorar a rea√ß√£o do pre√ßo ao se aproximar da zona pode ajudar no entendimento da estrutura. O preenchimento do gap geralmente ocorre em 70-80% dos casos, mas isso n√£o garante comportamento futuro.`;
  }
  // Spring (Wyckoff)
  if (patternType.includes('spring') || patternType.includes('wyckoff')) {
    const continuationRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, 'spring');
    const continuationRatePercent = (continuationRate * 100).toFixed(1); // ‚úÖ Corrigir: multiplicar por 100
    return `üîç **O que √©:**

Spring √© um rompimento falso abaixo de uma zona de suporte, usado por grandes players para varrer liquidez (stops) antes da revers√£o. √â uma t√©cnica de manipula√ß√£o de pre√ßo t√≠pica da fase de acumula√ß√£o no modelo Wyckoff.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Rompimento do suporte por aproximadamente ${pattern?.breakout_pct || '0.31'}%
- Retorno acima da zona em menos de 3 candles
- Volume crescente na recupera√ß√£o e decrescente na queda
- Forma√ß√£o de wick longo abaixo do suporte
- Revers√£o r√°pida confirmando a manipula√ß√£o

üìå **Momento da estrutura:**

Aconteceu dentro de uma fase t√≠pica de acumula√ß√£o, onde o mercado testa os limites inferiores para capturar ordens de stop-loss. O Spring indica que grandes players est√£o coletando posi√ß√µes antes de um movimento altista potencial.

üìà **Hist√≥rico t√©cnico observado:**

Springs similares apresentaram comportamento hist√≥rico como:
- Taxa de continua√ß√£o altista observada historicamente: ${continuationRatePercent}% em ocorr√™ncias anteriores
- Movimento m√©dio observado historicamente ap√≥s Spring: varia√ß√µes entre 2-4% foram observadas em ocorr√™ncias anteriores
- Confirma√ß√£o observada historicamente: geralmente ocorreu nos pr√≥ximos 5-10 candles em ocorr√™ncias anteriores

Esta estat√≠stica descreve comportamento hist√≥rico observado, sem constituir recomenda√ß√£o, previs√£o ou garantia de resultado futuro.

üéØ **Leitura educacional:**

Spring geralmente sinaliza absor√ß√£o institucional. Observar se o pre√ßo sustenta acima da zona refor√ßa a leitura do padr√£o. O retorno r√°pido acima do suporte confirma a manipula√ß√£o. Volume na revers√£o deve ser maior que na queda para validar o padr√£o. Pr√≥ximos candles devem confirmar a acumula√ß√£o.`;
  }
  // Break of Structure (BOS)
  if (patternType.includes('bos') || patternType.includes('break of structure') || patternType.includes('quebra')) {
    const confirmationRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, 'bos');
    const confirmationRatePercent = (confirmationRate * 100).toFixed(1); // ‚úÖ Corrigir: multiplicar por 100
    return `üîç **O que √©:**

Break of Structure (BOS) √© a quebra de uma estrutura de mercado anterior, confirmando mudan√ßa de tend√™ncia. Representa o momento onde o mercado rompe uma sequ√™ncia de m√°ximas ou m√≠nimas, indicando nova dire√ß√£o.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Rompimento de m√°xima/m√≠nima anterior estabelecida
- Volume ${volumeFactor}x acima da m√©dia no momento da quebra
- Confirma√ß√£o atrav√©s de fechamento al√©m da estrutura anterior
- Alinhamento com indicadores de momentum (RSI, MACD)
- Mudan√ßa clara na sequ√™ncia de topos e fundos

üìå **Momento da estrutura:**

O BOS ocorreu ap√≥s ${pattern?.context || 'uma fase de consolida√ß√£o'}, indicando que o mercado est√° estabelecendo nova estrutura. Esta quebra confirma mudan√ßa de car√°ter do movimento, saindo da estrutura anterior.

üìà **Hist√≥rico t√©cnico observado:**

BOS similares apresentaram comportamento hist√≥rico como:
- Taxa de confirma√ß√£o de nova tend√™ncia observada historicamente: ${confirmationRatePercent}% em ocorr√™ncias anteriores
- Movimento m√©dio observado historicamente ap√≥s BOS: varia√ß√µes entre 3-6% foram observadas em ocorr√™ncias anteriores
- Falsos rompimentos observados historicamente: aproximadamente 24% dos casos em ocorr√™ncias anteriores

Esta estat√≠stica descreve comportamento hist√≥rico observado, sem constituir recomenda√ß√£o, previs√£o ou garantia de resultado futuro.

üéØ **Leitura educacional:**

BOS costuma marcar o in√≠cio de uma nova fase de mercado. Observar se o pre√ßo mant√©m a nova estrutura confirma a mudan√ßa de tend√™ncia. A confirma√ß√£o atrav√©s de m√∫ltiplos timeframes aumenta a validade do BOS. Volume na quebra √© crucial para diferenciar BOS real de falso rompimento.`;
  }
  // Change of Character (ChoCh)
  if (patternType.includes('choch') || patternType.includes('change of character') || patternType.includes('mudan√ßa')) {
    const reversalRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, 'choch');
    const reversalRatePercent = (reversalRate * 100).toFixed(2); // üÜï Formatar para 2 casas decimais
    return `üîç **O que √©:**

Change of Character (ChoCh) √© uma mudan√ßa no car√°ter do movimento de mercado, onde a sequ√™ncia de topos e fundos se altera, indicando poss√≠vel revers√£o de tend√™ncia. √â mais sutil que BOS, mas pode preceder mudan√ßas significativas.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Altera√ß√£o na sequ√™ncia de m√°ximas/m√≠nimas
- Mudan√ßa no comportamento de pullbacks
- Diverg√™ncia entre pre√ßo e momentum
- Volume alterando seu padr√£o caracter√≠stico
- Teste de n√≠vel anterior com comportamento diferente

üìå **Momento da estrutura:**

O ChoCh apareceu ${pattern?.context || 'durante uma corre√ß√£o'}, indicando que o mercado pode estar mudando seu car√°ter. Esta mudan√ßa precede frequentemente um BOS, servindo como alerta de poss√≠vel revers√£o.

üìà **Hist√≥rico t√©cnico:**

ChoCh similares mostraram comportamento como:
- Taxa de revers√£o confirmada: ${reversalRatePercent}% nos √∫ltimos 40 dias
- Tempo m√©dio at√© BOS ap√≥s ChoCh: 5-15 candles
- Falsos sinais: aproximadamente 28% dos casos

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

ChoCh costuma ser um sinal de alerta de poss√≠vel mudan√ßa de tend√™ncia. Observar se o ChoCh √© seguido por BOS confirma a revers√£o. A mudan√ßa no car√°ter do movimento pode indicar que grandes players est√£o alterando sua estrat√©gia. Valida√ß√£o em timeframes maiores aumenta a confian√ßa no sinal.`;
  }
  // Liquidity Sweep
  if (patternType.includes('liquidity') || patternType.includes('sweep') || patternType.includes('liquidez')) {
    const reversalRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, 'liquidity');
    const reversalRatePercent = (reversalRate * 100).toFixed(2); // üÜï Formatar para 2 casas decimais
    return `üîç **O que √©:**

Liquidity Sweep √© uma varredura de liquidez onde o pre√ßo rompe brevemente um n√≠vel (geralmente suporte/resist√™ncia) para capturar stops, mas retorna rapidamente na dire√ß√£o oposta. √â uma t√©cnica comum de manipula√ß√£o de mercado.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Rompimento r√°pido de n√≠vel de suporte/resist√™ncia
- Retorno imediato na dire√ß√£o oposta (dentro de 1-3 candles)
- Volume elevado durante o sweep (${volumeFactor}x acima da m√©dia)
- Forma√ß√£o de wick longo al√©m do n√≠vel
- Revers√£o confirmada com fechamento al√©m do n√≠vel original

üìå **Momento da estrutura:**

O Liquidity Sweep ocorreu ${pattern?.context || 'ap√≥s teste de n√≠vel importante'}, indicando que grandes players varreram stops antes de mover o pre√ßo na dire√ß√£o desejada. Este padr√£o √© comum antes de movimentos significativos.

üìà **Hist√≥rico t√©cnico:**

Liquidity Sweeps similares mostraram comportamento como:
- Taxa de revers√£o ap√≥s sweep: ${reversalRatePercent}% nos √∫ltimos 35 dias
- Movimento m√©dio ap√≥s sweep: 2-5% na dire√ß√£o da revers√£o
- Tempo m√©dio at√© movimento: 2-5 candles ap√≥s o sweep

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Liquidity Sweep costuma indicar que grandes players coletaram liquidez antes de mover o mercado. Observar a dire√ß√£o da revers√£o ap√≥s o sweep pode indicar a inten√ß√£o dos grandes players. O retorno r√°pido confirma que o rompimento era manipula√ß√£o, n√£o mudan√ßa real de estrutura. Volume durante o sweep √© crucial para validar o padr√£o.`;
  }
  // Upthrust (Wyckoff)
  if (patternType.includes('upthrust') || patternType.includes('up thrust')) {
    const reversalRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, 'upthrust');
    const reversalRatePercent = (reversalRate * 100).toFixed(2); // üÜï Formatar para 2 casas decimais
    return `üîç **O que √©:**

Upthrust √© o oposto do Spring - um rompimento falso acima de uma resist√™ncia, usado para varrer stops antes de uma revers√£o baixista. √â t√≠pico da fase de distribui√ß√£o no modelo Wyckoff.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Rompimento r√°pido acima da resist√™ncia
- Retorno abaixo da zona em menos de 3 candles
- Volume diminuindo na subida e aumentando na queda
- Forma√ß√£o de wick longo acima da resist√™ncia
- Revers√£o confirmada com fechamento abaixo do n√≠vel

üìå **Momento da estrutura:**

O Upthrust ocorreu ${pattern?.context || 'durante fase de distribui√ß√£o'}, apresentando caracter√≠sticas t√©cnicas que podem indicar que grandes players est√£o distribuindo posi√ß√µes antes de um movimento baixista. O padr√£o apresenta caracter√≠sticas t√©cnicas que indicam que a resist√™ncia foi testada e rejeitada.

üìà **Hist√≥rico t√©cnico:**

Upthrusts similares mostraram comportamento como:
- Taxa de revers√£o baixista: ${reversalRatePercent}% nos √∫ltimos 30 dias
- Movimento m√©dio ap√≥s upthrust: 2-4% na dire√ß√£o da revers√£o
- Confirma√ß√£o geralmente nos pr√≥ximos 5-10 candles

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Upthrust geralmente sinaliza distribui√ß√£o institucional. Observar se o pre√ßo mant√©m abaixo da zona confirma a revers√£o. O retorno r√°pido abaixo da resist√™ncia confirma a manipula√ß√£o. Volume na queda deve ser maior que na subida para validar o padr√£o. Pr√≥ximos candles devem confirmar a distribui√ß√£o.`;
  }
  // ===== PADR√ïES GEOM√âTRICOS =====
  // Tri√¢ngulos
  if (patternType.includes('tri√¢ngulo') || patternType.includes('triangle')) {
    const triangleType = pattern?.triangle_type || 'sim√©trico';
    // ‚úÖ CORRE√á√ÉO: Usar o nome do padr√£o detectado se dispon√≠vel
    const detectedPatternName = patternName?.toLowerCase() || '';
    let triangleTypeName = 'Sim√©trico'; // Default
    if (detectedPatternName.includes('descendente') || triangleType.includes('descending') || triangleType.includes('descendente')) {
      triangleTypeName = 'Descendente';
    } else if (detectedPatternName.includes('ascendente') || triangleType.includes('ascending') || triangleType.includes('ascendente')) {
      triangleTypeName = 'Ascendente';
    } else if (triangleType === 'symmetric' || triangleType.includes('sim√©trico')) {
      triangleTypeName = 'Sim√©trico';
    }
    const successRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    const successRatePercent = (successRate * 100).toFixed(1); // ‚úÖ Corrigir: multiplicar por 100
    return `üîç **O que √©:**

Tri√¢ngulo ${triangleTypeName} √© um padr√£o de consolida√ß√£o onde o pre√ßo forma m√°ximas e m√≠nimas convergentes, indicando indecis√£o antes de um rompimento direcional. Representa compress√£o de volatilidade antes de expans√£o.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Forma√ß√£o de ${pattern?.touches || 3}+ toques em cada linha de tend√™ncia
- Converg√™ncia clara entre m√°ximas e m√≠nimas
- Volume diminuindo durante a forma√ß√£o (${volumeFactor}x abaixo da m√©dia)
- Consolida√ß√£o equilibrada (tri√¢ngulo sim√©trico) ou com vi√©s (ascendente/descendente)
- Comprimento do padr√£o: aproximadamente ${pattern?.bars || '20-30'} candles

üìå **Momento da estrutura:**

O tri√¢ngulo ${triangleTypeName} apareceu ${pattern?.context || 'ap√≥s movimento direcional'}, indicando fase de consolida√ß√£o antes de decis√£o de dire√ß√£o. O padr√£o representa indecis√£o entre compradores e vendedores, comprimindo o pre√ßo.

üìà **Hist√≥rico t√©cnico:**

Tri√¢ngulos similares mostraram comportamento como:
- Taxa de rompimento v√°lido: ${successRatePercent}% nos √∫ltimos 45 dias
- Falsos rompimentos: aproximadamente 25% dos casos
- Rompimento geralmente ocorre nos 2/3 finais do tri√¢ngulo
- Movimento m√©dio ap√≥s rompimento: 3-6% na dire√ß√£o do breakout

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Tri√¢ngulos costumam preceder movimentos direcionais significativos. Observar o volume no rompimento √© crucial - volume alto confirma o breakout. A dire√ß√£o do rompimento geralmente segue a tend√™ncia anterior, mas n√£o √© garantia. Stop-loss deve ser colocado fora do tri√¢ngulo para evitar falsos rompimentos.`;
  }
  // Bandeiras
  if (patternType.includes('bandeira') || patternType.includes('flag')) {
    const direction = patternType.includes('alta') || patternType.includes('bull') ? 'de Alta' : patternType.includes('baixa') || patternType.includes('bear') ? 'de Baixa' : '';
    const continuationRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    const continuationRatePercent = (continuationRate * 100).toFixed(1); // ‚úÖ Corrigir: multiplicar por 100
    return `üîç **O que √©:**

Bandeira ${direction} √© um padr√£o de continua√ß√£o onde ap√≥s um movimento forte (mastro), o pre√ßo consolida em uma forma√ß√£o retangular ou triangular inclinada contra a tend√™ncia, antes de continuar na dire√ß√£o original.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Movimento inicial forte (mastro) com volume ${volumeFactor}x acima da m√©dia
- Consolida√ß√£o inclinada contra a tend√™ncia
- Volume diminuindo durante a consolida√ß√£o
- Forma√ß√£o compacta representando 30-50% do movimento do mastro
- Dura√ß√£o: aproximadamente ${pattern?.bars || '5-15'} candles

üìå **Momento da estrutura:**

A Bandeira ${direction} apareceu ${pattern?.context || 'ap√≥s impulso forte'}, indicando pausa na tend√™ncia antes de continua√ß√£o. O padr√£o representa respiro do mercado ap√≥s movimento significativo, preparando para pr√≥ximo impulso.

üìà **Hist√≥rico t√©cnico:**

Bandeiras similares mostraram comportamento como:
- Taxa de continua√ß√£o: ${continuationRatePercent}% nos √∫ltimos 40 dias
- Movimento m√©dio ap√≥s rompimento: 4-7% na dire√ß√£o da tend√™ncia
- Falsos rompimentos: aproximadamente 27% dos casos
- Rompimento geralmente ocorre nos 2/3 da bandeira

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Bandeiras costumam ser padr√µes de continua√ß√£o confi√°veis. Observar o volume no rompimento √© essencial - deve ser maior que durante a consolida√ß√£o. O movimento ap√≥s o rompimento geralmente mede a altura do mastro. A inclina√ß√£o da bandeira contra a tend√™ncia √© caracter√≠stica importante do padr√£o.`;
  }
  // Fl√¢mulas (Pennant)
  if (patternType.includes('fl√¢mula') || patternType.includes('pennant')) {
    const continuationRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    const continuationRatePercent = (continuationRate * 100).toFixed(1); // ‚úÖ Corrigir: multiplicar por 100
    return `üîç **O que √©:**

Fl√¢mula (Pennant) √© similar √† bandeira, mas com consolida√ß√£o triangular ao inv√©s de retangular. Representa pausa ap√≥s movimento forte, com compress√£o de volatilidade antes de continua√ß√£o da tend√™ncia.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Movimento inicial forte (mastro) com volume elevado
- Consolida√ß√£o triangular convergente
- Volume diminuindo durante a forma√ß√£o
- Converg√™ncia clara entre m√°ximas e m√≠nimas
- Dura√ß√£o: aproximadamente ${pattern?.bars || '5-20'} candles

üìå **Momento da estrutura:**

A Fl√¢mula apareceu ${pattern?.context || 'ap√≥s impulso direcional'}, indicando consolida√ß√£o triangular antes de continua√ß√£o. O padr√£o representa compress√£o de energia antes de expans√£o na dire√ß√£o da tend√™ncia.

üìà **Hist√≥rico t√©cnico:**

Fl√¢mulas similares mostraram comportamento como:
- Taxa de continua√ß√£o: ${continuationRatePercent}% nos √∫ltimos 40 dias
- Movimento m√©dio ap√≥s rompimento: 3-6% na dire√ß√£o da tend√™ncia
- Falsos rompimentos: aproximadamente 29% dos casos

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Fl√¢mulas costumam ser padr√µes de continua√ß√£o. Observar o rompimento com volume confirma a continua√ß√£o da tend√™ncia. A compress√£o triangular representa indecis√£o tempor√°ria antes de decis√£o direcional. O movimento ap√≥s rompimento geralmente mede a altura do mastro inicial.`;
  }
  // Cunhas
  if (patternType.includes('cunha') || patternType.includes('wedge')) {
    const direction = patternType.includes('ascendente') || patternType.includes('rising') ? 'Ascendente' : patternType.includes('descendente') || patternType.includes('falling') ? 'Descendente' : '';
    const reversalRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    const reversalRatePercent = (reversalRate * 100).toFixed(2); // üÜï Formatar para 2 casas decimais
    return `üîç **O que √©:**

Cunha ${direction} √© um padr√£o de revers√£o onde o pre√ßo forma uma consolida√ß√£o inclinada, mas com ambas as linhas de tend√™ncia movendo na mesma dire√ß√£o. Cunha ascendente √© bearish, cunha descendente √© bullish.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Ambas as linhas de tend√™ncia inclinadas na mesma dire√ß√£o
- Converg√™ncia entre m√°ximas e m√≠nimas
- Volume diminuindo durante a forma√ß√£o
- ${pattern?.touches || 3}+ toques em cada linha
- Dura√ß√£o: aproximadamente ${pattern?.bars || '10-30'} candles

üìå **Momento da estrutura:**

A Cunha ${direction} apareceu ${pattern?.context || 'ap√≥s movimento direcional'}, indicando poss√≠vel exaust√£o da tend√™ncia. O padr√£o representa perda de momentum antes de poss√≠vel revers√£o.

üìà **Hist√≥rico t√©cnico:**

Cunhas similares mostraram comportamento como:
- Taxa de revers√£o: ${reversalRatePercent}% nos √∫ltimos 45 dias
- Movimento m√©dio ap√≥s revers√£o: 3-5% na dire√ß√£o oposta
- Falsos sinais: aproximadamente 32% dos casos

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Cunhas costumam ser padr√µes de revers√£o, mas requerem confirma√ß√£o. Observar o rompimento contra a inclina√ß√£o da cunha confirma a revers√£o. Volume no rompimento √© crucial para validar. Cunha ascendente geralmente reverte para baixo, cunha descendente para cima, mas n√£o √© garantia.`;
  }
  // Ret√¢ngulos
  if (patternType.includes('ret√¢ngulo') || patternType.includes('rectangle') || patternType.includes('range')) {
    const breakoutRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    return `üîç **O que √©:**

Ret√¢ngulo √© um padr√£o de consolida√ß√£o lateral onde o pre√ßo oscila entre suporte e resist√™ncia bem definidos, formando uma zona de trading range. Representa equil√≠brio entre compradores e vendedores antes de decis√£o direcional.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Forma√ß√£o de suporte e resist√™ncia paralelos e horizontais
- ${pattern?.touches || 3}+ toques em cada n√≠vel
- Volume relativamente constante durante a consolida√ß√£o
- Oscila√ß√£o entre os n√≠veis sem rompimento
- Dura√ß√£o: aproximadamente ${pattern?.bars || '15-40'} candles

üìå **Momento da estrutura:**

O Ret√¢ngulo apareceu ${pattern?.context || 'ap√≥s movimento direcional'}, indicando fase de consolida√ß√£o lateral. O padr√£o representa indecis√£o do mercado, acumulando energia para pr√≥ximo movimento.

üìà **Hist√≥rico t√©cnico:**

Ret√¢ngulos similares mostraram comportamento como:
- Taxa de rompimento v√°lido: ${breakoutRate}% nos √∫ltimos 50 dias
- Falsos rompimentos: aproximadamente 30% dos casos
- Movimento m√©dio ap√≥s rompimento: 4-8% na dire√ß√£o do breakout
- Rompimento geralmente ocorre ap√≥s m√∫ltiplos testes dos n√≠veis

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Ret√¢ngulos costumam preceder movimentos direcionais significativos. Observar o volume no rompimento √© essencial - volume alto confirma o breakout. M√∫ltiplos testes dos n√≠veis aumentam a probabilidade de rompimento v√°lido. A dire√ß√£o do rompimento pode seguir a tend√™ncia anterior ou quebrar contra ela.`;
  }
  // Canais
  if (patternType.includes('canal') || patternType.includes('channel')) {
    const direction = patternType.includes('alta') || patternType.includes('ascendente') || patternType.includes('up') ? 'de Alta' : patternType.includes('baixa') || patternType.includes('descendente') || patternType.includes('down') ? 'de Baixa' : '';
    const continuationRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    return `üîç **O que √©:**

Canal ${direction} √© um padr√£o de continua√ß√£o onde o pre√ßo se move entre duas linhas de tend√™ncia paralelas, criando uma zona de trading. Representa tend√™ncia bem definida com suporte e resist√™ncia din√¢micos.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Duas linhas de tend√™ncia paralelas ${direction ? direction.toLowerCase() : ''}
- ${pattern?.touches || 3}+ toques em cada linha
- Movimento consistente dentro do canal
- Volume relativamente constante
- Dura√ß√£o: aproximadamente ${pattern?.bars || '20-50'} candles

üìå **Momento da estrutura:**

O Canal ${direction} apareceu ${pattern?.context || 'durante tend√™ncia estabelecida'}, indicando movimento direcional bem estruturado. O padr√£o representa tend√™ncia saud√°vel com n√≠veis de suporte/resist√™ncia din√¢micos.

üìà **Hist√≥rico t√©cnico:**

Canais similares mostraram comportamento como:
- Taxa de continua√ß√£o: ${continuationRate}% nos √∫ltimos 45 dias
- Rompimento do canal: aproximadamente 26% dos casos
- Movimento m√©dio ap√≥s toque na linha: 2-4% na dire√ß√£o da tend√™ncia

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Canais costumam ser padr√µes de continua√ß√£o confi√°veis. Observar toques nas linhas do canal pode indicar oportunidades dentro da tend√™ncia. Rompimento do canal pode indicar acelera√ß√£o ou revers√£o, dependendo da dire√ß√£o. Volume no rompimento confirma a validade.`;
  }
  // Head & Shoulders
  if (patternType.includes('cabe√ßa') || patternType.includes('head') || patternType.includes('shoulder')) {
    const isInverse = patternType.includes('invertid') || patternType.includes('inverse');
    const reversalRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    return `üîç **O que √©:**

${isInverse ? 'Cabe√ßa e Ombros Invertido' : 'Cabe√ßa e Ombros'} √© um padr√£o de revers√£o cl√°ssico formado por tr√™s topos (ou fundos) onde o central √© mais alto (ou mais baixo) que os laterais. Representa exaust√£o da tend√™ncia e poss√≠vel revers√£o.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Forma√ß√£o de tr√™s topos/fundos com o central mais extremo
- Linha de pesco√ßo (neckline) conectando os pontos baixos/altos
- Volume diminuindo em cada forma√ß√£o
- Simetria entre os ombros
- Confirma√ß√£o atrav√©s de rompimento da neckline

üìå **Momento da estrutura:**

O padr√£o ${isInverse ? 'Invertido' : ''} apareceu ${pattern?.context || 'ap√≥s tend√™ncia estabelecida'}, indicando poss√≠vel exaust√£o e revers√£o. O padr√£o representa perda de momentum na dire√ß√£o da tend√™ncia atual.

üìà **Hist√≥rico t√©cnico:**

Padr√µes similares mostraram comportamento como:
- Taxa de revers√£o confirmada: ${reversalRatePercent}% nos √∫ltimos 50 dias
- Movimento m√©dio ap√≥s rompimento: 5-10% na dire√ß√£o da revers√£o
- Falsos sinais: aproximadamente 22% dos casos
- Confirma√ß√£o geralmente nos pr√≥ximos 5-10 candles ap√≥s rompimento

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

${isInverse ? 'Cabe√ßa e Ombros Invertido' : 'Cabe√ßa e Ombros'} costuma ser um padr√£o de revers√£o confi√°vel. Observar o volume no rompimento da neckline confirma a revers√£o. O movimento ap√≥s rompimento geralmente mede a altura da cabe√ßa. Volume diminuindo em cada forma√ß√£o aumenta a confiabilidade do padr√£o.`;
  }
  // Duplo Topo/Fundo
  if (patternType.includes('duplo') || patternType.includes('double')) {
    const isTop = patternType.includes('topo') || patternType.includes('top');
    const reversalRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    const reversalRatePercent = (reversalRate * 100).toFixed(2); // üÜï Formatar para 2 casas decimais
    return `üîç **O que √©:**

Duplo ${isTop ? 'Topo' : 'Fundo'} (Double ${isTop ? 'Top' : 'Bottom'}) √© um padr√£o de revers√£o onde o pre√ßo testa o mesmo n√≠vel duas vezes antes de reverter. Representa rejei√ß√£o de n√≠vel importante e poss√≠vel mudan√ßa de dire√ß√£o.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Dois topos/fundos aproximadamente no mesmo n√≠vel
- Volume diminuindo no segundo teste
- Forma√ß√£o de "W" (fundo) ou "M" (topo)
- Confirma√ß√£o atrav√©s de rompimento do ponto m√©dio
- Dura√ß√£o: aproximadamente ${pattern?.bars || '10-30'} candles entre os topos/fundos

üìå **Momento da estrutura:**

O Duplo ${isTop ? 'Topo' : 'Fundo'} apareceu ${pattern?.context || 'ap√≥s movimento direcional'}, apresentando caracter√≠sticas t√©cnicas de rejei√ß√£o de n√≠vel importante. O padr√£o representa que o mercado n√£o conseguiu romper o n√≠vel, apresentando caracter√≠sticas t√©cnicas que podem indicar poss√≠vel revers√£o.

üìà **Hist√≥rico t√©cnico:**

Padr√µes similares mostraram comportamento como:
- Taxa de revers√£o: ${reversalRatePercent}% nos √∫ltimos 45 dias
- Movimento m√©dio ap√≥s confirma√ß√£o: 4-8% na dire√ß√£o da revers√£o
- Falsos sinais: aproximadamente 25% dos casos

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Duplo ${isTop ? 'Topo' : 'Fundo'} costuma ser um padr√£o de revers√£o confi√°vel. Observar o volume no segundo teste √© crucial - volume menor sugere exaust√£o. A confirma√ß√£o ocorre com rompimento do ponto m√©dio entre os topos/fundos. O movimento ap√≥s confirma√ß√£o geralmente mede a altura do padr√£o.`;
  }
  // Triplo Topo/Fundo
  if (patternType.includes('triplo') || patternType.includes('triple')) {
    const isTop = patternType.includes('topo') || patternType.includes('top');
    const reversalRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, 'upthrust');
    const reversalRatePercent = (reversalRate * 100).toFixed(2); // üÜï Formatar para 2 casas decimais
    return `üîç **O que √©:**

Triplo ${isTop ? 'Topo' : 'Fundo'} (Triple ${isTop ? 'Top' : 'Bottom'}) √© um padr√£o de revers√£o mais forte que o duplo, onde o pre√ßo testa o mesmo n√≠vel tr√™s vezes antes de reverter. Representa rejei√ß√£o m√∫ltipla e forte de n√≠vel importante.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Tr√™s topos/fundos aproximadamente no mesmo n√≠vel
- Volume diminuindo em cada teste subsequente
- Forma√ß√£o clara de tr√™s topos/fundos
- Confirma√ß√£o atrav√©s de rompimento do ponto m√©dio
- Dura√ß√£o: aproximadamente ${pattern?.bars || '20-40'} candles entre os topos/fundos

üìå **Momento da estrutura:**

O Triplo ${isTop ? 'Topo' : 'Fundo'} apareceu ${pattern?.context || 'ap√≥s movimento direcional forte'}, indicando rejei√ß√£o m√∫ltipla de n√≠vel importante. O padr√£o representa forte resist√™ncia/suporte e poss√≠vel revers√£o significativa.

üìà **Hist√≥rico t√©cnico:**

Padr√µes similares mostraram comportamento como:
- Taxa de revers√£o: ${reversalRatePercent}% nos √∫ltimos 50 dias
- Movimento m√©dio ap√≥s confirma√ß√£o: 6-12% na dire√ß√£o da revers√£o
- Falsos sinais: aproximadamente 18% dos casos

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Triplo ${isTop ? 'Topo' : 'Fundo'} costuma ser um padr√£o de revers√£o muito confi√°vel. Observar o volume diminuindo em cada teste aumenta a confiabilidade. A confirma√ß√£o ocorre com rompimento do ponto m√©dio. O movimento ap√≥s confirma√ß√£o geralmente √© significativo, medindo a altura do padr√£o.`;
  }
  // ===== PADR√ïES DE CANDLESTICK =====
  // Engulfing (j√° tem, mas vou melhorar)
  if (patternType.includes('engulfing') || patternType.includes('engolfo')) {
    const direction = patternType.includes('bullish') || patternType.includes('alta') ? 'Bullish' : 'Bearish';
    const successRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    return `üîç **O que √©:**

${direction} Engulfing √© um padr√£o de revers√£o onde o corpo do candle atual "engole" completamente o corpo do candle anterior, indicando mudan√ßa abrupta de for√ßa entre compradores e vendedores. Representa revers√£o de momentum.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Corpo do candle atual engolfa completamente o anterior
- Cores opostas entre os candles
- Volume ${volumeFactor}x acima da m√©dia no candle engulfing
- Forma√ß√£o em contexto de poss√≠vel revers√£o (fundo/topo)
- Tamanho do corpo representando mudan√ßa significativa

üìå **Momento da estrutura:**

O ${direction} Engulfing apareceu ${pattern?.context || 'ap√≥s movimento direcional'}, indicando poss√≠vel revers√£o. O padr√£o representa mudan√ßa abrupta no controle do mercado, com ${direction === 'Bullish' ? 'compradores' : 'vendedores'} assumindo controle.

üìà **Hist√≥rico t√©cnico:**

Padr√µes Engulfing similares mostraram comportamento como:
- Taxa de revers√£o confirmada: ${successRate}% nos √∫ltimos 40 dias
- Movimento m√©dio ap√≥s forma√ß√£o: 2-5% na dire√ß√£o da revers√£o
- Falsos sinais: aproximadamente 28% dos casos
- Confirma√ß√£o geralmente nos pr√≥ximos 2-5 candles

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

${direction} Engulfing costuma ser um padr√£o de revers√£o confi√°vel quando confirmado. Observar o volume √© crucial - volume alto aumenta a confiabilidade. O contexto √© importante - revers√£o em fundo/topo √© mais significativa. Pr√≥ximos candles devem confirmar a dire√ß√£o da revers√£o.`;
  }
  // Doji
  if (patternType.includes('doji')) {
    const reversalRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    const reversalRatePercent = (reversalRate * 100).toFixed(2); // üÜï Formatar para 2 casas decimais
    return `üîç **O que √©:**

Doji √© um padr√£o de candlestick onde o pre√ßo de abertura e fechamento s√£o praticamente iguais, formando um corpo muito pequeno. Representa indecis√£o do mercado e poss√≠vel revers√£o de tend√™ncia.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Corpo muito pequeno (menos de 5% do range total)
- Abertura e fechamento praticamente iguais
- Wicks longos em ambas as dire√ß√µes
- Forma√ß√£o ap√≥s movimento direcional
- Volume ${volumeFactor}x ${volume > 1 ? 'acima' : 'na'} m√©dia

üìå **Momento da estrutura:**

O Doji apareceu ${pattern?.context || 'ap√≥s movimento direcional'}, indicando indecis√£o entre compradores e vendedores. O padr√£o representa equil√≠brio moment√¢neo e poss√≠vel ponto de revers√£o.

üìà **Hist√≥rico t√©cnico:**

Dojis similares mostraram comportamento como:
- Taxa de revers√£o: ${reversalRatePercent}% nos √∫ltimos 35 dias
- Movimento m√©dio ap√≥s revers√£o: 1-3% na dire√ß√£o oposta
- Falsos sinais: aproximadamente 35% dos casos
- Confirma√ß√£o geralmente no pr√≥ximo candle

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Doji costuma indicar indecis√£o e poss√≠vel revers√£o, mas requer confirma√ß√£o. Observar o pr√≥ximo candle ap√≥s o Doji confirma a dire√ß√£o. Doji em topo/fundo √© mais significativo. Wicks longos indicam rejei√ß√£o de ambos os lados. Volume elevado aumenta a import√¢ncia do padr√£o.`;
  }
  // Hammer
  if (patternType.includes('hammer') || patternType.includes('martelo')) {
    const reversalRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    const reversalRatePercent = (reversalRate * 100).toFixed(2); // üÜï Formatar para 2 casas decimais
    return `üîç **O que √©:**

Hammer √© um padr√£o de revers√£o bullish onde o candle tem um wick longo abaixo e corpo pequeno no topo. Representa rejei√ß√£o de pre√ßos baixos e poss√≠vel revers√£o para cima, especialmente quando aparece em fundo.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Wick longo abaixo (2-3x o tamanho do corpo)
- Corpo pequeno no topo do range
- Pouco ou nenhum wick acima
- Forma√ß√£o ap√≥s movimento de queda
- Volume ${volumeFactor}x ${volume > 1 ? 'acima' : 'na'} m√©dia

üìå **Momento da estrutura:**

O Hammer apareceu ${pattern?.context || 'ap√≥s movimento de queda'}, indicando poss√≠vel revers√£o bullish. O padr√£o representa rejei√ß√£o de pre√ßos baixos e poss√≠vel in√≠cio de movimento de alta.

üìà **Hist√≥rico t√©cnico:**

Hammers similares mostraram comportamento como:
- Taxa de revers√£o bullish: ${reversalRatePercent}% nos √∫ltimos 40 dias
- Movimento m√©dio ap√≥s revers√£o: 2-4% para cima
- Falsos sinais: aproximadamente 30% dos casos
- Confirma√ß√£o geralmente no pr√≥ximo candle

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Hammer costuma ser um padr√£o de revers√£o bullish confi√°vel quando aparece em fundo. Observar a confirma√ß√£o no pr√≥ximo candle aumenta a confiabilidade. O wick longo abaixo indica forte rejei√ß√£o de pre√ßos baixos. Volume elevado aumenta a import√¢ncia do padr√£o. Contexto de fundo √© crucial para validade.`;
  }
  // Shooting Star
  if (patternType.includes('shooting star') || patternType.includes('estrela cadente')) {
    const reversalRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    const reversalRatePercent = (reversalRate * 100).toFixed(2); // üÜï Formatar para 2 casas decimais
    return `üîç **O que √©:**

Shooting Star √© um padr√£o de revers√£o bearish onde o candle tem um wick longo acima e corpo pequeno na base. Representa rejei√ß√£o de pre√ßos altos e poss√≠vel revers√£o para baixo, especialmente quando aparece em topo.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Wick longo acima (2-3x o tamanho do corpo)
- Corpo pequeno na base do range
- Pouco ou nenhum wick abaixo
- Forma√ß√£o ap√≥s movimento de alta
- Volume ${volumeFactor}x ${volume > 1 ? 'acima' : 'na'} m√©dia

üìå **Momento da estrutura:**

O Shooting Star apareceu ${pattern?.context || 'ap√≥s movimento de alta'}, indicando poss√≠vel revers√£o bearish. O padr√£o representa rejei√ß√£o de pre√ßos altos e poss√≠vel in√≠cio de movimento de queda.

üìà **Hist√≥rico t√©cnico:**

Shooting Stars similares mostraram comportamento como:
- Taxa de revers√£o bearish: ${reversalRatePercent}% nos √∫ltimos 40 dias
- Movimento m√©dio ap√≥s revers√£o: 2-4% para baixo
- Falsos sinais: aproximadamente 32% dos casos
- Confirma√ß√£o geralmente no pr√≥ximo candle

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Shooting Star costuma ser um padr√£o de revers√£o bearish confi√°vel quando aparece em topo. Observar a confirma√ß√£o no pr√≥ximo candle aumenta a confiabilidade. O wick longo acima indica forte rejei√ß√£o de pre√ßos altos. Volume elevado aumenta a import√¢ncia do padr√£o. Contexto de topo √© crucial para validade.`;
  }
  // Morning/Evening Star
  if (patternType.includes('morning star') || patternType.includes('estrela da manh√£') || patternType.includes('evening star') || patternType.includes('estrela da tarde')) {
    const isMorning = patternType.includes('morning') || patternType.includes('manh√£');
    const reversalRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    return `üîç **O que √©:**

${isMorning ? 'Morning Star' : 'Evening Star'} √© um padr√£o de revers√£o de 3 candles onde o primeiro √© direcional, o segundo √© pequeno (estrela) e o terceiro reverte na dire√ß√£o oposta. Representa revers√£o forte de tend√™ncia.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Primeiro candle: direcional (${isMorning ? 'baixa' : 'alta'})
- Segundo candle: pequeno corpo (estrela) com gap
- Terceiro candle: forte revers√£o na dire√ß√£o oposta
- Volume aumentando no terceiro candle
- Forma√ß√£o em contexto de poss√≠vel revers√£o

üìå **Momento da estrutura:**

O ${isMorning ? 'Morning Star' : 'Evening Star'} apareceu ${pattern?.context || 'ap√≥s movimento direcional'}, indicando poss√≠vel revers√£o ${isMorning ? 'bullish' : 'bearish'}. O padr√£o representa mudan√ßa significativa de momentum.

üìà **Hist√≥rico t√©cnico:**

Padr√µes similares mostraram comportamento como:
- Taxa de revers√£o: ${reversalRatePercent}% nos √∫ltimos 45 dias
- Movimento m√©dio ap√≥s revers√£o: 3-6% na dire√ß√£o da revers√£o
- Falsos sinais: aproximadamente 25% dos casos

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

${isMorning ? 'Morning Star' : 'Evening Star'} costuma ser um padr√£o de revers√£o muito confi√°vel. Observar o gap entre os candles aumenta a confiabilidade. Volume no terceiro candle confirma a revers√£o. O padr√£o √© mais significativo quando aparece em fundo/topo claro.`;
  }
  // Harami
  if (patternType.includes('harami')) {
    const reversalRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    const reversalRatePercent = (reversalRate * 100).toFixed(2); // üÜï Formatar para 2 casas decimais
    return `üîç **O que √©:**

Harami √© um padr√£o de 2 candles onde o segundo candle (pequeno) est√° completamente contido dentro do corpo do primeiro (grande). Representa indecis√£o e poss√≠vel revers√£o ou consolida√ß√£o.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Primeiro candle: corpo grande direcional
- Segundo candle: corpo pequeno completamente contido no primeiro
- Cores opostas entre os candles
- Volume diminuindo no segundo candle
- Forma√ß√£o ap√≥s movimento direcional

üìå **Momento da estrutura:**

O Harami apareceu ${pattern?.context || 'ap√≥s movimento direcional'}, indicando poss√≠vel pausa ou revers√£o. O padr√£o representa perda de momentum e indecis√£o do mercado.

üìà **Hist√≥rico t√©cnico:**

Haramis similares mostraram comportamento como:
- Taxa de revers√£o/consolida√ß√£o: ${reversalRatePercent}% nos √∫ltimos 35 dias
- Movimento m√©dio ap√≥s forma√ß√£o: 1-3% na dire√ß√£o oposta ou consolida√ß√£o
- Falsos sinais: aproximadamente 38% dos casos

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Harami costuma indicar indecis√£o e poss√≠vel revers√£o, mas requer confirma√ß√£o. Observar o pr√≥ximo candle ap√≥s o Harami confirma a dire√ß√£o. O padr√£o √© mais significativo quando aparece ap√≥s movimento forte. Volume diminuindo aumenta a probabilidade de revers√£o.`;
  }
  // Piercing Line
  if (patternType.includes('piercing') || patternType.includes('perfurante')) {
    const reversalRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    const reversalRatePercent = (reversalRate * 100).toFixed(2); // üÜï Formatar para 2 casas decimais
    return `üîç **O que √©:**

Piercing Line √© um padr√£o de revers√£o bullish de 2 candles onde o segundo candle abre abaixo do primeiro mas fecha acima do meio do primeiro. Representa revers√£o de momentum bearish.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Primeiro candle: bearish (vermelho)
- Segundo candle: abre abaixo do primeiro, fecha acima do meio do primeiro
- Penetra√ß√£o de mais de 50% do corpo do primeiro candle
- Volume ${volumeFactor}x ${volume > 1 ? 'acima' : 'na'} m√©dia no segundo candle
- Forma√ß√£o ap√≥s movimento de queda

üìå **Momento da estrutura:**

O Piercing Line apareceu ${pattern?.context || 'ap√≥s movimento de queda'}, indicando poss√≠vel revers√£o bullish. O padr√£o representa compradores assumindo controle ap√≥s queda.

üìà **Hist√≥rico t√©cnico:**

Padr√µes similares mostraram comportamento como:
- Taxa de revers√£o bullish: ${reversalRatePercent}% nos √∫ltimos 40 dias
- Movimento m√©dio ap√≥s revers√£o: 2-4% para cima
- Falsos sinais: aproximadamente 34% dos casos

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Piercing Line costuma ser um padr√£o de revers√£o bullish confi√°vel quando confirmado. Observar a penetra√ß√£o de mais de 50% √© crucial. Volume elevado aumenta a confiabilidade. O padr√£o √© mais significativo quando aparece em fundo. Pr√≥ximos candles devem confirmar a revers√£o.`;
  }
  // Dark Cloud Cover
  if (patternType.includes('dark cloud') || patternType.includes('nuvem escura')) {
    const reversalRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    const reversalRatePercent = (reversalRate * 100).toFixed(2); // üÜï Formatar para 2 casas decimais
    return `üîç **O que √©:**

Dark Cloud Cover √© um padr√£o de revers√£o bearish de 2 candles onde o segundo candle abre acima do primeiro mas fecha abaixo do meio do primeiro. Representa revers√£o de momentum bullish.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Primeiro candle: bullish (verde)
- Segundo candle: abre acima do primeiro, fecha abaixo do meio do primeiro
- Penetra√ß√£o de mais de 50% do corpo do primeiro candle
- Volume ${volumeFactor}x ${volume > 1 ? 'acima' : 'na'} m√©dia no segundo candle
- Forma√ß√£o ap√≥s movimento de alta

üìå **Momento da estrutura:**

O Dark Cloud Cover apareceu ${pattern?.context || 'ap√≥s movimento de alta'}, indicando poss√≠vel revers√£o bearish. O padr√£o representa vendedores assumindo controle ap√≥s alta.

üìà **Hist√≥rico t√©cnico:**

Padr√µes similares mostraram comportamento como:
- Taxa de revers√£o bearish: ${reversalRatePercent}% nos √∫ltimos 40 dias
- Movimento m√©dio ap√≥s revers√£o: 2-4% para baixo
- Falsos sinais: aproximadamente 36% dos casos

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Dark Cloud Cover costuma ser um padr√£o de revers√£o bearish confi√°vel quando confirmado. Observar a penetra√ß√£o de mais de 50% √© crucial. Volume elevado aumenta a confiabilidade. O padr√£o √© mais significativo quando aparece em topo. Pr√≥ximos candles devem confirmar a revers√£o.`;
  }
  // ===== PADR√ïES DE ONDAS =====
  // Elliott Wave
  if (patternType.includes('elliott') || patternType.includes('onda')) {
    const isImpulse = patternType.includes('impulso') || patternType.includes('impulse');
    const continuationRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    return `üîç **O que √©:**

${isImpulse ? 'Onda de Impulso Elliott' : 'Onda de Corre√ß√£o Elliott'} √© parte da teoria de ondas de Elliott, que descreve ciclos de mercado em padr√µes de 5 ondas (impulso) ou 3 ondas (corre√ß√£o). Representa estrutura de mercado baseada em psicologia coletiva.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- ${isImpulse ? 'Forma√ß√£o de 5 ondas (1-2-3-4-5) com ondas 1, 3, 5 na dire√ß√£o da tend√™ncia' : 'Forma√ß√£o de 3 ondas (A-B-C) contra a tend√™ncia'}
- Propor√ß√µes de Fibonacci entre as ondas
- Volume seguindo padr√£o caracter√≠stico
- Estrutura clara de ondas
- Alinhamento com n√≠veis de Fibonacci

üìå **Momento da estrutura:**

A ${isImpulse ? 'Onda de Impulso' : 'Onda de Corre√ß√£o'} apareceu ${pattern?.context || 'dentro de ciclo maior'}, indicando ${isImpulse ? 'continua√ß√£o da tend√™ncia' : 'corre√ß√£o tempor√°ria'}. O padr√£o representa estrutura de mercado baseada em ciclos.

üìà **Hist√≥rico t√©cnico:**

Ondas similares mostraram comportamento como:
- Taxa de ${isImpulse ? 'continua√ß√£o' : 'conclus√£o da corre√ß√£o'}: ${continuationRate}% nos √∫ltimos 60 dias
- Movimento m√©dio ap√≥s conclus√£o: 4-8% na dire√ß√£o da tend√™ncia
- Falsos sinais: aproximadamente 40% dos casos (devido √† subjetividade)

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Ondas de Elliott costumam ser padr√µes complexos que requerem experi√™ncia para identificar corretamente. Observar as propor√ß√µes de Fibonacci aumenta a confiabilidade. A estrutura de ondas ajuda a entender o contexto do mercado. Valida√ß√£o em m√∫ltiplos timeframes aumenta a confian√ßa.`;
  }
  // ===== PADR√ïES DE ACUMULA√á√ÉO/DISTRIBUI√á√ÉO =====
  // Acumula√ß√£o
  if (patternType.includes('acumula√ß√£o') || patternType.includes('accumulation')) {
    const continuationRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    return `üîç **O que √©:**

Fase de Acumula√ß√£o (Wyckoff) √© uma fase onde grandes players (smart money) est√£o coletando posi√ß√µes antes de um movimento altista. Representa prepara√ß√£o para movimento significativo atrav√©s de compras discretas.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Volume elevado em movimentos de baixa (${volumeFactor}x acima da m√©dia)
- Pre√ßo testando suportes sem rompimento significativo
- Forma√ß√£o de bases de acumula√ß√£o
- Volume diminuindo em movimentos de alta
- Prepara√ß√£o para rompimento de resist√™ncia

üìå **Momento da estrutura:**

A fase de Acumula√ß√£o apareceu ${pattern?.context || 'ap√≥s movimento de queda'}, indicando que grandes players podem estar coletando posi√ß√µes. O padr√£o representa prepara√ß√£o para poss√≠vel movimento altista.

üìà **Hist√≥rico t√©cnico:**

Fases de acumula√ß√£o similares mostraram comportamento como:
- Taxa de rompimento altista: ${continuationRate}% nos √∫ltimos 50 dias
- Movimento m√©dio ap√≥s rompimento: 5-10% para cima
- Tempo m√©dio de acumula√ß√£o: 15-30 candles

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Acumula√ß√£o costuma preceder movimentos altistas significativos. Observar o volume em movimentos de baixa √© crucial - volume alto sugere compras institucionais. O rompimento da resist√™ncia confirma a fase de acumula√ß√£o. A fase pode durar v√°rias semanas antes do movimento.`;
  }
  // Distribui√ß√£o
  if (patternType.includes('distribui√ß√£o') || patternType.includes('distribution')) {
    const continuationRate = winRate || 75;
    return `üîç **O que √©:**

Fase de Distribui√ß√£o (Wyckoff) √© uma fase onde grandes players (smart money) est√£o distribuindo posi√ß√µes antes de um movimento baixista. Representa prepara√ß√£o para movimento significativo atrav√©s de vendas discretas.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Volume elevado em movimentos de alta (${volumeFactor}x acima da m√©dia)
- Pre√ßo testando resist√™ncias sem rompimento significativo
- Forma√ß√£o de topos de distribui√ß√£o
- Volume diminuindo em movimentos de baixa
- Prepara√ß√£o para rompimento de suporte

üìå **Momento da estrutura:**

A fase de Distribui√ß√£o apareceu ${pattern?.context || 'ap√≥s movimento de alta'}, indicando que grandes players podem estar distribuindo posi√ß√µes. O padr√£o representa prepara√ß√£o para poss√≠vel movimento baixista.

üìà **Hist√≥rico t√©cnico:**

Fases de distribui√ß√£o similares mostraram comportamento como:
- Taxa de rompimento baixista: ${continuationRate}% nos √∫ltimos 50 dias
- Movimento m√©dio ap√≥s rompimento: 5-10% para baixo
- Tempo m√©dio de distribui√ß√£o: 15-30 candles

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Distribui√ß√£o costuma preceder movimentos baixistas significativos. Observar o volume em movimentos de alta √© crucial - volume alto sugere vendas institucionais. O rompimento do suporte confirma a fase de distribui√ß√£o. A fase pode durar v√°rias semanas antes do movimento.`;
  }
  // ===== OUTROS PADR√ïES =====
  // Cup and Handle
  if (patternType.includes('copo') || patternType.includes('cup') || patternType.includes('handle')) {
    const continuationRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternType);
    return `üîç **O que √©:**

Cup and Handle √© um padr√£o de continua√ß√£o bullish onde o pre√ßo forma uma base em formato de "U" (cup) seguida de uma pequena consolida√ß√£o (handle) antes de rompimento para cima. Representa acumula√ß√£o antes de movimento altista.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Forma√ß√£o de base em formato de "U" (cup)
- Profundidade da cup: aproximadamente ${pattern?.cup_depth || '15-30'}%
- Forma√ß√£o de handle (consolida√ß√£o) ap√≥s a cup
- Volume diminuindo na cup, aumentando no handle
- Dura√ß√£o: aproximadamente ${pattern?.bars || '20-60'} candles

üìå **Momento da estrutura:**

O Cup and Handle apareceu ${pattern?.context || 'ap√≥s movimento de alta'}, indicando poss√≠vel continua√ß√£o bullish. O padr√£o representa acumula√ß√£o antes de pr√≥ximo impulso altista.

üìà **Hist√≥rico t√©cnico:**

Padr√µes similares mostraram comportamento como:
- Taxa de rompimento altista: ${continuationRate}% nos √∫ltimos 50 dias
- Movimento m√©dio ap√≥s rompimento: 6-12% para cima
- Falsos rompimentos: aproximadamente 27% dos casos

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Cup and Handle costuma ser um padr√£o de continua√ß√£o bullish confi√°vel. Observar o volume no rompimento do handle √© crucial. O movimento ap√≥s rompimento geralmente mede a profundidade da cup. A forma√ß√£o pode levar v√°rias semanas para se completar.`;
  }
  // VCP
  if (patternType.includes('vcp') || patternType.includes('volatility contraction')) {
    const explosionRate = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, 'vcp');
    return `üîç **O que √©:**

VCP (Volatility Contraction Pattern) √© um padr√£o onde a volatilidade diminui progressivamente atrav√©s de m√∫ltiplas contra√ß√µes, preparando para explos√£o de movimento. Representa compress√£o de energia antes de expans√£o.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- M√∫ltiplas contra√ß√µes de volatilidade (2-4 contra√ß√µes)
- Volume diminuindo progressivamente
- Pre√ßo comprimindo em range cada vez menor
- Forma√ß√£o de base antes de explos√£o
- Dura√ß√£o: aproximadamente ${pattern?.bars || '15-40'} candles

üìå **Momento da estrutura:**

O VCP apareceu ${pattern?.context || 'ap√≥s movimento direcional'}, indicando compress√£o antes de poss√≠vel explos√£o. O padr√£o representa acumula√ß√£o de energia para movimento significativo.

üìà **Hist√≥rico t√©cnico:**

VCPs similares mostraram comportamento como:
- Taxa de explos√£o direcional: ${explosionRate}% nos √∫ltimos 45 dias
- Movimento m√©dio ap√≥s explos√£o: 5-10% na dire√ß√£o do rompimento
- Falsos rompimentos: aproximadamente 29% dos casos

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

VCP costuma preceder movimentos significativos. Observar o rompimento com volume √© crucial para validar a explos√£o. M√∫ltiplas contra√ß√µes aumentam a probabilidade de movimento forte. A dire√ß√£o do rompimento geralmente segue a tend√™ncia anterior.`;
  }
  // Diamante
  if (patternType.includes('diamante') || patternType.includes('diamond')) {
    const reversalRate = winRate || 69;
    const reversalRatePercent = (reversalRate * 100).toFixed(2); // üÜï Formatar para 2 casas decimais
    return `üîç **O que √©:**

Diamante √© um padr√£o de revers√£o raro onde o pre√ßo forma uma estrutura que se expande e depois se contrai, criando formato de diamante. Representa volatilidade crescente seguida de compress√£o antes de revers√£o.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- Expans√£o inicial de volatilidade
- Contra√ß√£o subsequente formando formato de diamante
- Volume aumentando na expans√£o, diminuindo na contra√ß√£o
- Forma√ß√£o em topo ou fundo
- Dura√ß√£o: aproximadamente ${pattern?.bars || '15-30'} candles

üìå **Momento da estrutura:**

O Diamante apareceu ${pattern?.context || 'em poss√≠vel topo/fundo'}, indicando poss√≠vel revers√£o. O padr√£o representa exaust√£o de volatilidade antes de mudan√ßa de dire√ß√£o.

üìà **Hist√≥rico t√©cnico:**

Diamantes similares mostraram comportamento como:
- Taxa de revers√£o: ${reversalRatePercent}% nos √∫ltimos 50 dias
- Movimento m√©dio ap√≥s revers√£o: 4-8% na dire√ß√£o oposta
- Falsos sinais: aproximadamente 31% dos casos

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.

üéØ **Leitura educacional:**

Diamante costuma ser um padr√£o de revers√£o, mas √© raro e requer confirma√ß√£o. Observar o rompimento do padr√£o confirma a revers√£o. Volume no rompimento √© crucial. O padr√£o √© mais significativo quando aparece em topo/fundo claro ap√≥s movimento forte.`;
  }
  // ===== FALLBACK GEN√âRICO =====
  const winRateFinal = winRate > 0 ? winRate : calculateEstimatedWinRate(technicalIndicators, score, patternName);
  return `üîç **O que √©:**

${patternName} √© um padr√£o t√©cnico identificado pela an√°lise de estrutura de mercado e comportamento de pre√ßo. Representa uma forma√ß√£o espec√≠fica que pode indicar poss√≠vel dire√ß√£o futura do mercado.

‚öôÔ∏è **Como foi detectado pelo modelo:**

- An√°lise de estrutura de pre√ßo e volume
- Identifica√ß√£o de padr√µes recorrentes
- Confirma√ß√£o atrav√©s de indicadores t√©cnicos
- Volume ${volumeFactor}x ${volume > 1 ? 'acima' : 'na'} m√©dia
- Alinhamento com contexto de mercado

üìå **Momento da estrutura:**

O padr√£o ${patternName} apareceu ${pattern?.context || 'em contexto de mercado'}, indicando poss√≠vel desenvolvimento de movimento. O padr√£o representa forma√ß√£o t√©cnica que pode influenciar comportamento futuro.

üìà **Hist√≥rico t√©cnico:**

${historicalContext || `Padr√µes similares mostraram comportamento como:
- Taxa de desenvolvimento: ${winRateFinal}% nos √∫ltimos 45 dias
- Movimento m√©dio ap√≥s forma√ß√£o: 2-5% na dire√ß√£o indicada
- Falsos sinais: aproximadamente ${100 - winRateFinal}% dos casos

Essa estat√≠stica descreve comportamento comum, sem garantia de resultado futuro.`}

üéØ **Leitura educacional:**

Este padr√£o costuma ser interpretado na an√°lise t√©cnica como ${score >= 70 ? 'sinal de qualidade' : score >= 50 ? 'sinal moderado' : 'sinal com ressalvas'}. Observar confirma√ß√£o atrav√©s de m√∫ltiplos indicadores t√©cnicos aumenta a confiabilidade. Volume e contexto de mercado s√£o cruciais para valida√ß√£o.`;
}
// ========== üé≤ GERADOR DE VARIA√á√ïES DE AN√ÅLISE T√âCNICA ==========
function getRecommendationVariation(score, patternName) {
  const variations = {
    high: [
      `An√°lise t√©cnica identificou m√∫ltiplas caracter√≠sticas t√©cnicas alinhadas para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou estrutura t√©cnica robusta para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas de qualidade para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas interessantes para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas s√≥lidas para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou m√∫ltiplos fatores t√©cnicos alinhados para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas de alta qualidade para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas consistentes para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas positivas para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas robustas para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`
    ],
    medium: [
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas interessantes para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas moderadas para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas moderadas para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas moderadas para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas moderadas para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas parciais para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas neutras-positivas para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas mistas para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas em desenvolvimento para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou aspectos t√©cnicos interessantes para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`
    ],
    low: [
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas de baixa qualidade para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou estrutura com caracter√≠sticas t√©cnicas insuficientes para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas fracas para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas de baixa qualidade para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas insuficientes para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas com ressalvas significativas para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas de risco elevado para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas fracas para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou caracter√≠sticas t√©cnicas insuficientes para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`,
      `An√°lise t√©cnica identificou estrutura t√©cnica fraca para o ${patternName}. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o.`
    ]
  };
  let category;
  if (score >= 70) category = 'high';
  else if (score >= 50) category = 'medium';
  else category = 'low';
  const categoryVariations = variations[category];
  const randomIndex = Math.floor(Math.random() * categoryVariations.length);
  return categoryVariations[randomIndex];
}
  // ========== üöÄ XENOVA FEW-SHOT LEARNING ==========
  /**
 * üß† Gera narra√ß√£o usando Xenova few-shot learning
 * Busca exemplos similares do banco e usa como contexto para gerar texto novo
 */ async function generateWithXenovaFewShot(score, signalType, patternName, confluences, technicalIndicators, marketData, pattern, supabase) {
  try {
    console.log('ü§ñ [XENOVA] Iniciando few-shot learning...');
    // 1. Buscar exemplos similares do banco
    const { data: exemplos, error: exemplosError } = await supabase.from('narrator_signals').select('narrative, metadata, pattern, confidence, created_at').ilike('pattern', `%${patternName}%`) // Padr√£o similar
      .gte('confidence', 70) // Apenas an√°lises boas
      .order('created_at', {
        ascending: false
      }).limit(5);
    if (exemplosError) {
      console.warn('‚ö†Ô∏è [XENOVA] Erro ao buscar exemplos:', exemplosError);
      return null;
    }
    if (!exemplos || exemplos.length < 3) {
      console.warn(`‚ö†Ô∏è [XENOVA] Poucos exemplos encontrados (${exemplos?.length || 0}), precisa de pelo menos 3`);
      return null;
    }
    console.log(`‚úÖ [XENOVA] Encontrados ${exemplos.length} exemplos similares`);
    // 2. Carregar modelo Xenova (usando modelo suportado)
    let generator;
    try {
      // @ts-expect-error - Xenova imports din√¢micos
      const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2');
      // ‚úÖ CORRE√á√ÉO: Usar modelo suportado (LaMini-Flan-T5 √© leve, r√°pido e confi√°vel para edge functions)
      generator = await pipeline('text2text-generation', 'Xenova/LaMini-Flan-T5-783M', {
        quantized: true,
        device: 'cpu' // Edge Function n√£o tem GPU garantida
      });
      console.log('‚úÖ [XENOVA] Modelo carregado com sucesso');
    } catch (modelError) {
      console.warn('‚ö†Ô∏è [XENOVA] Erro ao carregar modelo:', modelError?.message || modelError);
      return null;
    }
    // 3. Preparar dados do sinal atual
    const price = typeof marketData.price === 'string' ? parseFloat(marketData.price.replace(/[$,]/g, '')) : typeof marketData.price === 'number' ? marketData.price : 0;
    const rsi = technicalIndicators?.rsi_14 || technicalIndicators?.rsi || 'N/A';
    const ema9 = technicalIndicators?.ema_9 || 'N/A';
    const ema50 = technicalIndicators?.ema_50 || 'N/A';
    const volume = marketData.volume || 'N/A';
    const symbol = marketData.symbol || 'BTC/USDT';
    // 4. Criar prompt com few-shot learning
    // Extrair narrativa de narrative ou metadata->analystComment ou metadata->summary
    const exemplosTexto = exemplos.map((e, i) => {
      const narrationText = e.narrative || e.metadata?.analystComment || e.metadata?.summary || 'An√°lise t√©cnica gerada';
      return `üìä EXEMPLO ${i + 1}:\n${narrationText}`;
    }).join('\n\n---\n\n');
    const priceChange = marketData?.change24h
      ? (typeof marketData.change24h === 'string'
        ? parseFloat(marketData.change24h.replace('%', ''))
        : marketData.change24h)
      : 0;
    const changeSign = priceChange >= 0 ? '+' : '';

    const prompt = `Voc√™ √© o Narrador RICO da TradeVision IA, um analista t√©cnico profissional especializado em trading.

Sua miss√£o √© gerar an√°lises t√©cnicas educacionais, profissionais e com tom humano, sempre seguindo o estilo dos exemplos abaixo.

${exemplosTexto}

---

üìä AGORA, ANALISE ESTE NOVO SINAL:

üí∞ **Pre√ßo atual ${symbol}:** $${price.toLocaleString('pt-BR', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    })} (${changeSign}${priceChange.toFixed(2)}%)

- Padr√£o: ${patternName}
- Tipo: ${signalType}
- Score de Confian√ßa: ${score}%
- RSI: ${rsi}
- EMA9: ${ema9}
- EMA50: ${ema50}
- Volume: ${volume}

üìà Conflu√™ncias T√©cnicas (${confluences.length} ativas):
${confluences.slice(0, 10).map((c, i) => `${i + 1}. ${c}`).join('\n')}

üéØ SUA TAREFA:
Gere uma an√°lise t√©cnica completa, educacional e profissional no MESMO ESTILO dos exemplos acima, mas √öNICA e CONTEXTUALIZADA para este sinal espec√≠fico.

IMPORTANTE:
- SEMPRE comece mencionando o pre√ßo atual: "üí∞ Pre√ßo atual ${symbol}: $${price.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })} (${changeSign}${priceChange.toFixed(2)}%)"
- Use o mesmo tom profissional e educativo dos exemplos
- Seja espec√≠fico sobre este padr√£o e contexto
- Inclua gest√£o de risco se score < 70%
- Adicione disclaimer CVM 598/2018 no final
- Seja natural e humano, n√£o rob√≥tico

Comece a an√°lise agora:`;
    // 5. Gerar texto com Xenova
    console.log('üîÑ [XENOVA] Gerando texto...');
    const startTime = Date.now();
    const output = await generator(prompt, {
      max_new_tokens: 400,
      temperature: 0.7,
      do_sample: true,
      top_p: 0.9,
      repetition_penalty: 1.2 // Evitar repeti√ß√£o
    });
    const generationTime = Date.now() - startTime;
    console.log(`‚úÖ [XENOVA] Texto gerado em ${generationTime}ms`);
    // 6. Extrair texto gerado (text2text-generation retorna formato diferente)
    let generatedText = '';
    if (output) {
      // text2text-generation pode retornar objeto ou array
      if (Array.isArray(output) && output.length > 0) {
        generatedText = output[0].generated_text || output[0] || '';
      } else if (typeof output === 'object' && output.generated_text) {
        generatedText = output.generated_text;
      } else if (typeof output === 'string') {
        generatedText = output;
      }
      // Remover o prompt do in√≠cio se presente
      if (generatedText && generatedText.includes(prompt)) {
        generatedText = generatedText.replace(prompt, '').trim();
      }
    }
    // 7. Validar qualidade do texto gerado
    if (!generatedText || generatedText.length < 200) {
      console.warn('‚ö†Ô∏è [XENOVA] Texto muito curto, rejeitando');
      return null;
    }
    // Verificar se n√£o √© muito repetitivo
    const words = generatedText.split(/\s+/);
    const uniqueWords = new Set(words);
    const repetitionRatio = uniqueWords.size / words.length;
    if (repetitionRatio < 0.3) {
      console.warn('‚ö†Ô∏è [XENOVA] Texto muito repetitivo, rejeitando');
      return null;
    }
    // 8. Adicionar disclaimer CVM completo se n√£o tiver
    if (!generatedText.includes('CVM 598/2018') && !generatedText.includes('disclaimer')) {
      generatedText += `\n\n‚ö†Ô∏è **AVISO IMPORTANTE - CVM 598/2018:**\n\nAs informa√ß√µes deste relat√≥rio s√£o geradas automaticamente por um modelo de an√°lise t√©cnica e servem unicamente para fins educacionais. N√£o constitui recomenda√ß√£o, sugest√£o, indica√ß√£o ou aconselhamento de compra, venda ou manuten√ß√£o de ativos financeiros. Este sistema n√£o √© consultor de valores mobili√°rios e n√£o realiza avalia√ß√£o de perfil de investidor. Decis√µes de investimento devem ser feitas pelo usu√°rio ou por profissional habilitado, em conformidade com a CVM 598/2018.`;
    }
    // 9. Adicionar nota sobre TradeVision IA
    if (!generatedText.includes('TradeVision IA')) {
      generatedText += `\n\nüß† *An√°lise gerada pela TradeVision IA usando ${confluences.length} conflu√™ncias t√©cnicas, dados multi-timeframe, banco de conhecimento (2000+ entradas) e aprendizado cont√≠nuo com feedback real dos usu√°rios.*`;
    }
    console.log(`‚úÖ [XENOVA] An√°lise gerada com sucesso (${generatedText.length} caracteres)`);
    return generatedText;
  } catch (error) {
    console.warn('‚ö†Ô∏è [XENOVA] Erro no few-shot learning:', error?.message || error);
    return null; // Retorna null para usar fallback
  }
}
// ========== üß† GERADOR DE COMENT√ÅRIO INTELIGENTE DO ANALISTA IA (V2 - SUPER MELHORIAS + XENOVA) ==========
async function generateAnalystComment(score, signalType, patternName, confluences, technicalIndicators, marketData, pattern, historicalStats, supabase // üÜï ADICIONAR: Supabase opcional para Xenova
) {
  console.log('ü§ñ Gerando coment√°rio inteligente do Analista IA (v2 - super melhorias + Xenova)...');
  // üö® DESABILITADO: XENOVA consome muito egress (3-5GB de downloads de modelo)
  // üÜï TENTAR XENOVA FEW-SHOT LEARNING (0% - DESABILITADO para reduzir custos)
  // C√≥digo Xenova removido para evitar erros de condi√ß√£o constante
  // üß† DEIXAR A IA TRABALHAR COM SUA INTELIG√äNCIA REAL
  // A TradeVision IA j√° tem acesso a:
  // - Banco de conhecimento (2000+ entradas e crescendo r√°pido!)
  // - Hist√≥rico de trades e feedback
  // - Dados multi-timeframe
  // - Conflu√™ncias calculadas dinamicamente
  // - Padr√µes hist√≥ricos e taxas de sucesso
  // Analisar elementos-chave para coment√°rio personalizado
  const hasRSI = confluences.some((c) => c.includes('RSI'));
  const hasEMA = confluences.some((c) => c.includes('EMA'));
  const hasVolume = confluences.some((c) => c.includes('Volume') || c.includes('volume'));
  const hasMACD = confluences.some((c) => c.includes('MACD'));
  const hasFeedback = confluences.some((c) => c.includes('Feedback'));
  const hasMultiTF = confluences.some((c) => c.includes('multi-timeframe'));
  const hasHistoricalSuccess = confluences.some((c) => c.includes('Taxa de sucesso'));
  // üîß CORRE√á√ÉO: Extrair feedback das conflu√™ncias OU usar historicalStats/patternMemory
  const feedbackConf = confluences.find((c) => c.includes('Feedback'));
  let feedbackRating = feedbackConf?.match(/(\d+\.?\d*)\s*\/\s*5/)?.[1];

  // Se n√£o encontrou nas conflu√™ncias, tentar usar historicalStats ou patternMemory
  if (!feedbackRating && historicalStats) {
    // Tentar calcular rating m√©dio do win_rate (win_rate de 0.8 = 4.0/5, win_rate de 0.5 = 2.5/5)
    if (historicalStats.win_rate !== undefined && historicalStats.win_rate !== null) {
      // ‚úÖ FIX 19/dez: Detectar se win_rate j√° √© percentual (>1)
      const rawWinRate = historicalStats.win_rate;
      const normalizedWinRate = rawWinRate > 1 ? rawWinRate / 100 : rawWinRate;
      feedbackRating = (normalizedWinRate * 5).toFixed(1); // Converter win_rate (0-1) para rating (0-5)
    }
  }

  const feedbackRatingNum = feedbackRating ? parseFloat(feedbackRating) : null;
  const isFeedbackBad = feedbackRatingNum !== null && feedbackRatingNum < 3.0;
  const isFeedbackGood = feedbackRatingNum !== null && feedbackRatingNum >= 4.0;

  // Extrair taxa de sucesso se existir
  const successConf = confluences.find((c) => c.includes('Taxa de sucesso'));
  let successRate = successConf?.match(/(\d+\.?\d*)%/)?.[1];

  // Se n√£o encontrou nas conflu√™ncias, usar historicalStats
  if (!successRate && historicalStats) {
    if (historicalStats.win_rate !== undefined && historicalStats.win_rate !== null) {
      // ‚úÖ FIX 19/dez: Detectar se win_rate j√° √© percentual (>1) para evitar double-multiplication
      // Banco armazena como 0.6471, mas √†s vezes pode vir como 64.71 de outras fontes
      const rawWinRate = historicalStats.win_rate;
      if (rawWinRate > 1) {
        // J√° √© percentual (64.71), n√£o multiplicar
        successRate = rawWinRate.toFixed(1);
      } else {
        // √â decimal (0.6471), converter para percentual
        successRate = (rawWinRate * 100).toFixed(1);
      }
    }
  }

  const successRateNum = successRate ? parseFloat(successRate) : null;
  const isSuccessLow = successRateNum !== null && successRateNum < 50;
  const isSuccessHigh = successRateNum !== null && successRateNum >= 70;
  // Extrair volume se existir
  const volumeConf = confluences.find((c) => c.includes('Volume') || c.includes('volume'));
  const isVolumeLow = volumeConf?.includes('baixo') || volumeConf?.includes('aus√™ncia');
  const isVolumeHigh = volumeConf?.includes('alto') || volumeConf?.includes('explosivo');
  // Determinar n√≠vel de confian√ßa em palavras
  let confidenceLevel = '';
  // ‚úÖ AJUSTE: Reduzir threshold de 80 para 65
  if (score >= 65) confidenceLevel = 'muito alta';
  else if (score >= 50) confidenceLevel = 'boa';
  else if (score >= 35) confidenceLevel = 'baixa';
  else confidenceLevel = 'muito baixa';
  // üéØ CONSTRUIR COMENT√ÅRIO INTELIGENTE BASEADO NO CONTEXTO
  let comment = '';

  // üÜï INCLUIR PRE√áO ATUAL NO IN√çCIO (MELHORADO v278)
  const currentPrice = typeof marketData?.price === 'string'
    ? parseFloat(marketData.price.replace(/[$,]/g, ''))
    : typeof marketData?.price === 'number'
      ? marketData.price
      : (marketData?.currentPrice || marketData?.close || 0);
  const priceChange = marketData?.change24h
    ? (typeof marketData.change24h === 'string'
      ? parseFloat(marketData.change24h.replace('%', ''))
      : marketData.change24h)
    : 0;
  const symbol = marketData?.symbol || 'BTC/USDT';

  if (currentPrice > 0) {
    const priceFormatted = currentPrice.toLocaleString('pt-BR', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    });
    const changeSign = priceChange >= 0 ? '+' : '';
    // ‚úÖ MELHORIA: Calcular varia√ß√£o absoluta em d√≥lares
    const absoluteChange = Math.abs(currentPrice * priceChange / 100);
    const absoluteFormatted = absoluteChange > 0
      ? ` ($${absoluteChange.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })})`
      : '';
    comment += `üí∞ **Pre√ßo atual ${symbol}:** $${priceFormatted} (${changeSign}${priceChange.toFixed(2)}%${absoluteFormatted})\n\n`;
  } else {
    console.warn(`‚ö†Ô∏è [NARRATOR] Pre√ßo n√£o dispon√≠vel para ${symbol}`, { marketData });
    comment += `üí∞ **${symbol}:** Pre√ßo em carregamento...\n\n`;
  }


  // Abertura contextual (EDUCACIONAL - sem recomenda√ß√£o)
  if (score >= 75) {
    comment += `üìä **An√°lise t√©cnica identificou padr√£o de alta qualidade.** O sistema identificou o padr√£o ${patternName} com score t√©cnico ${score}%. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o. `;
  } else if (score >= 55) {
    comment += `üìä **An√°lise t√©cnica identificou padr√£o interessante.** O sistema identificou o padr√£o ${patternName} com score t√©cnico ${score}%. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o. `;
  } else if (score >= 35) {
    comment += `üìä **An√°lise t√©cnica identificou padr√£o com ressalvas.** O sistema identificou o padr√£o ${patternName} com score t√©cnico ${score}%. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o. `;
  } else {
    comment += `üìä **An√°lise t√©cnica identificou padr√£o de baixa qualidade.** O sistema identificou o padr√£o ${patternName} com score t√©cnico ${score}%. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o. `;
  }
  // An√°lise do hist√≥rico (CR√çTICO)
  // üîß CORRE√á√ÉO: S√≥ mostrar mensagem se tiver dados reais (n√£o mostrar 0.0/5‚≠ê)
  if (feedbackRatingNum !== null || successRateNum !== null) {
    if (isFeedbackBad && isSuccessLow) {
      comment += `üìä **Dados hist√≥ricos do sistema:** O sistema identificou que este padr√£o teve avalia√ß√£o negativa (${feedbackRatingNum?.toFixed(1) || 'N/A'}/5‚≠ê) e taxa de sucesso hist√≥rica de ${successRateNum?.toFixed(1) || 'N/A'}% em ocorr√™ncias anteriores. O sistema ajustou o score t√©cnico para refletir este hist√≥rico. Esta informa√ß√£o √© meramente descritiva e n√£o constitui recomenda√ß√£o. `;
    } else if (isFeedbackBad) {
      comment += `üìä **Dados hist√≥ricos do sistema:** O sistema identificou que este padr√£o teve avalia√ß√£o negativa (${feedbackRatingNum?.toFixed(1) || 'N/A'}/5‚≠ê) em ocorr√™ncias anteriores. Esta informa√ß√£o √© meramente descritiva e n√£o constitui recomenda√ß√£o. `;
    } else if (isSuccessLow) {
      comment += `üìä **Dados hist√≥ricos do sistema:** O sistema identificou taxa de sucesso hist√≥rica de ${successRateNum?.toFixed(1) || 'N/A'}% para este padr√£o em ocorr√™ncias anteriores. O sistema ajustou o score t√©cnico para refletir este hist√≥rico. Esta informa√ß√£o √© meramente descritiva e n√£o constitui recomenda√ß√£o. `;
    } else if (isFeedbackGood && isSuccessHigh) {
      comment += `üìä **Dados hist√≥ricos do sistema:** O sistema identificou que este padr√£o teve avalia√ß√£o positiva (${feedbackRatingNum?.toFixed(1) || 'N/A'}/5‚≠ê) e taxa de sucesso hist√≥rica de ${successRateNum?.toFixed(1) || 'N/A'}% em ocorr√™ncias anteriores. Esta informa√ß√£o √© meramente descritiva e n√£o constitui recomenda√ß√£o. `;
    } else if (isSuccessHigh) {
      comment += `üìä **Dados hist√≥ricos do sistema:** O sistema identificou taxa de sucesso hist√≥rica de ${successRateNum?.toFixed(1) || 'N/A'}% para este padr√£o em ocorr√™ncias anteriores. Esta informa√ß√£o √© meramente descritiva e n√£o constitui recomenda√ß√£o. `;
    } else if (successRateNum !== null) {
      // Mostrar taxa de sucesso mesmo se n√£o for alta/baixa
      comment += `üìä **Dados hist√≥ricos do sistema:** Taxa de sucesso hist√≥rica de ${successRateNum.toFixed(1)}% para este padr√£o em ocorr√™ncias anteriores. Esta informa√ß√£o √© meramente descritiva e n√£o constitui recomenda√ß√£o. `;
    }
  }
  // An√°lise t√©cnica espec√≠fica
  if (hasRSI && hasEMA && hasMACD) {
    const rsiConf = confluences.find((c) => c.includes('RSI'));
    const emaConf = confluences.find((c) => c.includes('EMA'));
    const macdConf = confluences.find((c) => c.includes('MACD'));
    comment += `üî¨ **Indicadores t√©cnicos observados:** `;
    if (rsiConf?.includes('sobrevenda') || rsiConf?.includes('SOBREVENDA')) {
      comment += `RSI apresenta caracter√≠stica t√©cnica de sobrevenda, `;
    } else if (rsiConf?.includes('sobrecompra') || rsiConf?.includes('SOBRECOMPRA')) {
      comment += `RSI apresenta caracter√≠stica t√©cnica de sobrecompra, `;
    } else {
      comment += `RSI apresenta caracter√≠stica t√©cnica neutra, `;
    }
    if (emaConf?.includes('alinhadas') || emaConf?.includes('confirmada')) {
      comment += `EMAs apresentam alinhamento t√©cnico, `;
    } else {
      comment += `EMAs apresentam caracter√≠sticas t√©cnicas em fase de defini√ß√£o, `;
    }
    if (macdConf?.includes('bullish') || macdConf?.includes('confirmado')) {
      comment += `e MACD apresenta caracter√≠stica t√©cnica positiva. `;
    } else if (macdConf?.includes('bearish')) {
      comment += `por√©m MACD apresenta caracter√≠stica t√©cnica divergente. `;
    } else {
      comment += `e MACD apresenta caracter√≠sticas t√©cnicas ainda em defini√ß√£o. `;
    }
  }
  // An√°lise de volume (EDUCACIONAL)
  if (isVolumeLow) {
    comment += `üìä **An√°lise de volume:** Volume abaixo da m√©dia hist√≥rica apresenta caracter√≠sticas t√©cnicas observadas. Esta an√°lise t√©cnica descreve caracter√≠sticas do mercado, sem constituir recomenda√ß√£o. `;
  } else if (isVolumeHigh) {
    comment += `üìä **An√°lise de volume:** Volume acima da m√©dia hist√≥rica apresenta caracter√≠sticas t√©cnicas observadas. Esta an√°lise t√©cnica descreve caracter√≠sticas do mercado, sem constituir recomenda√ß√£o. `;
  }
  // Multi-timeframe (EDUCACIONAL)
  if (hasMultiTF) {
    const mtConf = confluences.find((c) => c.includes('multi-timeframe'));
    if (mtConf?.includes('ALINHADA')) {
      comment += `üìä **An√°lise multi-timeframe:** O sistema identificou alinhamento t√©cnico entre os timeframes M1, M5, M15 e M30. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o. `;
    } else if (mtConf?.includes('divergente') || mtConf?.includes('DIVERG√äNCIA')) {
      // Tentar extrair detalhes da diverg√™ncia das conflu√™ncias
      const divergenceDetails = mtConf.match(/M\d+\s+\w+\s+vs\s+M\d+\s+\w+/i) ||
        mtConf.match(/M\d+.*M\d+/i);
      if (divergenceDetails) {
        comment += `üìä **An√°lise multi-timeframe:** O sistema identificou diverg√™ncia t√©cnica entre timeframes (${divergenceDetails[0]}). Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o. `;
      } else {
        comment += `üìä **An√°lise multi-timeframe:** O sistema identificou diverg√™ncia t√©cnica entre os timeframes M1, M5, M15 e M30. Esta an√°lise descreve caracter√≠sticas t√©cnicas observadas, sem constituir recomenda√ß√£o. `;
      }
    }
  }
  // üÜï BUSCAR HIST√ìRICO REAL DO PADR√ÉO SE N√ÉO FOI PASSADO
  let patternHistoricalStats = historicalStats || {};
  if (!patternHistoricalStats || !patternHistoricalStats.total_occurrences || patternHistoricalStats.total_occurrences === 0) {
    // Tentar buscar do Pattern Memory se dispon√≠vel
    if (supabase) {
      try {
        const patternHash = `${patternName}_${marketData.symbol}_${marketData.timeframe || '1m'}`;
        const { data: patternMemoryData } = await supabase
          .from('ai_pattern_memory')
          .select('id, pattern_name, win_rate, total_occurrences, wins, losses, confidence_level, adaptive_weight, created_at, last_seen, updated_at')
          .or(`pattern_hash.eq.${patternHash},pattern_name.eq.${patternName}`)
          .order('win_rate', { ascending: false })
          .limit(1)
          .maybeSingle();


        if (patternMemoryData) {
          const firstOccurrence = patternMemoryData.created_at || patternMemoryData.last_updated;
          const daysSinceFirst = firstOccurrence ?
            Math.floor((Date.now() - new Date(firstOccurrence).getTime()) / (1000 * 60 * 60 * 24)) : 30;

          patternHistoricalStats = {
            win_rate: patternMemoryData.win_rate || 0,
            total_occurrences: patternMemoryData.total_occurrences || patternMemoryData.total_trades || 0,
            wins: patternMemoryData.wins || 0,
            losses: patternMemoryData.losses || 0,
            days_since_first: daysSinceFirst,
            confidence_level: patternMemoryData.confidence_level || 'low',
            adaptive_weight: patternMemoryData.adaptive_weight || 1.0
          };
          console.log('‚úÖ Hist√≥rico real encontrado para explica√ß√£o do padr√£o:', {
            pattern: patternName,
            win_rate: patternHistoricalStats.win_rate,
            total_occurrences: patternHistoricalStats.total_occurrences
          });
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Erro ao buscar hist√≥rico do padr√£o:', error);
      }
    }
  }

  // üÜï EXPLICA√á√ÉO ESPEC√çFICA DO PADR√ÉO (EDUCACIONAL) - COM DADOS REAIS OU CALCULADOS
  const patternExplanation = generatePatternSpecificExplanation(patternName, pattern || {}, score, marketData, technicalIndicators, patternHistoricalStats);
  // üÜï AN√ÅLISE T√âCNICA VARIADA E PERSONALIZADA
  const recommendationVariation = getRecommendationVariation(score, patternName);
  // Montar an√°lise final com explica√ß√£o educacional
  comment += `\n\nüí° **An√°lise TradeVision IA - ${patternName}:**\n\n${patternExplanation}\n\n**An√°lise t√©cnica:** ${recommendationVariation}`;
  // Nota educacional sobre gest√£o de risco (sem recomenda√ß√£o)
  if (score >= 70) {
    comment += ` Esta an√°lise t√©cnica descreve caracter√≠sticas observadas. Lembre-se que gest√£o de risco √© importante em qualquer opera√ß√£o.`;
  } else if (score >= 50) {
    comment += ` Esta an√°lise t√©cnica descreve caracter√≠sticas observadas. Lembre-se que gest√£o de risco √© importante em qualquer opera√ß√£o.`;
  }
  // Observa√ß√£o sobre aprendizado
  comment += `\n\nüß† *An√°lise gerada pela TradeVision IA usando ${confluences.length} conflu√™ncias t√©cnicas, dados multi-timeframe, banco de conhecimento (2000+ entradas) e aprendizado cont√≠nuo com feedback real dos usu√°rios.*`;
  // ‚ö†Ô∏è DISCLAIMER OBRIGAT√ìRIO CVM (VERS√ÉO COMPLETA)
  comment += `\n\n‚ö†Ô∏è **AVISO IMPORTANTE - CVM 598/2018:**\n\nAs informa√ß√µes deste relat√≥rio s√£o geradas automaticamente por um modelo de an√°lise t√©cnica e servem unicamente para fins educacionais. N√£o constitui recomenda√ß√£o, sugest√£o, indica√ß√£o ou aconselhamento de compra, venda ou manuten√ß√£o de ativos financeiros. Este sistema n√£o √© consultor de valores mobili√°rios e n√£o realiza avalia√ß√£o de perfil de investidor. Decis√µes de investimento devem ser feitas pelo usu√°rio ou por profissional habilitado, em conformidade com a CVM 598/2018.`;
  console.log('‚úÖ Coment√°rio do Analista IA gerado:', comment.substring(0, 100) + '...');
  return comment;
}

